/* MACHINE GENERATED By Halide. */

#if !(__cplusplus >= 201103L || _MSVC_LANG >= 201103L)
#error "This code requires C++11 (or later); please upgrade your compiler."
#endif

#include <assert.h>
#include <fenv.h>
#include <float.h>
#include <limits.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <type_traits>

extern "C" {
int64_t halide_current_time_ns(void *ctx);
void halide_profiler_pipeline_end(void *, void *);
struct halide_buffer_t;
char *halide_buffer_to_string(char *, char *, const halide_buffer_t *);
}

#ifdef _WIN32
#ifndef _MT
__declspec(dllimport) float __cdecl roundf(float);
__declspec(dllimport) double __cdecl round(double);
#endif
#else
inline float asinh_f32(float x) {
    return asinhf(x);
}
inline float acosh_f32(float x) {
    return acoshf(x);
}
inline float atanh_f32(float x) {
    return atanhf(x);
}
inline double asinh_f64(double x) {
    return asinh(x);
}
inline double acosh_f64(double x) {
    return acosh(x);
}
inline double atanh_f64(double x) {
    return atanh(x);
}
#endif
inline float sqrt_f32(float x) {
    return sqrtf(x);
}
inline float sin_f32(float x) {
    return sinf(x);
}
inline float asin_f32(float x) {
    return asinf(x);
}
inline float cos_f32(float x) {
    return cosf(x);
}
inline float acos_f32(float x) {
    return acosf(x);
}
inline float tan_f32(float x) {
    return tanf(x);
}
inline float atan_f32(float x) {
    return atanf(x);
}
inline float atan2_f32(float x, float y) {
    return atan2f(x, y);
}
inline float sinh_f32(float x) {
    return sinhf(x);
}
inline float cosh_f32(float x) {
    return coshf(x);
}
inline float tanh_f32(float x) {
    return tanhf(x);
}
inline float hypot_f32(float x, float y) {
    return hypotf(x, y);
}
inline float exp_f32(float x) {
    return expf(x);
}
inline float log_f32(float x) {
    return logf(x);
}
inline float pow_f32(float x, float y) {
    return powf(x, y);
}
inline float floor_f32(float x) {
    return floorf(x);
}
inline float ceil_f32(float x) {
    return ceilf(x);
}

inline double sqrt_f64(double x) {
    return sqrt(x);
}
inline double sin_f64(double x) {
    return sin(x);
}
inline double asin_f64(double x) {
    return asin(x);
}
inline double cos_f64(double x) {
    return cos(x);
}
inline double acos_f64(double x) {
    return acos(x);
}
inline double tan_f64(double x) {
    return tan(x);
}
inline double atan_f64(double x) {
    return atan(x);
}
inline double atan2_f64(double x, double y) {
    return atan2(x, y);
}
inline double sinh_f64(double x) {
    return sinh(x);
}
inline double cosh_f64(double x) {
    return cosh(x);
}
inline double tanh_f64(double x) {
    return tanh(x);
}
inline double hypot_f64(double x, double y) {
    return hypot(x, y);
}
inline double exp_f64(double x) {
    return exp(x);
}
inline double log_f64(double x) {
    return log(x);
}
inline double pow_f64(double x, double y) {
    return pow(x, y);
}
inline double floor_f64(double x) {
    return floor(x);
}
inline double ceil_f64(double x) {
    return ceil(x);
}

inline float nan_f32() {
    return NAN;
}
inline float neg_inf_f32() {
    return -INFINITY;
}
inline float inf_f32() {
    return INFINITY;
}
inline bool is_nan_f32(float x) {
    return isnan(x);
}
inline bool is_nan_f64(double x) {
    return isnan(x);
}
inline bool is_inf_f32(float x) {
    return isinf(x);
}
inline bool is_inf_f64(double x) {
    return isinf(x);
}
inline bool is_finite_f32(float x) {
    return isfinite(x);
}
inline bool is_finite_f64(double x) {
    return isfinite(x);
}

template<typename A, typename B>
inline A reinterpret(const B &b) {
    static_assert(sizeof(A) == sizeof(B), "type size mismatch");
    A a;
    memcpy(&a, &b, sizeof(a));
    return a;
}

inline float float_from_bits(uint32_t bits) {
    return reinterpret<float, uint32_t>(bits);
}

template<typename T>
inline int halide_popcount_fallback(T a) {
    int bits_set = 0;
    while (a != 0) {
        bits_set += 1;
        // See: https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan
        a &= a - 1;
    }
    return bits_set;
}

template<typename T>
inline int halide_popcount(T a) {
    return halide_popcount_fallback<T>(a);
}

template<>
inline int halide_popcount<uint64_t>(uint64_t a) {
#ifdef _MSC_VER
#if defined(_WIN64)
    return __popcnt64(a);
#else
    return __popcnt((uint32_t)(a >> 32)) + __popcnt((uint32_t)(a & 0xffffffff));
#endif
#else
#if defined(__builtin_popcountll)
    static_assert(sizeof(unsigned long long) >= sizeof(uint64_t), "");
    return return __builtin_popcountll(a);
#else
    return halide_popcount_fallback<uint64_t>(a);
#endif
#endif
}

template<typename T>
inline int halide_count_leading_zeros(T a) {
    int leading_zeros = 0;
    int bit = sizeof(a) * 8 - 1;
    while (bit >= 0 && (a & (((T)1) << bit)) == 0) {
        leading_zeros++;
        bit--;
    }
    return leading_zeros;
}

template<typename T>
inline int halide_count_trailing_zeros(T a) {
    int trailing_zeros = 0;
    constexpr int bits = sizeof(a) * 8;
    int bit = 0;
    while (bit < bits && (a & (((T)1) << bit)) == 0) {
        trailing_zeros++;
        bit++;
    }
    return trailing_zeros;
}

template<typename T>
inline T halide_cpp_max(const T &a, const T &b) {
    return (a > b) ? a : b;
}

template<typename T>
inline T halide_cpp_min(const T &a, const T &b) {
    return (a < b) ? a : b;
}

template<typename T>
inline void halide_maybe_unused(const T &) {
}

template<typename A, typename B>
const B &return_second(const A &a, const B &b) {
    halide_maybe_unused(a);
    return b;
}

namespace {
template<void (*FreeFn)(void *, void *)>
class HalideFreeHelper {
    void *const user_context;
    void *ptr;

public:
    HalideFreeHelper(void *user_context, void *ptr)
        : user_context(user_context), ptr(ptr) {
    }
    ~HalideFreeHelper() {
        free();
    }
    void free() {
        if (ptr) {
            FreeFn(user_context, ptr);
            ptr = nullptr;
        }
    }
};

}  // namespace

#ifndef HALIDE_HALIDERUNTIME_H
#define HALIDE_HALIDERUNTIME_H

#ifndef COMPILING_HALIDE_RUNTIME
#ifdef __cplusplus
#include <array>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <string_view>
#else
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>
#endif
#else
#include "runtime_internal.h"
#endif

#ifdef __cplusplus
// Forward declare type to allow naming typed handles.
// See Type.h for documentation.
template<typename T>
struct halide_handle_traits;
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
// Note that (for MSVC) you should not use "inline" along with HALIDE_ALWAYS_INLINE;
// it is not necessary, and may produce warnings for some build configurations.
#define HALIDE_ALWAYS_INLINE __forceinline
#define HALIDE_NEVER_INLINE __declspec(noinline)
#else
// Note that (for Posixy compilers) you should always use "inline" along with HALIDE_ALWAYS_INLINE;
// otherwise some corner-case scenarios may erroneously report link errors.
#define HALIDE_ALWAYS_INLINE inline __attribute__((always_inline))
#define HALIDE_NEVER_INLINE __attribute__((noinline))
#endif

#ifndef HALIDE_MUST_USE_RESULT
#ifdef __has_attribute
#if __has_attribute(nodiscard)
// C++17 or later
#define HALIDE_MUST_USE_RESULT [[nodiscard]]
#elif __has_attribute(warn_unused_result)
// Clang/GCC
#define HALIDE_MUST_USE_RESULT __attribute__((warn_unused_result))
#else
#define HALIDE_MUST_USE_RESULT
#endif
#else
#define HALIDE_MUST_USE_RESULT
#endif
#endif

// Annotation for AOT and JIT calls -- if undefined, use no annotation.
// To ensure that all results are checked, do something like
//
//    -DHALIDE_FUNCTION_ATTRS=HALIDE_MUST_USE_RESULT
//
// in your C++ compiler options
#ifndef HALIDE_FUNCTION_ATTRS
#define HALIDE_FUNCTION_ATTRS
#endif

#ifndef HALIDE_EXPORT_SYMBOL
#ifdef _MSC_VER
#define HALIDE_EXPORT_SYMBOL __declspec(dllexport)
#else
#define HALIDE_EXPORT_SYMBOL __attribute__((visibility("default")))
#endif
#endif

#ifndef COMPILING_HALIDE_RUNTIME

// clang had _Float16 added as a reserved name in clang 8, but
// doesn't actually support it on most platforms until clang 15.
// Ideally there would be a better way to detect if the type
// is supported, even in a compiler independent fashion, but
// coming up with one has proven elusive.
#if defined(__clang__) && (__clang_major__ >= 16) && !defined(__EMSCRIPTEN__)
#if defined(__is_identifier)
#if !__is_identifier(_Float16)
#define HALIDE_CPP_COMPILER_HAS_FLOAT16
#endif
#endif
#endif

// Similarly, detecting _Float16 for gcc is problematic.
// For now, we say that if >= v12, and compiling on x86 or arm,
// we assume support. This may need revision.
#if defined(__GNUC__) && (__GNUC__ >= 12)
#if defined(__x86_64__) || defined(__i386__) || defined(__arm__) || defined(__aarch64__)
#define HALIDE_CPP_COMPILER_HAS_FLOAT16
#endif
#endif

#endif  // !COMPILING_HALIDE_RUNTIME

/** \file
 *
 * This file declares the routines used by Halide internally in its
 * runtime. On platforms that support weak linking, these can be
 * replaced with user-defined versions by defining an extern "C"
 * function with the same name and signature.
 *
 * When doing Just In Time (JIT) compilation members of
 * some_pipeline_or_func.jit_handlers() must be replaced instead. The
 * corresponding methods are documented below.
 *
 * All of these functions take a "void *user_context" parameter as their
 * first argument; if the Halide kernel that calls back to any of these
 * functions has been compiled with the UserContext feature set on its Target,
 * then the value of that pointer passed from the code that calls the
 * Halide kernel is piped through to the function.
 *
 * Some of these are also useful to call when using the default
 * implementation. E.g. halide_shutdown_thread_pool.
 *
 * Note that even on platforms with weak linking, some linker setups
 * may not respect the override you provide. E.g. if the override is
 * in a shared library and the halide object files are linked directly
 * into the output, the builtin versions of the runtime functions will
 * be called. See your linker documentation for more details. On
 * Linux, LD_DYNAMIC_WEAK=1 may help.
 *
 */

// Forward-declare to suppress warnings if compiling as C.
struct halide_buffer_t;

/** Print a message to stderr. Main use is to support tracing
 * functionality, print, and print_when calls. Also called by the default
 * halide_error.  This function can be replaced in JITed code by using
 * halide_custom_print and providing an implementation of halide_print
 * in AOT code. See Func::set_custom_print.
 */
// @{
extern void halide_print(void *user_context, const char *);
extern void halide_default_print(void *user_context, const char *);
typedef void (*halide_print_t)(void *, const char *);
extern halide_print_t halide_set_custom_print(halide_print_t print);
// @}

/** Halide calls this function on runtime errors (for example bounds
 * checking failures). This function can be replaced in JITed code by
 * using Func::set_error_handler, or in AOT code by calling
 * halide_set_error_handler. In AOT code on platforms that support
 * weak linking (i.e. not Windows), you can also override it by simply
 * defining your own halide_error.
 */
// @{
extern void halide_error(void *user_context, const char *);
extern void halide_default_error(void *user_context, const char *);
typedef void (*halide_error_handler_t)(void *, const char *);
extern halide_error_handler_t halide_set_error_handler(halide_error_handler_t handler);
// @}

/** Cross-platform mutex. Must be initialized with zero and implementation
 * must treat zero as an unlocked mutex with no waiters, etc.
 */
struct halide_mutex {
    uintptr_t _private[1];
};

/** Cross platform condition variable. Must be initialized to 0. */
struct halide_cond {
    uintptr_t _private[1];
};

/** A basic set of mutex and condition variable functions, which call
 * platform specific code for mutual exclusion. Equivalent to posix
 * calls. */
//@{
extern void halide_mutex_lock(struct halide_mutex *mutex);
extern void halide_mutex_unlock(struct halide_mutex *mutex);
extern void halide_cond_signal(struct halide_cond *cond);
extern void halide_cond_broadcast(struct halide_cond *cond);
extern void halide_cond_wait(struct halide_cond *cond, struct halide_mutex *mutex);
//@}

/** Functions for constructing/destroying/locking/unlocking arrays of mutexes. */
struct halide_mutex_array;
//@{
extern struct halide_mutex_array *halide_mutex_array_create(int sz);
extern void halide_mutex_array_destroy(void *user_context, void *array);
extern int halide_mutex_array_lock(struct halide_mutex_array *array, int entry);
extern int halide_mutex_array_unlock(struct halide_mutex_array *array, int entry);
//@}

/** Define halide_do_par_for to replace the default thread pool
 * implementation. halide_shutdown_thread_pool can also be called to
 * release resources used by the default thread pool on platforms
 * where it makes sense. See Func::set_custom_do_task and
 * Func::set_custom_do_par_for. Should return zero if all the jobs
 * return zero, or an arbitrarily chosen return value from one of the
 * jobs otherwise.
 */
//@{
typedef int (*halide_task_t)(void *user_context, int task_number, uint8_t *closure);
extern int halide_do_par_for(void *user_context,
                             halide_task_t task,
                             int min, int size, uint8_t *closure);
extern void halide_shutdown_thread_pool();
//@}

/** Set a custom method for performing a parallel for loop. Returns
 * the old do_par_for handler. */
typedef int (*halide_do_par_for_t)(void *, halide_task_t, int, int, uint8_t *);
extern halide_do_par_for_t halide_set_custom_do_par_for(halide_do_par_for_t do_par_for);

/** An opaque struct representing a semaphore. Used by the task system for async tasks. */
struct halide_semaphore_t {
    uint64_t _private[2];
};

/** A struct representing a semaphore and a number of items that must
 * be acquired from it. Used in halide_parallel_task_t below. */
struct halide_semaphore_acquire_t {
    struct halide_semaphore_t *semaphore;
    int count;
};
extern int halide_semaphore_init(struct halide_semaphore_t *, int n);
extern int halide_semaphore_release(struct halide_semaphore_t *, int n);
extern bool halide_semaphore_try_acquire(struct halide_semaphore_t *, int n);
typedef int (*halide_semaphore_init_t)(struct halide_semaphore_t *, int);
typedef int (*halide_semaphore_release_t)(struct halide_semaphore_t *, int);
typedef bool (*halide_semaphore_try_acquire_t)(struct halide_semaphore_t *, int);

/** A task representing a serial for loop evaluated over some range.
 * Note that task_parent is a pass through argument that should be
 * passed to any dependent taks that are invoked using halide_do_parallel_tasks
 * underneath this call. */
typedef int (*halide_loop_task_t)(void *user_context, int min, int extent,
                                  uint8_t *closure, void *task_parent);

/** A parallel task to be passed to halide_do_parallel_tasks. This
 * task may recursively call halide_do_parallel_tasks, and there may
 * be complex dependencies between seemingly unrelated tasks expressed
 * using semaphores. If you are using a custom task system, care must
 * be taken to avoid potential deadlock. This can be done by carefully
 * respecting the static metadata at the end of the task struct.*/
struct halide_parallel_task_t {
    // The function to call. It takes a user context, a min and
    // extent, a closure, and a task system pass through argument.
    halide_loop_task_t fn;

    // The closure to pass it
    uint8_t *closure;

    // The name of the function to be called. For debugging purposes only.
    const char *name;

    // An array of semaphores that must be acquired before the
    // function is called. Must be reacquired for every call made.
    struct halide_semaphore_acquire_t *semaphores;
    int num_semaphores;

    // The entire range the function should be called over. This range
    // may be sliced up and the function called multiple times.
    int min, extent;

    // A parallel task provides several pieces of metadata to prevent
    // unbounded resource usage or deadlock.

    // The first is the minimum number of execution contexts (call
    // stacks or threads) necessary for the function to run to
    // completion. This may be greater than one when there is nested
    // parallelism with internal producer-consumer relationships
    // (calling the function recursively spawns and blocks on parallel
    // sub-tasks that communicate with each other via semaphores). If
    // a parallel runtime calls the function when fewer than this many
    // threads are idle, it may need to create more threads to
    // complete the task, or else risk deadlock due to committing all
    // threads to tasks that cannot complete without more.
    //
    // FIXME: Note that extern stages are assumed to only require a
    // single thread to complete. If the extern stage is itself a
    // Halide pipeline, this may be an underestimate.
    int min_threads;

    // The calls to the function should be in serial order from min to min+extent-1, with only
    // one executing at a time. If false, any order is fine, and
    // concurrency is fine.
    bool serial;
};

/** Enqueue some number of the tasks described above and wait for them
 * to complete. While waiting, the calling threads assists with either
 * the tasks enqueued, or other non-blocking tasks in the task
 * system. Note that task_parent should be NULL for top-level calls
 * and the pass through argument if this call is being made from
 * another task. */
extern int halide_do_parallel_tasks(void *user_context, int num_tasks,
                                    struct halide_parallel_task_t *tasks,
                                    void *task_parent);

/** If you use the default do_par_for, you can still set a custom
 * handler to perform each individual task. Returns the old handler. */
//@{
typedef int (*halide_do_task_t)(void *, halide_task_t, int, uint8_t *);
extern halide_do_task_t halide_set_custom_do_task(halide_do_task_t do_task);
extern int halide_do_task(void *user_context, halide_task_t f, int idx,
                          uint8_t *closure);
//@}

/** The version of do_task called for loop tasks. By default calls the
 * loop task with the same arguments. */
// @{
typedef int (*halide_do_loop_task_t)(void *, halide_loop_task_t, int, int, uint8_t *, void *);
extern halide_do_loop_task_t halide_set_custom_do_loop_task(halide_do_loop_task_t do_task);
extern int halide_do_loop_task(void *user_context, halide_loop_task_t f, int min, int extent,
                               uint8_t *closure, void *task_parent);
//@}

/** Provide an entire custom tasking runtime via function
 * pointers. Note that do_task and semaphore_try_acquire are only ever
 * called by halide_default_do_par_for and
 * halide_default_do_parallel_tasks, so it's only necessary to provide
 * those if you are mixing in the default implementations of
 * do_par_for and do_parallel_tasks. */
// @{
typedef int (*halide_do_parallel_tasks_t)(void *, int, struct halide_parallel_task_t *,
                                          void *task_parent);
extern void halide_set_custom_parallel_runtime(
    halide_do_par_for_t,
    halide_do_task_t,
    halide_do_loop_task_t,
    halide_do_parallel_tasks_t,
    halide_semaphore_init_t,
    halide_semaphore_try_acquire_t,
    halide_semaphore_release_t);
// @}

/** The default versions of the parallel runtime functions. */
// @{
extern int halide_default_do_par_for(void *user_context,
                                     halide_task_t task,
                                     int min, int size, uint8_t *closure);
extern int halide_default_do_parallel_tasks(void *user_context,
                                            int num_tasks,
                                            struct halide_parallel_task_t *tasks,
                                            void *task_parent);
extern int halide_default_do_task(void *user_context, halide_task_t f, int idx,
                                  uint8_t *closure);
extern int halide_default_do_loop_task(void *user_context, halide_loop_task_t f,
                                       int min, int extent,
                                       uint8_t *closure, void *task_parent);
extern int halide_default_semaphore_init(struct halide_semaphore_t *, int n);
extern int halide_default_semaphore_release(struct halide_semaphore_t *, int n);
extern bool halide_default_semaphore_try_acquire(struct halide_semaphore_t *, int n);
// @}

struct halide_thread;

/** Spawn a thread. Returns a handle to the thread for the purposes of
 * joining it. The thread must be joined in order to clean up any
 * resources associated with it. */
extern struct halide_thread *halide_spawn_thread(void (*f)(void *), void *closure);

/** Join a thread. */
extern void halide_join_thread(struct halide_thread *);

/** Set the number of threads used by Halide's thread pool. Returns
 * the old number.
 *
 * n < 0  : error condition
 * n == 0 : use a reasonable system default (typically, number of cpus online).
 * n == 1 : use exactly one thread; this will always enforce serial execution
 * n > 1  : use a pool of exactly n threads.
 *
 * (Note that this is only guaranteed when using the default implementations
 * of halide_do_par_for(); custom implementations may completely ignore values
 * passed to halide_set_num_threads().)
 */
extern int halide_set_num_threads(int n);

/** Halide calls these functions to allocate and free memory. To
 * replace in AOT code, use the halide_set_custom_malloc and
 * halide_set_custom_free, or (on platforms that support weak
 * linking), simply define these functions yourself. In JIT-compiled
 * code use Func::set_custom_allocator.
 *
 * If you override them, and find yourself wanting to call the default
 * implementation from within your override, use
 * halide_default_malloc/free.
 *
 * Note that halide_malloc must return a pointer aligned to the
 * maximum meaningful alignment for the platform for the purpose of
 * vector loads and stores, *and* with an allocated size that is (at least)
 * an integral multiple of that same alignment. The default implementation
 * uses 32-byte alignment on arm and 64-byte alignment on x86. Additionally,
 * it must be safe to read at least 8 bytes before the start and beyond the end.
 */
//@{
extern void *halide_malloc(void *user_context, size_t x);
extern void halide_free(void *user_context, void *ptr);
extern void *halide_default_malloc(void *user_context, size_t x);
extern void halide_default_free(void *user_context, void *ptr);
typedef void *(*halide_malloc_t)(void *, size_t);
typedef void (*halide_free_t)(void *, void *);
extern halide_malloc_t halide_set_custom_malloc(halide_malloc_t user_malloc);
extern halide_free_t halide_set_custom_free(halide_free_t user_free);
//@}

/** Halide calls these functions to interact with the underlying
 * system runtime functions. To replace in AOT code on platforms that
 * support weak linking, define these functions yourself, or use
 * the halide_set_custom_load_library() and halide_set_custom_get_library_symbol()
 * functions. In JIT-compiled code, use JITSharedRuntime::set_default_handlers().
 *
 * halide_load_library and halide_get_library_symbol are equivalent to
 * dlopen and dlsym. halide_get_symbol(sym) is equivalent to
 * dlsym(RTLD_DEFAULT, sym).
 */
//@{
extern void *halide_get_symbol(const char *name);
extern void *halide_load_library(const char *name);
extern void *halide_get_library_symbol(void *lib, const char *name);
extern void *halide_default_get_symbol(const char *name);
extern void *halide_default_load_library(const char *name);
extern void *halide_default_get_library_symbol(void *lib, const char *name);
typedef void *(*halide_get_symbol_t)(const char *name);
typedef void *(*halide_load_library_t)(const char *name);
typedef void *(*halide_get_library_symbol_t)(void *lib, const char *name);
extern halide_get_symbol_t halide_set_custom_get_symbol(halide_get_symbol_t user_get_symbol);
extern halide_load_library_t halide_set_custom_load_library(halide_load_library_t user_load_library);
extern halide_get_library_symbol_t halide_set_custom_get_library_symbol(halide_get_library_symbol_t user_get_library_symbol);
//@}

/** Called when debug_to_file is used inside %Halide code.  See
 * Func::debug_to_file for how this is called
 *
 * Cannot be replaced in JITted code at present.
 */
extern int32_t halide_debug_to_file(void *user_context, const char *filename,
                                    int32_t type_code,
                                    struct halide_buffer_t *buf);

/** Types in the halide type system. They can be ints, unsigned ints,
 * or floats (of various bit-widths), or a handle (which is always 64-bits).
 * Note that the int/uint/float values do not imply a specific bit width
 * (the bit width is expected to be encoded in a separate value).
 */
typedef enum halide_type_code_t
#if (__cplusplus >= 201103L || _MSVC_LANG >= 201103L)
    : uint8_t
#endif
{
    halide_type_int = 0,     ///< signed integers
    halide_type_uint = 1,    ///< unsigned integers
    halide_type_float = 2,   ///< IEEE floating point numbers
    halide_type_handle = 3,  ///< opaque pointer type (void *)
    halide_type_bfloat = 4,  ///< floating point numbers in the bfloat format
} halide_type_code_t;

// Note that while __attribute__ can go before or after the declaration,
// __declspec apparently is only allowed before.
#ifndef HALIDE_ATTRIBUTE_ALIGN
#ifdef _MSC_VER
#define HALIDE_ATTRIBUTE_ALIGN(x) __declspec(align(x))
#else
#define HALIDE_ATTRIBUTE_ALIGN(x) __attribute__((aligned(x)))
#endif
#endif

/** A runtime tag for a type in the halide type system. Can be ints,
 * unsigned ints, or floats of various bit-widths (the 'bits'
 * field). Can also be vectors of the same (by setting the 'lanes'
 * field to something larger than one). This struct should be
 * exactly 32-bits in size. */
struct halide_type_t {
    /** The basic type code: signed integer, unsigned integer, or floating point. */
#if (__cplusplus >= 201103L || _MSVC_LANG >= 201103L)
    HALIDE_ATTRIBUTE_ALIGN(1)
    halide_type_code_t code;  // halide_type_code_t
#else
    HALIDE_ATTRIBUTE_ALIGN(1)
    uint8_t code;  // halide_type_code_t
#endif

    /** The number of bits of precision of a single scalar value of this type. */
    HALIDE_ATTRIBUTE_ALIGN(1)
    uint8_t bits;

    /** How many elements in a vector. This is 1 for scalar types. */
    HALIDE_ATTRIBUTE_ALIGN(2)
    uint16_t lanes;

#if (__cplusplus >= 201103L || _MSVC_LANG >= 201103L)
    /** Construct a runtime representation of a Halide type from:
     * code: The fundamental type from an enum.
     * bits: The bit size of one element.
     * lanes: The number of vector elements in the type. */
    HALIDE_ALWAYS_INLINE constexpr halide_type_t(halide_type_code_t code, uint8_t bits, uint16_t lanes = 1)
        : code(code), bits(bits), lanes(lanes) {
    }

    /** Default constructor is required e.g. to declare halide_trace_event
     * instances. */
    HALIDE_ALWAYS_INLINE constexpr halide_type_t()
        : code((halide_type_code_t)0), bits(0), lanes(0) {
    }

    HALIDE_ALWAYS_INLINE constexpr halide_type_t with_lanes(uint16_t new_lanes) const {
        return halide_type_t((halide_type_code_t)code, bits, new_lanes);
    }

    HALIDE_ALWAYS_INLINE constexpr halide_type_t element_of() const {
        return with_lanes(1);
    }
    /** Compare two types for equality. */
    HALIDE_ALWAYS_INLINE constexpr bool operator==(const halide_type_t &other) const {
        return as_u32() == other.as_u32();
    }

    HALIDE_ALWAYS_INLINE constexpr bool operator!=(const halide_type_t &other) const {
        return !(*this == other);
    }

    HALIDE_ALWAYS_INLINE constexpr bool operator<(const halide_type_t &other) const {
        return as_u32() < other.as_u32();
    }

    /** Size in bytes for a single element, even if width is not 1, of this type. */
    HALIDE_ALWAYS_INLINE constexpr int bytes() const {
        return (bits + 7) / 8;
    }

    HALIDE_ALWAYS_INLINE constexpr uint32_t as_u32() const {
        // Note that this produces a result that is identical to memcpy'ing 'this'
        // into a u32 (on a little-endian machine, anyway), and at -O1 or greater
        // on Clang, the compiler knows this and optimizes this into a single 32-bit move.
        // (At -O0 it will look awful.)
        return static_cast<uint8_t>(code) |
               (static_cast<uint16_t>(bits) << 8) |
               (static_cast<uint32_t>(lanes) << 16);
    }
#endif
};

#if (__cplusplus >= 201103L || _MSVC_LANG >= 201103L)
static_assert(sizeof(halide_type_t) == sizeof(uint32_t), "size mismatch in halide_type_t");
#endif

enum halide_trace_event_code_t { halide_trace_load = 0,
                                 halide_trace_store = 1,
                                 halide_trace_begin_realization = 2,
                                 halide_trace_end_realization = 3,
                                 halide_trace_produce = 4,
                                 halide_trace_end_produce = 5,
                                 halide_trace_consume = 6,
                                 halide_trace_end_consume = 7,
                                 halide_trace_begin_pipeline = 8,
                                 halide_trace_end_pipeline = 9,
                                 halide_trace_tag = 10 };

struct halide_trace_event_t {
    /** The name of the Func or Pipeline that this event refers to */
    const char *func;

    /** If the event type is a load or a store, this points to the
     * value being loaded or stored. Use the type field to safely cast
     * this to a concrete pointer type and retrieve it. For other
     * events this is null. */
    void *value;

    /** For loads and stores, an array which contains the location
     * being accessed. For vector loads or stores it is an array of
     * vectors of coordinates (the vector dimension is innermost).
     *
     * For realization or production-related events, this will contain
     * the mins and extents of the region being accessed, in the order
     * min0, extent0, min1, extent1, ...
     *
     * For pipeline-related events, this will be null.
     */
    int32_t *coordinates;

    /** For halide_trace_tag, this points to a read-only null-terminated string
     * of arbitrary text. For all other events, this will be null.
     */
    const char *trace_tag;

    /** If the event type is a load or a store, this is the type of
     * the data. Otherwise, the value is meaningless. */
    struct halide_type_t type;

    /** The type of event */
    enum halide_trace_event_code_t event;

    /* The ID of the parent event (see below for an explanation of
     * event ancestry). */
    int32_t parent_id;

    /** If this was a load or store of a Tuple-valued Func, this is
     * which tuple element was accessed. */
    int32_t value_index;

    /** The length of the coordinates array */
    int32_t dimensions;
};

/** Called when Funcs are marked as trace_load, trace_store, or
 * trace_realization. See Func::set_custom_trace. The default
 * implementation either prints events via halide_print, or if
 * HL_TRACE_FILE is defined, dumps the trace to that file in a
 * sequence of trace packets. The header for a trace packet is defined
 * below. If the trace is going to be large, you may want to make the
 * file a named pipe, and then read from that pipe into gzip.
 *
 * halide_trace returns a unique ID which will be passed to future
 * events that "belong" to the earlier event as the parent id. The
 * ownership hierarchy looks like:
 *
 * begin_pipeline
 * +--trace_tag (if any)
 * +--trace_tag (if any)
 * ...
 * +--begin_realization
 * |  +--produce
 * |  |  +--load/store
 * |  |  +--end_produce
 * |  +--consume
 * |  |  +--load
 * |  |  +--end_consume
 * |  +--end_realization
 * +--end_pipeline
 *
 * Threading means that ownership cannot be inferred from the ordering
 * of events. There can be many active realizations of a given
 * function, or many active productions for a single
 * realization. Within a single production, the ordering of events is
 * meaningful.
 *
 * Note that all trace_tag events (if any) will occur just after the begin_pipeline
 * event, but before any begin_realization events. All trace_tags for a given Func
 * will be emitted in the order added.
 */
// @}
extern int32_t halide_trace(void *user_context, const struct halide_trace_event_t *event);
extern int32_t halide_default_trace(void *user_context, const struct halide_trace_event_t *event);
typedef int32_t (*halide_trace_t)(void *user_context, const struct halide_trace_event_t *);
extern halide_trace_t halide_set_custom_trace(halide_trace_t trace);
// @}

/** The header of a packet in a binary trace. All fields are 32-bit. */
struct halide_trace_packet_t {
    /** The total size of this packet in bytes. Always a multiple of
     * four. Equivalently, the number of bytes until the next
     * packet. */
    uint32_t size;

    /** The id of this packet (for the purpose of parent_id). */
    int32_t id;

    /** The remaining fields are equivalent to those in halide_trace_event_t */
    // @{
    struct halide_type_t type;
    enum halide_trace_event_code_t event;
    int32_t parent_id;
    int32_t value_index;
    int32_t dimensions;
    // @}

#if (__cplusplus >= 201103L || _MSVC_LANG >= 201103L)
    /** Get the coordinates array, assuming this packet is laid out in
     * memory as it was written. The coordinates array comes
     * immediately after the packet header. */
    HALIDE_ALWAYS_INLINE const int *coordinates() const {
        return (const int *)(this + 1);
    }

    HALIDE_ALWAYS_INLINE int *coordinates() {
        return (int *)(this + 1);
    }

    /** Get the value, assuming this packet is laid out in memory as
     * it was written. The packet comes immediately after the coordinates
     * array. */
    HALIDE_ALWAYS_INLINE const void *value() const {
        return (const void *)(coordinates() + dimensions);
    }

    HALIDE_ALWAYS_INLINE void *value() {
        return (void *)(coordinates() + dimensions);
    }

    /** Get the func name, assuming this packet is laid out in memory
     * as it was written. It comes after the value. */
    HALIDE_ALWAYS_INLINE const char *func() const {
        return (const char *)value() + type.lanes * type.bytes();
    }

    HALIDE_ALWAYS_INLINE char *func() {
        return (char *)value() + type.lanes * type.bytes();
    }

    /** Get the trace_tag (if any), assuming this packet is laid out in memory
     * as it was written. It comes after the func name. If there is no trace_tag,
     * this will return a pointer to an empty string. */
    HALIDE_ALWAYS_INLINE const char *trace_tag() const {
        const char *f = func();
        // strlen may not be available here
        while (*f++) {
            // nothing
        }
        return f;
    }

    HALIDE_ALWAYS_INLINE char *trace_tag() {
        char *f = func();
        // strlen may not be available here
        while (*f++) {
            // nothing
        }
        return f;
    }
#endif
};

/** Set the file descriptor that Halide should write binary trace
 * events to. If called with 0 as the argument, Halide outputs trace
 * information to stdout in a human-readable format. If never called,
 * Halide checks the for existence of an environment variable called
 * HL_TRACE_FILE and opens that file. If HL_TRACE_FILE is not defined,
 * it outputs trace information to stdout in a human-readable
 * format. */
extern void halide_set_trace_file(int fd);

/** Halide calls this to retrieve the file descriptor to write binary
 * trace events to. The default implementation returns the value set
 * by halide_set_trace_file. Implement it yourself if you wish to use
 * a custom file descriptor per user_context. Return zero from your
 * implementation to tell Halide to print human-readable trace
 * information to stdout. */
extern int halide_get_trace_file(void *user_context);

/** If tracing is writing to a file. This call closes that file
 * (flushing the trace). Returns zero on success. */
extern int halide_shutdown_trace();

/** All Halide GPU or device backend implementations provide an
 * interface to be used with halide_device_malloc, etc. This is
 * accessed via the functions below.
 */

/** An opaque struct containing per-GPU API implementations of the
 * device functions. */
struct halide_device_interface_impl_t;

/** Each GPU API provides a halide_device_interface_t struct pointing
 * to the code that manages device allocations. You can access these
 * functions directly from the struct member function pointers, or by
 * calling the functions declared below. Note that the global
 * functions are not available when using Halide as a JIT compiler.
 * If you are using raw halide_buffer_t in that context you must use
 * the function pointers in the device_interface struct.
 *
 * The function pointers below are currently the same for every GPU
 * API; only the impl field varies. These top-level functions do the
 * bookkeeping that is common across all GPU APIs, and then dispatch
 * to more API-specific functions via another set of function pointers
 * hidden inside the impl field.
 */
struct halide_device_interface_t {
    int (*device_malloc)(void *user_context, struct halide_buffer_t *buf,
                         const struct halide_device_interface_t *device_interface);
    int (*device_free)(void *user_context, struct halide_buffer_t *buf);
    int (*device_sync)(void *user_context, struct halide_buffer_t *buf);
    void (*device_release)(void *user_context,
                           const struct halide_device_interface_t *device_interface);
    int (*copy_to_host)(void *user_context, struct halide_buffer_t *buf);
    int (*copy_to_device)(void *user_context, struct halide_buffer_t *buf,
                          const struct halide_device_interface_t *device_interface);
    int (*device_and_host_malloc)(void *user_context, struct halide_buffer_t *buf,
                                  const struct halide_device_interface_t *device_interface);
    int (*device_and_host_free)(void *user_context, struct halide_buffer_t *buf);
    int (*buffer_copy)(void *user_context, struct halide_buffer_t *src,
                       const struct halide_device_interface_t *dst_device_interface, struct halide_buffer_t *dst);
    int (*device_crop)(void *user_context, const struct halide_buffer_t *src,
                       struct halide_buffer_t *dst);
    int (*device_slice)(void *user_context, const struct halide_buffer_t *src,
                        int slice_dim, int slice_pos, struct halide_buffer_t *dst);
    int (*device_release_crop)(void *user_context, struct halide_buffer_t *buf);
    int (*wrap_native)(void *user_context, struct halide_buffer_t *buf, uint64_t handle,
                       const struct halide_device_interface_t *device_interface);
    int (*detach_native)(void *user_context, struct halide_buffer_t *buf);
    int (*compute_capability)(void *user_context, int *major, int *minor);
    const struct halide_device_interface_impl_t *impl;
};

/** Release all data associated with the given device interface, in
 * particular all resources (memory, texture, context handles)
 * allocated by Halide. Must be called explicitly when using AOT
 * compilation. This is *not* thread-safe with respect to actively
 * running Halide code. Ensure all pipelines are finished before
 * calling this. */
extern void halide_device_release(void *user_context,
                                  const struct halide_device_interface_t *device_interface);

/** Copy image data from device memory to host memory. This must be called
 * explicitly to copy back the results of a GPU-based filter. */
extern int halide_copy_to_host(void *user_context, struct halide_buffer_t *buf);

/** Copy image data from host memory to device memory. This should not
 * be called directly; Halide handles copying to the device
 * automatically.  If interface is NULL and the buf has a non-zero dev
 * field, the device associated with the dev handle will be
 * used. Otherwise if the dev field is 0 and interface is NULL, an
 * error is returned. */
extern int halide_copy_to_device(void *user_context, struct halide_buffer_t *buf,
                                 const struct halide_device_interface_t *device_interface);

/** Copy data from one buffer to another. The buffers may have
 * different shapes and sizes, but the destination buffer's shape must
 * be contained within the source buffer's shape. That is, for each
 * dimension, the min on the destination buffer must be greater than
 * or equal to the min on the source buffer, and min+extent on the
 * destination buffer must be less that or equal to min+extent on the
 * source buffer. The source data is pulled from either device or
 * host memory on the source, depending on the dirty flags. host is
 * preferred if both are valid. The dst_device_interface parameter
 * controls the destination memory space. NULL means host memory. */
extern int halide_buffer_copy(void *user_context, struct halide_buffer_t *src,
                              const struct halide_device_interface_t *dst_device_interface,
                              struct halide_buffer_t *dst);

/** Give the destination buffer a device allocation which is an alias
 * for the same coordinate range in the source buffer. Modifies the
 * device, device_interface, and the device_dirty flag only. Only
 * supported by some device APIs (others will return
 * halide_error_code_device_crop_unsupported). Call
 * halide_device_release_crop instead of halide_device_free to clean
 * up resources associated with the cropped view. Do not free the
 * device allocation on the source buffer while the destination buffer
 * still lives. Note that the two buffers do not share dirty flags, so
 * care must be taken to update them together as needed. Note that src
 * and dst are required to have the same number of dimensions.
 *
 * Note also that (in theory) device interfaces which support cropping may
 * still not support cropping a crop (instead, create a new crop of the parent
 * buffer); in practice, no known implementation has this limitation, although
 * it is possible that some future implementations may require it. */
extern int halide_device_crop(void *user_context,
                              const struct halide_buffer_t *src,
                              struct halide_buffer_t *dst);

/** Give the destination buffer a device allocation which is an alias
 * for a similar coordinate range in the source buffer, but with one dimension
 * sliced away in the dst. Modifies the device, device_interface, and the
 * device_dirty flag only. Only supported by some device APIs (others will return
 * halide_error_code_device_crop_unsupported). Call
 * halide_device_release_crop instead of halide_device_free to clean
 * up resources associated with the sliced view. Do not free the
 * device allocation on the source buffer while the destination buffer
 * still lives. Note that the two buffers do not share dirty flags, so
 * care must be taken to update them together as needed. Note that the dst buffer
 * must have exactly one fewer dimension than the src buffer, and that slice_dim
 * and slice_pos must be valid within src. */
extern int halide_device_slice(void *user_context,
                               const struct halide_buffer_t *src,
                               int slice_dim, int slice_pos,
                               struct halide_buffer_t *dst);

/** Release any resources associated with a cropped/sliced view of another
 * buffer. */
extern int halide_device_release_crop(void *user_context,
                                      struct halide_buffer_t *buf);

/** Wait for current GPU operations to complete. Calling this explicitly
 * should rarely be necessary, except maybe for profiling. */
extern int halide_device_sync(void *user_context, struct halide_buffer_t *buf);

/** Allocate device memory to back a halide_buffer_t. */
extern int halide_device_malloc(void *user_context, struct halide_buffer_t *buf,
                                const struct halide_device_interface_t *device_interface);

/** Free device memory. */
extern int halide_device_free(void *user_context, struct halide_buffer_t *buf);

/** Wrap or detach a native device handle, setting the device field
 * and device_interface field as appropriate for the given GPU
 * API. The meaning of the opaque handle is specific to the device
 * interface, so if you know the device interface in use, call the
 * more specific functions in the runtime headers for your specific
 * device API instead (e.g. HalideRuntimeCuda.h). */
// @{
extern int halide_device_wrap_native(void *user_context,
                                     struct halide_buffer_t *buf,
                                     uint64_t handle,
                                     const struct halide_device_interface_t *device_interface);
extern int halide_device_detach_native(void *user_context, struct halide_buffer_t *buf);
// @}

/** Selects which gpu device to use. 0 is usually the display
 * device. If never called, Halide uses the environment variable
 * HL_GPU_DEVICE. If that variable is unset, Halide uses the last
 * device. Set this to -1 to use the last device. */
extern void halide_set_gpu_device(int n);

/** Halide calls this to get the desired halide gpu device
 * setting. Implement this yourself to use a different gpu device per
 * user_context. The default implementation returns the value set by
 * halide_set_gpu_device, or the environment variable
 * HL_GPU_DEVICE. */
extern int halide_get_gpu_device(void *user_context);

/** Set the soft maximum amount of memory, in bytes, that the LRU
 *  cache will use to memoize Func results.  This is not a strict
 *  maximum in that concurrency and simultaneous use of memoized
 *  reults larger than the cache size can both cause it to
 *  temporariliy be larger than the size specified here.
 */
extern void halide_memoization_cache_set_size(int64_t size);

/** Given a cache key for a memoized result, currently constructed
 *  from the Func name and top-level Func name plus the arguments of
 *  the computation, determine if the result is in the cache and
 *  return it if so. (The internals of the cache key should be
 *  considered opaque by this function.) If this routine returns true,
 *  it is a cache miss. Otherwise, it will return false and the
 *  buffers passed in will be filled, via copying, with memoized
 *  data. The last argument is a list if halide_buffer_t pointers which
 *  represents the outputs of the memoized Func. If the Func does not
 *  return a Tuple, there will only be one halide_buffer_t in the list. The
 *  tuple_count parameters determines the length of the list.
 *
 * The return values are:
 * -1: Signals an error.
 *  0: Success and cache hit.
 *  1: Success and cache miss.
 */
extern int halide_memoization_cache_lookup(void *user_context, const uint8_t *cache_key, int32_t size,
                                           struct halide_buffer_t *realized_bounds,
                                           int32_t tuple_count, struct halide_buffer_t **tuple_buffers);

/** Given a cache key for a memoized result, currently constructed
 *  from the Func name and top-level Func name plus the arguments of
 *  the computation, store the result in the cache for futre access by
 *  halide_memoization_cache_lookup. (The internals of the cache key
 *  should be considered opaque by this function.) Data is copied out
 *  from the inputs and inputs are unmodified. The last argument is a
 *  list if halide_buffer_t pointers which represents the outputs of the
 *  memoized Func. If the Func does not return a Tuple, there will
 *  only be one halide_buffer_t in the list. The tuple_count parameters
 *  determines the length of the list.
 *
 * If there is a memory allocation failure, the store does not store
 * the data into the cache.
 *
 * If has_eviction_key is true, the entry is marked with eviction_key to
 * allow removing the key with halide_memoization_cache_evict.
 */
extern int halide_memoization_cache_store(void *user_context, const uint8_t *cache_key, int32_t size,
                                          struct halide_buffer_t *realized_bounds,
                                          int32_t tuple_count,
                                          struct halide_buffer_t **tuple_buffers,
                                          bool has_eviction_key, uint64_t eviction_key);

/** Evict all cache entries that were tagged with the given
 *  eviction_key in the memoize scheduling directive.
 */
extern void halide_memoization_cache_evict(void *user_context, uint64_t eviction_key);

/** If halide_memoization_cache_lookup succeeds,
 * halide_memoization_cache_release must be called to signal the
 * storage is no longer being used by the caller. It will be passed
 * the host pointer of one the buffers returned by
 * halide_memoization_cache_lookup. That is
 * halide_memoization_cache_release will be called multiple times for
 * the case where halide_memoization_cache_lookup is handling multiple
 * buffers.  (This corresponds to memoizing a Tuple in Halide.) Note
 * that the host pointer must be sufficient to get to all information
 * the release operation needs. The default Halide cache impleemntation
 * accomplishes this by storing extra data before the start of the user
 * modifiable host storage.
 *
 * This call is like free and does not have a failure return.
 */
extern void halide_memoization_cache_release(void *user_context, void *host);

/** Free all memory and resources associated with the memoization cache.
 * Must be called at a time when no other threads are accessing the cache.
 */
extern void halide_memoization_cache_cleanup();

/** Verify that a given range of memory has been initialized; only used when Target::MSAN is enabled.
 *
 * The default implementation simply calls the LLVM-provided __msan_check_mem_is_initialized() function.
 *
 * The return value should always be zero.
 */
extern int halide_msan_check_memory_is_initialized(void *user_context, const void *ptr, uint64_t len, const char *name);

/** Verify that the data pointed to by the halide_buffer_t is initialized (but *not* the halide_buffer_t itself),
 * using halide_msan_check_memory_is_initialized() for checking.
 *
 * The default implementation takes pains to only check the active memory ranges
 * (skipping padding), and sorting into ranges to always check the smallest number of
 * ranges, in monotonically increasing memory order.
 *
 * Most client code should never need to replace the default implementation.
 *
 * The return value should always be zero.
 */
extern int halide_msan_check_buffer_is_initialized(void *user_context, struct halide_buffer_t *buffer, const char *buf_name);

/** Annotate that a given range of memory has been initialized;
 * only used when Target::MSAN is enabled.
 *
 * The default implementation simply calls the LLVM-provided __msan_unpoison() function.
 *
 * The return value should always be zero.
 */
extern int halide_msan_annotate_memory_is_initialized(void *user_context, const void *ptr, uint64_t len);

/** Mark the data pointed to by the halide_buffer_t as initialized (but *not* the halide_buffer_t itself),
 * using halide_msan_annotate_memory_is_initialized() for marking.
 *
 * The default implementation takes pains to only mark the active memory ranges
 * (skipping padding), and sorting into ranges to always mark the smallest number of
 * ranges, in monotonically increasing memory order.
 *
 * Most client code should never need to replace the default implementation.
 *
 * The return value should always be zero.
 */
extern int halide_msan_annotate_buffer_is_initialized(void *user_context, struct halide_buffer_t *buffer);
extern void halide_msan_annotate_buffer_is_initialized_as_destructor(void *user_context, void *buffer);

/** The error codes that may be returned by a Halide pipeline. */
enum halide_error_code_t {
    /** There was no error. This is the value returned by Halide on success. */
    halide_error_code_success = 0,

    /** An uncategorized error occurred. Refer to the string passed to halide_error. */
    halide_error_code_generic_error = -1,

    /** A Func was given an explicit bound via Func::bound, but this
     * was not large enough to encompass the region that is used of
     * the Func by the rest of the pipeline. */
    halide_error_code_explicit_bounds_too_small = -2,

    /** The elem_size field of a halide_buffer_t does not match the size in
     * bytes of the type of that ImageParam. Probable type mismatch. */
    halide_error_code_bad_type = -3,

    /** A pipeline would access memory outside of the halide_buffer_t passed
     * in. */
    halide_error_code_access_out_of_bounds = -4,

    /** A halide_buffer_t was given that spans more than 2GB of memory. */
    halide_error_code_buffer_allocation_too_large = -5,

    /** A halide_buffer_t was given with extents that multiply to a number
     * greater than 2^31-1 */
    halide_error_code_buffer_extents_too_large = -6,

    /** Applying explicit constraints on the size of an input or
     * output buffer shrank the size of that buffer below what will be
     * accessed by the pipeline. */
    halide_error_code_constraints_make_required_region_smaller = -7,

    /** A constraint on a size or stride of an input or output buffer
     * was not met by the halide_buffer_t passed in. */
    halide_error_code_constraint_violated = -8,

    /** A scalar parameter passed in was smaller than its minimum
     * declared value. */
    halide_error_code_param_too_small = -9,

    /** A scalar parameter passed in was greater than its minimum
     * declared value. */
    halide_error_code_param_too_large = -10,

    /** A call to halide_malloc returned NULL. */
    halide_error_code_out_of_memory = -11,

    /** A halide_buffer_t pointer passed in was NULL. */
    halide_error_code_buffer_argument_is_null = -12,

    /** debug_to_file failed to open or write to the specified
     * file. */
    halide_error_code_debug_to_file_failed = -13,

    /** The Halide runtime encountered an error while trying to copy
     * from device to host. Turn on -debug in your target string to
     * see more details. */
    halide_error_code_copy_to_host_failed = -14,

    /** The Halide runtime encountered an error while trying to copy
     * from host to device. Turn on -debug in your target string to
     * see more details. */
    halide_error_code_copy_to_device_failed = -15,

    /** The Halide runtime encountered an error while trying to
     * allocate memory on device. Turn on -debug in your target string
     * to see more details. */
    halide_error_code_device_malloc_failed = -16,

    /** The Halide runtime encountered an error while trying to
     * synchronize with a device. Turn on -debug in your target string
     * to see more details. */
    halide_error_code_device_sync_failed = -17,

    /** The Halide runtime encountered an error while trying to free a
     * device allocation. Turn on -debug in your target string to see
     * more details. */
    halide_error_code_device_free_failed = -18,

    /** Buffer has a non-zero device but no device interface, which
     * violates a Halide invariant. */
    halide_error_code_no_device_interface = -19,

    /** This part of the Halide runtime is unimplemented on this platform. */
    halide_error_code_unimplemented = -20,

    /** A runtime symbol could not be loaded. */
    halide_error_code_symbol_not_found = -21,

    /** There is a bug in the Halide compiler. */
    halide_error_code_internal_error = -22,

    /** The Halide runtime encountered an error while trying to launch
     * a GPU kernel. Turn on -debug in your target string to see more
     * details. */
    halide_error_code_device_run_failed = -23,

    /** The Halide runtime encountered a host pointer that violated
     * the alignment set for it by way of a call to
     * set_host_alignment */
    halide_error_code_unaligned_host_ptr = -24,

    /** A fold_storage directive was used on a dimension that is not
     * accessed in a monotonically increasing or decreasing fashion. */
    halide_error_code_bad_fold = -25,

    /** A fold_storage directive was used with a fold factor that was
     * too small to store all the values of a producer needed by the
     * consumer. */
    halide_error_code_fold_factor_too_small = -26,

    /** User-specified require() expression was not satisfied. */
    halide_error_code_requirement_failed = -27,

    /** At least one of the buffer's extents are negative. */
    halide_error_code_buffer_extents_negative = -28,

    /** Call(s) to a GPU backend API failed. */
    halide_error_code_gpu_device_error = -29,

    /** Failure recording trace packets for one of the halide_target_feature_trace features. */
    halide_error_code_trace_failed = -30,

    /** A specialize_fail() schedule branch was selected at runtime. */
    halide_error_code_specialize_fail = -31,

    /** The Halide runtime encountered an error while trying to wrap a
     * native device handle.  Turn on -debug in your target string to
     * see more details. */
    halide_error_code_device_wrap_native_failed = -32,

    /** The Halide runtime encountered an error while trying to detach
     * a native device handle.  Turn on -debug in your target string
     * to see more details. */
    halide_error_code_device_detach_native_failed = -33,

    /** The host field on an input or output was null, the device
     * field was not zero, and the pipeline tries to use the buffer on
     * the host. You may be passing a GPU-only buffer to a pipeline
     * which is scheduled to use it on the CPU. */
    halide_error_code_host_is_null = -34,

    /** A folded buffer was passed to an extern stage, but the region
     * touched wraps around the fold boundary. */
    halide_error_code_bad_extern_fold = -35,

    /** Buffer has a non-null device_interface but device is 0, which
     * violates a Halide invariant. */
    halide_error_code_device_interface_no_device = -36,

    /** Buffer has both host and device dirty bits set, which violates
     * a Halide invariant. */
    halide_error_code_host_and_device_dirty = -37,

    /** The halide_buffer_t * passed to a halide runtime routine is
     * nullptr and this is not allowed. */
    halide_error_code_buffer_is_null = -38,

    /** The Halide runtime encountered an error while trying to copy
     * from one buffer to another. Turn on -debug in your target
     * string to see more details. */
    halide_error_code_device_buffer_copy_failed = -39,

    /** Attempted to make cropped/sliced alias of a buffer with a device
     * field, but the device_interface does not support cropping. */
    halide_error_code_device_crop_unsupported = -40,

    /** Cropping/slicing a buffer failed for some other reason. Turn on -debug
     * in your target string. */
    halide_error_code_device_crop_failed = -41,

    /** An operation on a buffer required an allocation on a
     * particular device interface, but a device allocation already
     * existed on a different device interface. Free the old one
     * first. */
    halide_error_code_incompatible_device_interface = -42,

    /** The dimensions field of a halide_buffer_t does not match the dimensions of that ImageParam. */
    halide_error_code_bad_dimensions = -43,

    /** A buffer with the device_dirty flag set was passed to a
     * pipeline compiled with no device backends enabled, so it
     * doesn't know how to copy the data back from device memory to
     * host memory. Either call copy_to_host before calling the Halide
     * pipeline, or enable the appropriate device backend. */
    halide_error_code_device_dirty_with_no_device_support = -44,

    /** An explicit storage bound provided is too small to store
     * all the values produced by the function. */
    halide_error_code_storage_bound_too_small = -45,
};

/** Halide calls the functions below on various error conditions. The
 * default implementations construct an error message, call
 * halide_error, then return the matching error code above. On
 * platforms that support weak linking, you can override these to
 * catch the errors individually. */

/** A call into an extern stage for the purposes of bounds inference
 * failed. Returns the error code given by the extern stage. */
extern int halide_error_bounds_inference_call_failed(void *user_context, const char *extern_stage_name, int result);

/** A call to an extern stage failed. Returned the error code given by
 * the extern stage. */
extern int halide_error_extern_stage_failed(void *user_context, const char *extern_stage_name, int result);

/** Various other error conditions. See the enum above for a
 * description of each. */
// @{
extern int halide_error_explicit_bounds_too_small(void *user_context, const char *func_name, const char *var_name,
                                                  int min_bound, int max_bound, int min_required, int max_required);
extern int halide_error_bad_type(void *user_context, const char *func_name,
                                 uint32_t type_given, uint32_t correct_type);  // N.B. The last two args are the bit representation of a halide_type_t
extern int halide_error_bad_dimensions(void *user_context, const char *func_name,
                                       int32_t dimensions_given, int32_t correct_dimensions);
extern int halide_error_access_out_of_bounds(void *user_context, const char *func_name,
                                             int dimension, int min_touched, int max_touched,
                                             int min_valid, int max_valid);
extern int halide_error_buffer_allocation_too_large(void *user_context, const char *buffer_name,
                                                    uint64_t allocation_size, uint64_t max_size);
extern int halide_error_buffer_extents_negative(void *user_context, const char *buffer_name, int dimension, int extent);
extern int halide_error_buffer_extents_too_large(void *user_context, const char *buffer_name,
                                                 int64_t actual_size, int64_t max_size);
extern int halide_error_constraints_make_required_region_smaller(void *user_context, const char *buffer_name,
                                                                 int dimension,
                                                                 int constrained_min, int constrained_extent,
                                                                 int required_min, int required_extent);
extern int halide_error_constraint_violated(void *user_context, const char *var, int val,
                                            const char *constrained_var, int constrained_val);
extern int halide_error_param_too_small_i64(void *user_context, const char *param_name,
                                            int64_t val, int64_t min_val);
extern int halide_error_param_too_small_u64(void *user_context, const char *param_name,
                                            uint64_t val, uint64_t min_val);
extern int halide_error_param_too_small_f64(void *user_context, const char *param_name,
                                            double val, double min_val);
extern int halide_error_param_too_large_i64(void *user_context, const char *param_name,
                                            int64_t val, int64_t max_val);
extern int halide_error_param_too_large_u64(void *user_context, const char *param_name,
                                            uint64_t val, uint64_t max_val);
extern int halide_error_param_too_large_f64(void *user_context, const char *param_name,
                                            double val, double max_val);
extern int halide_error_out_of_memory(void *user_context);
extern int halide_error_buffer_argument_is_null(void *user_context, const char *buffer_name);
extern int halide_error_debug_to_file_failed(void *user_context, const char *func,
                                             const char *filename, int error_code);
extern int halide_error_unaligned_host_ptr(void *user_context, const char *func_name, int alignment);
extern int halide_error_host_is_null(void *user_context, const char *func_name);
extern int halide_error_bad_fold(void *user_context, const char *func_name, const char *var_name,
                                 const char *loop_name);
extern int halide_error_bad_extern_fold(void *user_context, const char *func_name,
                                        int dim, int min, int extent, int valid_min, int fold_factor);

extern int halide_error_fold_factor_too_small(void *user_context, const char *func_name, const char *var_name,
                                              int fold_factor, const char *loop_name, int required_extent);
extern int halide_error_requirement_failed(void *user_context, const char *condition, const char *message);
extern int halide_error_specialize_fail(void *user_context, const char *message);
extern int halide_error_no_device_interface(void *user_context);
extern int halide_error_device_interface_no_device(void *user_context);
extern int halide_error_host_and_device_dirty(void *user_context);
extern int halide_error_buffer_is_null(void *user_context, const char *routine);
extern int halide_error_device_dirty_with_no_device_support(void *user_context, const char *buffer_name);
extern int halide_error_storage_bound_too_small(void *user_context, const char *func_name, const char *var_name,
                                                int provided_size, int required_size);
extern int halide_error_device_crop_failed(void *user_context);
// @}

/** Optional features a compilation Target can have.
 * Be sure to keep this in sync with the Feature enum in Target.h and the implementation of
 * get_runtime_compatible_target in Target.cpp if you add a new feature.
 */
typedef enum halide_target_feature_t {
    halide_target_feature_jit = 0,          ///< Generate code that will run immediately inside the calling process.
    halide_target_feature_debug,            ///< Turn on debug info and output for runtime code.
    halide_target_feature_no_asserts,       ///< Disable all runtime checks, for slightly tighter code.
    halide_target_feature_no_bounds_query,  ///< Disable the bounds querying functionality.

    halide_target_feature_sse41,  ///< Use SSE 4.1 and earlier instructions. Only relevant on x86.
    halide_target_feature_avx,    ///< Use AVX 1 instructions. Only relevant on x86.
    halide_target_feature_avx2,   ///< Use AVX 2 instructions. Only relevant on x86.
    halide_target_feature_fma,    ///< Enable x86 FMA instruction
    halide_target_feature_fma4,   ///< Enable x86 (AMD) FMA4 instruction set
    halide_target_feature_f16c,   ///< Enable x86 16-bit float support

    halide_target_feature_armv7s,   ///< Generate code for ARMv7s. Only relevant for 32-bit ARM.
    halide_target_feature_no_neon,  ///< Avoid using NEON instructions. Only relevant for 32-bit ARM.

    halide_target_feature_vsx,              ///< Use VSX instructions. Only relevant on POWERPC.
    halide_target_feature_power_arch_2_07,  ///< Use POWER ISA 2.07 new instructions. Only relevant on POWERPC.

    halide_target_feature_cuda,               ///< Enable the CUDA runtime. Defaults to compute capability 2.0 (Fermi)
    halide_target_feature_cuda_capability30,  ///< Enable CUDA compute capability 3.0 (Kepler)
    halide_target_feature_cuda_capability32,  ///< Enable CUDA compute capability 3.2 (Tegra K1)
    halide_target_feature_cuda_capability35,  ///< Enable CUDA compute capability 3.5 (Kepler)
    halide_target_feature_cuda_capability50,  ///< Enable CUDA compute capability 5.0 (Maxwell)
    halide_target_feature_cuda_capability61,  ///< Enable CUDA compute capability 6.1 (Pascal)
    halide_target_feature_cuda_capability70,  ///< Enable CUDA compute capability 7.0 (Volta)
    halide_target_feature_cuda_capability75,  ///< Enable CUDA compute capability 7.5 (Turing)
    halide_target_feature_cuda_capability80,  ///< Enable CUDA compute capability 8.0 (Ampere)
    halide_target_feature_cuda_capability86,  ///< Enable CUDA compute capability 8.6 (Ampere)

    halide_target_feature_opencl,       ///< Enable the OpenCL runtime.
    halide_target_feature_cl_doubles,   ///< Enable double support on OpenCL targets
    halide_target_feature_cl_atomic64,  ///< Enable 64-bit atomics operations on OpenCL targets

    halide_target_feature_openglcompute,  ///< Enable OpenGL Compute runtime. NOTE: This feature is deprecated and will be removed in Halide 17.

    halide_target_feature_user_context,  ///< Generated code takes a user_context pointer as first argument

    halide_target_feature_profile,     ///< Launch a sampling profiler alongside the Halide pipeline that monitors and reports the runtime used by each Func
    halide_target_feature_no_runtime,  ///< Do not include a copy of the Halide runtime in any generated object file or assembly

    halide_target_feature_metal,  ///< Enable the (Apple) Metal runtime.

    halide_target_feature_c_plus_plus_mangling,  ///< Generate C++ mangled names for result function, et al

    halide_target_feature_large_buffers,  ///< Enable 64-bit buffer indexing to support buffers > 2GB. Ignored if bits != 64.

    halide_target_feature_hvx_128,                ///< Enable HVX 128 byte mode.
    halide_target_feature_hvx_v62,                ///< Enable Hexagon v62 architecture.
    halide_target_feature_fuzz_float_stores,      ///< On every floating point store, set the last bit of the mantissa to zero. Pipelines for which the output is very different with this feature enabled may also produce very different output on different processors.
    halide_target_feature_soft_float_abi,         ///< Enable soft float ABI. This only enables the soft float ABI calling convention, which does not necessarily use soft floats.
    halide_target_feature_msan,                   ///< Enable hooks for MSAN support.
    halide_target_feature_avx512,                 ///< Enable the base AVX512 subset supported by all AVX512 architectures. The specific feature sets are AVX-512F and AVX512-CD. See https://en.wikipedia.org/wiki/AVX-512 for a description of each AVX subset.
    halide_target_feature_avx512_knl,             ///< Enable the AVX512 features supported by Knight's Landing chips, such as the Xeon Phi x200. This includes the base AVX512 set, and also AVX512-CD and AVX512-ER.
    halide_target_feature_avx512_skylake,         ///< Enable the AVX512 features supported by Skylake Xeon server processors. This adds AVX512-VL, AVX512-BW, and AVX512-DQ to the base set. The main difference from the base AVX512 set is better support for small integer ops. Note that this does not include the Knight's Landing features. Note also that these features are not available on Skylake desktop and mobile processors.
    halide_target_feature_avx512_cannonlake,      ///< Enable the AVX512 features expected to be supported by future Cannonlake processors. This includes all of the Skylake features, plus AVX512-IFMA and AVX512-VBMI.
    halide_target_feature_avx512_sapphirerapids,  ///< Enable the AVX512 features supported by Sapphire Rapids processors. This include all of the Cannonlake features, plus AVX512-VNNI and AVX512-BF16.
    halide_target_feature_trace_loads,            ///< Trace all loads done by the pipeline. Equivalent to calling Func::trace_loads on every non-inlined Func.
    halide_target_feature_trace_stores,           ///< Trace all stores done by the pipeline. Equivalent to calling Func::trace_stores on every non-inlined Func.
    halide_target_feature_trace_realizations,     ///< Trace all realizations done by the pipeline. Equivalent to calling Func::trace_realizations on every non-inlined Func.
    halide_target_feature_trace_pipeline,         ///< Trace the pipeline.
    halide_target_feature_hvx_v65,                ///< Enable Hexagon v65 architecture.
    halide_target_feature_hvx_v66,                ///< Enable Hexagon v66 architecture.
    halide_target_feature_cl_half,                ///< Enable half support on OpenCL targets
    halide_target_feature_strict_float,           ///< Turn off all non-IEEE floating-point optimization. Currently applies only to LLVM targets.
    halide_target_feature_tsan,                   ///< Enable hooks for TSAN support.
    halide_target_feature_asan,                   ///< Enable hooks for ASAN support.
    halide_target_feature_d3d12compute,           ///< Enable Direct3D 12 Compute runtime.
    halide_target_feature_check_unsafe_promises,  ///< Insert assertions for promises.
    halide_target_feature_hexagon_dma,            ///< Enable Hexagon DMA buffers.
    halide_target_feature_embed_bitcode,          ///< Emulate clang -fembed-bitcode flag.
    halide_target_feature_enable_llvm_loop_opt,   ///< Enable loop vectorization + unrolling in LLVM. Overrides halide_target_feature_disable_llvm_loop_opt. (Ignored for non-LLVM targets.)
    halide_target_feature_wasm_simd128,           ///< Enable +simd128 instructions for WebAssembly codegen.
    halide_target_feature_wasm_signext,           ///< Enable +sign-ext instructions for WebAssembly codegen.
    halide_target_feature_wasm_sat_float_to_int,  ///< Enable saturating (nontrapping) float-to-int instructions for WebAssembly codegen.
    halide_target_feature_wasm_threads,           ///< Enable use of threads in WebAssembly codegen. Requires the use of a wasm runtime that provides pthread-compatible wrappers (typically, Emscripten with the -pthreads flag). Unsupported under WASI.
    halide_target_feature_wasm_bulk_memory,       ///< Enable +bulk-memory instructions for WebAssembly codegen.
    halide_target_feature_webgpu,                 ///< Enable the WebGPU runtime.
    halide_target_feature_sve,                    ///< Enable ARM Scalable Vector Extensions
    halide_target_feature_sve2,                   ///< Enable ARM Scalable Vector Extensions v2
    halide_target_feature_egl,                    ///< Force use of EGL support.
    halide_target_feature_arm_dot_prod,           ///< Enable ARMv8.2-a dotprod extension (i.e. udot and sdot instructions)
    halide_target_feature_arm_fp16,               ///< Enable ARMv8.2-a half-precision floating point data processing
    halide_llvm_large_code_model,                 ///< Use the LLVM large code model to compile
    halide_target_feature_rvv,                    ///< Enable RISCV "V" Vector Extension
    halide_target_feature_armv81a,                ///< Enable ARMv8.1-a instructions
    halide_target_feature_sanitizer_coverage,     ///< Enable hooks for SanitizerCoverage support.
    halide_target_feature_profile_by_timer,       ///< Alternative to halide_target_feature_profile using timer interrupt for systems without threads or applicartions that need to avoid them.
    halide_target_feature_spirv,                  ///< Enable SPIR-V code generation support.
    halide_target_feature_vulkan,                 ///< Enable Vulkan runtime support.
    halide_target_feature_vulkan_int8,            ///< Enable Vulkan 8-bit integer support.
    halide_target_feature_vulkan_int16,           ///< Enable Vulkan 16-bit integer support.
    halide_target_feature_vulkan_int64,           ///< Enable Vulkan 64-bit integer support.
    halide_target_feature_vulkan_float16,         ///< Enable Vulkan 16-bit float support.
    halide_target_feature_vulkan_float64,         ///< Enable Vulkan 64-bit float support.
    halide_target_feature_vulkan_version10,       ///< Enable Vulkan v1.0 runtime target support.
    halide_target_feature_vulkan_version12,       ///< Enable Vulkan v1.2 runtime target support.
    halide_target_feature_vulkan_version13,       ///< Enable Vulkan v1.3 runtime target support.
    halide_target_feature_semihosting,            ///< Used together with Target::NoOS for the baremetal target built with semihosting library and run with semihosting mode where minimum I/O communication with a host PC is available.
    halide_target_feature_end                     ///< A sentinel. Every target is considered to have this feature, and setting this feature does nothing.
} halide_target_feature_t;

/** This function is called internally by Halide in some situations to determine
 * if the current execution environment can support the given set of
 * halide_target_feature_t flags. The implementation must do the following:
 *
 * -- If there are flags set in features that the function knows *cannot* be supported, return 0.
 * -- Otherwise, return 1.
 * -- Note that any flags set in features that the function doesn't know how to test should be ignored;
 * this implies that a return value of 1 means "not known to be bad" rather than "known to be good".
 *
 * In other words: a return value of 0 means "It is not safe to use code compiled with these features",
 * while a return value of 1 means "It is not obviously unsafe to use code compiled with these features".
 *
 * The default implementation simply calls halide_default_can_use_target_features.
 *
 * Note that `features` points to an array of `count` uint64_t; this array must contain enough
 * bits to represent all the currently known features. Any excess bits must be set to zero.
 */
// @{
extern int halide_can_use_target_features(int count, const uint64_t *features);
typedef int (*halide_can_use_target_features_t)(int count, const uint64_t *features);
extern halide_can_use_target_features_t halide_set_custom_can_use_target_features(halide_can_use_target_features_t);
// @}

/**
 * This is the default implementation of halide_can_use_target_features; it is provided
 * for convenience of user code that may wish to extend halide_can_use_target_features
 * but continue providing existing support, e.g.
 *
 *     int halide_can_use_target_features(int count, const uint64_t *features) {
 *          if (features[halide_target_somefeature >> 6] & (1LL << (halide_target_somefeature & 63))) {
 *              if (!can_use_somefeature()) {
 *                  return 0;
 *              }
 *          }
 *          return halide_default_can_use_target_features(count, features);
 *     }
 */
extern int halide_default_can_use_target_features(int count, const uint64_t *features);

typedef struct halide_dimension_t {
#if (__cplusplus >= 201103L || _MSVC_LANG >= 201103L)
    int32_t min = 0, extent = 0, stride = 0;

    // Per-dimension flags. None are defined yet (This is reserved for future use).
    uint32_t flags = 0;

    HALIDE_ALWAYS_INLINE halide_dimension_t() = default;
    HALIDE_ALWAYS_INLINE halide_dimension_t(int32_t m, int32_t e, int32_t s, uint32_t f = 0)
        : min(m), extent(e), stride(s), flags(f) {
    }

    HALIDE_ALWAYS_INLINE bool operator==(const halide_dimension_t &other) const {
        return (min == other.min) &&
               (extent == other.extent) &&
               (stride == other.stride) &&
               (flags == other.flags);
    }

    HALIDE_ALWAYS_INLINE bool operator!=(const halide_dimension_t &other) const {
        return !(*this == other);
    }
#else
    int32_t min, extent, stride;

    // Per-dimension flags. None are defined yet (This is reserved for future use).
    uint32_t flags;
#endif
} halide_dimension_t;

#ifdef __cplusplus
}  // extern "C"
#endif

typedef enum { halide_buffer_flag_host_dirty = 1,
               halide_buffer_flag_device_dirty = 2 } halide_buffer_flags;

/**
 * The raw representation of an image passed around by generated
 * Halide code. It includes some stuff to track whether the image is
 * not actually in main memory, but instead on a device (like a
 * GPU). For a more convenient C++ wrapper, use Halide::Buffer<T>. */
typedef struct halide_buffer_t {
    /** A device-handle for e.g. GPU memory used to back this buffer. */
    uint64_t device;

    /** The interface used to interpret the above handle. */
    const struct halide_device_interface_t *device_interface;

    /** A pointer to the start of the data in main memory. In terms of
     * the Halide coordinate system, this is the address of the min
     * coordinates (defined below). */
    uint8_t *host;

    /** flags with various meanings. */
    uint64_t flags;

    /** The type of each buffer element. */
    struct halide_type_t type;

    /** The dimensionality of the buffer. */
    int32_t dimensions;

    /** The shape of the buffer. Halide does not own this array - you
     * must manage the memory for it yourself. */
    halide_dimension_t *dim;

    /** Pads the buffer up to a multiple of 8 bytes */
    void *padding;

#if (__cplusplus >= 201103L || _MSVC_LANG >= 201103L)
    /** Convenience methods for accessing the flags */
    // @{
    HALIDE_ALWAYS_INLINE bool get_flag(halide_buffer_flags flag) const {
        return (flags & flag) != 0;
    }

    HALIDE_ALWAYS_INLINE void set_flag(halide_buffer_flags flag, bool value) {
        if (value) {
            flags |= flag;
        } else {
            flags &= ~uint64_t(flag);
        }
    }

    HALIDE_ALWAYS_INLINE bool host_dirty() const {
        return get_flag(halide_buffer_flag_host_dirty);
    }

    HALIDE_ALWAYS_INLINE bool device_dirty() const {
        return get_flag(halide_buffer_flag_device_dirty);
    }

    HALIDE_ALWAYS_INLINE void set_host_dirty(bool v = true) {
        set_flag(halide_buffer_flag_host_dirty, v);
    }

    HALIDE_ALWAYS_INLINE void set_device_dirty(bool v = true) {
        set_flag(halide_buffer_flag_device_dirty, v);
    }
    // @}

    /** The total number of elements this buffer represents. Equal to
     * the product of the extents */
    HALIDE_ALWAYS_INLINE size_t number_of_elements() const {
        size_t s = 1;
        for (int i = 0; i < dimensions; i++) {
            s *= dim[i].extent;
        }
        return s;
    }

    /** Offset to the element with the lowest address.
     * If all strides are positive, equal to zero.
     * Offset is in elements, not bytes.
     * Unlike begin(), this is ok to call on an unallocated buffer. */
    HALIDE_ALWAYS_INLINE ptrdiff_t begin_offset() const {
        ptrdiff_t index = 0;
        for (int i = 0; i < dimensions; i++) {
            const int stride = dim[i].stride;
            if (stride < 0) {
                index += stride * (ptrdiff_t)(dim[i].extent - 1);
            }
        }
        return index;
    }

    /** An offset to one beyond the element with the highest address.
     * Offset is in elements, not bytes.
     * Unlike end(), this is ok to call on an unallocated buffer. */
    HALIDE_ALWAYS_INLINE ptrdiff_t end_offset() const {
        ptrdiff_t index = 0;
        for (int i = 0; i < dimensions; i++) {
            const int stride = dim[i].stride;
            if (stride > 0) {
                index += stride * (ptrdiff_t)(dim[i].extent - 1);
            }
        }
        index += 1;
        return index;
    }

    /** A pointer to the element with the lowest address.
     * If all strides are positive, equal to the host pointer.
     * Illegal to call on an unallocated buffer. */
    HALIDE_ALWAYS_INLINE uint8_t *begin() const {
        return host + begin_offset() * type.bytes();
    }

    /** A pointer to one beyond the element with the highest address.
     * Illegal to call on an unallocated buffer. */
    HALIDE_ALWAYS_INLINE uint8_t *end() const {
        return host + end_offset() * type.bytes();
    }

    /** The total number of bytes spanned by the data in memory. */
    HALIDE_ALWAYS_INLINE size_t size_in_bytes() const {
        return (size_t)(end_offset() - begin_offset()) * type.bytes();
    }

    /** A pointer to the element at the given location. */
    HALIDE_ALWAYS_INLINE uint8_t *address_of(const int *pos) const {
        ptrdiff_t index = 0;
        for (int i = 0; i < dimensions; i++) {
            index += (ptrdiff_t)dim[i].stride * (pos[i] - dim[i].min);
        }
        return host + index * type.bytes();
    }

    /** Attempt to call device_sync for the buffer. If the buffer
     * has no device_interface (or no device_sync), this is a quiet no-op.
     * Calling this explicitly should rarely be necessary, except for profiling. */
    HALIDE_ALWAYS_INLINE int device_sync(void *ctx = nullptr) {
        if (device_interface && device_interface->device_sync) {
            return device_interface->device_sync(ctx, this);
        }
        return 0;
    }

    /** Check if an input buffer passed extern stage is a querying
     * bounds. Compared to doing the host pointer check directly,
     * this both adds clarity to code and will facilitate moving to
     * another representation for bounds query arguments. */
    HALIDE_ALWAYS_INLINE bool is_bounds_query() const {
        return host == nullptr && device == 0;
    }

#endif
} halide_buffer_t;

#ifdef __cplusplus
extern "C" {
#endif

#ifndef HALIDE_ATTRIBUTE_DEPRECATED
#ifdef HALIDE_ALLOW_DEPRECATED
#define HALIDE_ATTRIBUTE_DEPRECATED(x)
#else
#ifdef _MSC_VER
#define HALIDE_ATTRIBUTE_DEPRECATED(x) __declspec(deprecated(x))
#else
#define HALIDE_ATTRIBUTE_DEPRECATED(x) __attribute__((deprecated(x)))
#endif
#endif
#endif

/** halide_scalar_value_t is a simple union able to represent all the well-known
 * scalar values in a filter argument. Note that it isn't tagged with a type;
 * you must ensure you know the proper type before accessing. Most user
 * code will never need to create instances of this struct; its primary use
 * is to hold def/min/max values in a halide_filter_argument_t. (Note that
 * this is conceptually just a union; it's wrapped in a struct to ensure
 * that it doesn't get anonymized by LLVM.)
 */
struct halide_scalar_value_t {
    union {
        bool b;
        int8_t i8;
        int16_t i16;
        int32_t i32;
        int64_t i64;
        uint8_t u8;
        uint16_t u16;
        uint32_t u32;
        uint64_t u64;
        float f32;
        double f64;
        void *handle;
    } u;
#ifdef __cplusplus
    HALIDE_ALWAYS_INLINE halide_scalar_value_t() {
        u.u64 = 0;
    }
#endif
};

enum halide_argument_kind_t {
    halide_argument_kind_input_scalar = 0,
    halide_argument_kind_input_buffer = 1,
    halide_argument_kind_output_buffer = 2
};

/*
    These structs must be robust across different compilers and settings; when
    modifying them, strive for the following rules:

    1) All fields are explicitly sized. I.e. must use int32_t and not "int"
    2) All fields must land on an alignment boundary that is the same as their size
    3) Explicit padding is added to make that so
    4) The sizeof the struct is padded out to a multiple of the largest natural size thing in the struct
    5) don't forget that 32 and 64 bit pointers are different sizes
*/

/**
 * Obsolete version of halide_filter_argument_t; only present in
 * code that wrote halide_filter_metadata_t version 0.
 */
struct halide_filter_argument_t_v0 {
    const char *name;
    int32_t kind;
    int32_t dimensions;
    struct halide_type_t type;
    const struct halide_scalar_value_t *def, *min, *max;
};

/**
 * halide_filter_argument_t is essentially a plain-C-struct equivalent to
 * Halide::Argument; most user code will never need to create one.
 */
struct halide_filter_argument_t {
    const char *name;    // name of the argument; will never be null or empty.
    int32_t kind;        // actually halide_argument_kind_t
    int32_t dimensions;  // always zero for scalar arguments
    struct halide_type_t type;
    // These pointers should always be null for buffer arguments,
    // and *may* be null for scalar arguments. (A null value means
    // there is no def/min/max/estimate specified for this argument.)
    const struct halide_scalar_value_t *scalar_def, *scalar_min, *scalar_max, *scalar_estimate;
    // This pointer should always be null for scalar arguments,
    // and *may* be null for buffer arguments. If not null, it should always
    // point to an array of dimensions*2 pointers, which will be the (min, extent)
    // estimates for each dimension of the buffer. (Note that any of the pointers
    // may be null as well.)
    int64_t const *const *buffer_estimates;
};

struct halide_filter_metadata_t {
#ifdef __cplusplus
    static const int32_t VERSION = 1;
#endif

    /** version of this metadata; currently always 1. */
    int32_t version;

    /** The number of entries in the arguments field. This is always >= 1. */
    int32_t num_arguments;

    /** An array of the filters input and output arguments; this will never be
     * null. The order of arguments is not guaranteed (input and output arguments
     * may come in any order); however, it is guaranteed that all arguments
     * will have a unique name within a given filter. */
    const struct halide_filter_argument_t *arguments;

    /** The Target for which the filter was compiled. This is always
     * a canonical Target string (ie a product of Target::to_string). */
    const char *target;

    /** The function name of the filter. */
    const char *name;
};

/** halide_register_argv_and_metadata() is a **user-defined** function that
 * must be provided in order to use the registration.cc files produced
 * by Generators when the 'registration' output is requested. Each registration.cc
 * file provides a static initializer that calls this function with the given
 * filter's argv-call variant, its metadata, and (optionally) and additional
 * textual data that the build system chooses to tack on for its own purposes.
 * Note that this will be called at static-initializer time (i.e., before
 * main() is called), and in an unpredictable order. Note that extra_key_value_pairs
 * may be nullptr; if it's not null, it's expected to be a null-terminated list
 * of strings, with an even number of entries. */
void halide_register_argv_and_metadata(
    int (*filter_argv_call)(void **),
    const struct halide_filter_metadata_t *filter_metadata,
    const char *const *extra_key_value_pairs);

/** The functions below here are relevant for pipelines compiled with
 * the -profile target flag, which runs a sampling profiler thread
 * alongside the pipeline. */

/** Per-Func state tracked by the sampling profiler. */
struct HALIDE_ATTRIBUTE_ALIGN(8) halide_profiler_func_stats {
    /** Total time taken evaluating this Func (in nanoseconds). */
    uint64_t time;

    /** The current memory allocation of this Func. */
    uint64_t memory_current;

    /** The peak memory allocation of this Func. */
    uint64_t memory_peak;

    /** The total memory allocation of this Func. */
    uint64_t memory_total;

    /** The peak stack allocation of this Func's threads. */
    uint64_t stack_peak;

    /** The average number of thread pool worker threads active while computing this Func. */
    uint64_t active_threads_numerator, active_threads_denominator;

    /** The name of this Func. A global constant string. */
    const char *name;

    /** The total number of memory allocation of this Func. */
    int num_allocs;
};

/** Per-pipeline state tracked by the sampling profiler. These exist
 * in a linked list. */
struct HALIDE_ATTRIBUTE_ALIGN(8) halide_profiler_pipeline_stats {
    /** Total time spent inside this pipeline (in nanoseconds) */
    uint64_t time;

    /** The current memory allocation of funcs in this pipeline. */
    uint64_t memory_current;

    /** The peak memory allocation of funcs in this pipeline. */
    uint64_t memory_peak;

    /** The total memory allocation of funcs in this pipeline. */
    uint64_t memory_total;

    /** The average number of thread pool worker threads doing useful
     * work while computing this pipeline. */
    uint64_t active_threads_numerator, active_threads_denominator;

    /** The name of this pipeline. A global constant string. */
    const char *name;

    /** An array containing states for each Func in this pipeline. */
    struct halide_profiler_func_stats *funcs;

    /** The next pipeline_stats pointer. It's a void * because types
     * in the Halide runtime may not currently be recursive. */
    void *next;

    /** The number of funcs in this pipeline. */
    int num_funcs;

    /** An internal base id used to identify the funcs in this pipeline. */
    int first_func_id;

    /** The number of times this pipeline has been run. */
    int runs;

    /** The total number of samples taken inside of this pipeline. */
    int samples;

    /** The total number of memory allocation of funcs in this pipeline. */
    int num_allocs;
};

/** The global state of the profiler. */

struct halide_profiler_state {
    /** Guards access to the fields below. If not locked, the sampling
     * profiler thread is free to modify things below (including
     * reordering the linked list of pipeline stats). */
    struct halide_mutex lock;

    /** The amount of time the profiler thread sleeps between samples
     * in milliseconds. Defaults to 1 */
    int sleep_time;

    /** An internal id used for bookkeeping. */
    int first_free_id;

    /** The id of the current running Func. Set by the pipeline, read
     * periodically by the profiler thread. */
    int current_func;

    /** The number of threads currently doing work. */
    int active_threads;

    /** A linked list of stats gathered for each pipeline. */
    struct halide_profiler_pipeline_stats *pipelines;

    /** Retrieve remote profiler state. Used so that the sampling
     * profiler can follow along with execution that occurs elsewhere,
     * e.g. on a DSP. If null, it reads from the int above instead. */
    void (*get_remote_profiler_state)(int *func, int *active_workers);

    /** Sampling thread reference to be joined at shutdown. */
    struct halide_thread *sampling_thread;
};

/** Profiler func ids with special meanings. */
enum {
    /// current_func takes on this value when not inside Halide code
    halide_profiler_outside_of_halide = -1,
    /// Set current_func to this value to tell the profiling thread to
    /// halt. It will start up again next time you run a pipeline with
    /// profiling enabled.
    halide_profiler_please_stop = -2
};

/** Get a pointer to the global profiler state for programmatic
 * inspection. Lock it before using to pause the profiler. */
extern struct halide_profiler_state *halide_profiler_get_state();

/** Get a pointer to the pipeline state associated with pipeline_name.
 * This function grabs the global profiler state's lock on entry. */
extern struct halide_profiler_pipeline_stats *halide_profiler_get_pipeline_state(const char *pipeline_name);

/** Collects profiling information. Intended to be called from a timer
 * interrupt handler if timer based profiling is being used.
 *  State argument is acquired via halide_profiler_get_pipeline_state.
 * prev_t argument is the previous time and can be used to set a more
 * accurate time interval if desired. */
extern int halide_profiler_sample(struct halide_profiler_state *s, uint64_t *prev_t);

/** Reset profiler state cheaply. May leave threads running or some
 * memory allocated but all accumluated statistics are reset.
 * WARNING: Do NOT call this method while any halide pipeline is
 * running; halide_profiler_memory_allocate/free and
 * halide_profiler_stack_peak_update update the profiler pipeline's
 * state without grabbing the global profiler state's lock. */
extern void halide_profiler_reset();

/** Reset all profiler state.
 * WARNING: Do NOT call this method while any halide pipeline is
 * running; halide_profiler_memory_allocate/free and
 * halide_profiler_stack_peak_update update the profiler pipeline's
 * state without grabbing the global profiler state's lock. */
void halide_profiler_shutdown();

/** Print out timing statistics for everything run since the last
 * reset. Also happens at process exit. */
extern void halide_profiler_report(void *user_context);

/** For timer based profiling, this routine starts the timer chain running.
 * halide_get_profiler_state can be called to get the current timer interval.
 */
extern void halide_start_timer_chain();
/** These routines are called to temporarily disable and then reenable
 * timer interuppts for profiling */
//@{
extern void halide_disable_timer_interrupt();
extern void halide_enable_timer_interrupt();
//@}

/// \name "Float16" functions
/// These functions operate of bits (``uint16_t``) representing a half
/// precision floating point number (IEEE-754 2008 binary16).
//{@

/** Read bits representing a half precision floating point number and return
 *  the float that represents the same value */
extern float halide_float16_bits_to_float(uint16_t);

/** Read bits representing a half precision floating point number and return
 *  the double that represents the same value */
extern double halide_float16_bits_to_double(uint16_t);

// TODO: Conversion functions to half

//@}

// Allocating and freeing device memory is often very slow. The
// methods below give Halide's runtime permission to hold onto device
// memory to service future requests instead of returning it to the
// underlying device API. The API does not manage an allocation pool,
// all it does is provide access to a shared counter that acts as a
// limit on the unused memory not yet returned to the underlying
// device API. It makes callbacks to participants when memory needs to
// be released because the limit is about to be exceeded (either
// because the limit has been reduced, or because the memory owned by
// some participant becomes unused).

/** Tell Halide whether or not it is permitted to hold onto device
 * allocations to service future requests instead of returning them
 * eagerly to the underlying device API. Many device allocators are
 * quite slow, so it can be beneficial to set this to true. The
 * default value for now is false.
 *
 * Note that if enabled, the eviction policy is very simplistic. The
 * 32 most-recently used allocations are preserved, regardless of
 * their size. Additionally, if a call to cuMalloc results in an
 * out-of-memory error, the entire cache is flushed and the allocation
 * is retried. See https://github.com/halide/Halide/issues/4093
 *
 * If set to false, releases all unused device allocations back to the
 * underlying device APIs. For finer-grained control, see specific
 * methods in each device api runtime.
 *
 * Note that if the flag is set to true, this call *must* succeed and return
 * a value of halide_error_code_success (i.e., zero); if you replace
 * the implementation of this call in the runtime, you must honor this contract.
 * */
extern int halide_reuse_device_allocations(void *user_context, bool);

/** Determines whether on device_free the memory is returned
 * immediately to the device API, or placed on a free list for future
 * use. Override and switch based on the user_context for
 * finer-grained control. By default just returns the value most
 * recently set by the method above. */
extern bool halide_can_reuse_device_allocations(void *user_context);

struct halide_device_allocation_pool {
    int (*release_unused)(void *user_context);
    struct halide_device_allocation_pool *next;
};

/** Register a callback to be informed when
 * halide_reuse_device_allocations(false) is called, and all unused
 * device allocations must be released. The object passed should have
 * global lifetime, and its next field will be clobbered. */
extern void halide_register_device_allocation_pool(struct halide_device_allocation_pool *);

#ifdef __cplusplus
}  // End extern "C"
#endif

#if (__cplusplus >= 201103L || _MSVC_LANG >= 201103L)

namespace {

template<typename T>
struct check_is_pointer {
    static constexpr bool value = false;
};

template<typename T>
struct check_is_pointer<T *> {
    static constexpr bool value = true;
};

}  // namespace

/** Construct the halide equivalent of a C type */
template<typename T>
HALIDE_ALWAYS_INLINE constexpr halide_type_t halide_type_of() {
    // Create a compile-time error if T is not a pointer (without
    // using any includes - this code goes into the runtime).
    // (Note that we can't have uninitialized variables in constexpr functions,
    // even if those variables aren't used.)
    static_assert(check_is_pointer<T>::value, "Expected a pointer type here");
    return halide_type_t(halide_type_handle, 64);
}

#ifdef HALIDE_CPP_COMPILER_HAS_FLOAT16
template<>
HALIDE_ALWAYS_INLINE constexpr halide_type_t halide_type_of<_Float16>() {
    return halide_type_t(halide_type_float, 16);
}
#endif

template<>
HALIDE_ALWAYS_INLINE constexpr halide_type_t halide_type_of<float>() {
    return halide_type_t(halide_type_float, 32);
}

template<>
HALIDE_ALWAYS_INLINE constexpr halide_type_t halide_type_of<double>() {
    return halide_type_t(halide_type_float, 64);
}

template<>
HALIDE_ALWAYS_INLINE constexpr halide_type_t halide_type_of<bool>() {
    return halide_type_t(halide_type_uint, 1);
}

template<>
HALIDE_ALWAYS_INLINE constexpr halide_type_t halide_type_of<uint8_t>() {
    return halide_type_t(halide_type_uint, 8);
}

template<>
HALIDE_ALWAYS_INLINE constexpr halide_type_t halide_type_of<uint16_t>() {
    return halide_type_t(halide_type_uint, 16);
}

template<>
HALIDE_ALWAYS_INLINE constexpr halide_type_t halide_type_of<uint32_t>() {
    return halide_type_t(halide_type_uint, 32);
}

template<>
HALIDE_ALWAYS_INLINE constexpr halide_type_t halide_type_of<uint64_t>() {
    return halide_type_t(halide_type_uint, 64);
}

template<>
HALIDE_ALWAYS_INLINE constexpr halide_type_t halide_type_of<int8_t>() {
    return halide_type_t(halide_type_int, 8);
}

template<>
HALIDE_ALWAYS_INLINE constexpr halide_type_t halide_type_of<int16_t>() {
    return halide_type_t(halide_type_int, 16);
}

template<>
HALIDE_ALWAYS_INLINE constexpr halide_type_t halide_type_of<int32_t>() {
    return halide_type_t(halide_type_int, 32);
}

template<>
HALIDE_ALWAYS_INLINE constexpr halide_type_t halide_type_of<int64_t>() {
    return halide_type_t(halide_type_int, 64);
}

#ifndef COMPILING_HALIDE_RUNTIME

// These structures are used by `function_info_header` files
// (generated by passing `-e function_info_header` to a Generator).
// The generated files contain documentation on the proper usage.
namespace HalideFunctionInfo {

enum ArgumentKind { InputScalar = 0,
                    InputBuffer = 1,
                    OutputBuffer = 2 };

struct ArgumentInfo {
    std::string_view name;
    ArgumentKind kind;
    int32_t dimensions;  // always zero for scalar arguments
    halide_type_t type;
};

}  // namespace HalideFunctionInfo

#endif  // COMPILING_HALIDE_RUNTIME

#endif  // (__cplusplus >= 201103L || _MSVC_LANG >= 201103L)

#endif  // HALIDE_HALIDERUNTIME_H

#ifdef COMPILING_HALIDE_RUNTIME
#include "HalideRuntime.h"
#define HALIDE_BUFFER_HELPER_ATTRS WEAK_INLINE
#else
#define HALIDE_BUFFER_HELPER_ATTRS inline
#endif

// Structs are annoying to deal with from within Halide Stmts. These
// utility functions are for dealing with halide_buffer_t in that
// context. They are not intended for use outside of Halide code, and
// not exposed in HalideRuntime.h. The symbols are private to the
// module and should be inlined and then stripped. This blob of code
// also gets copy-pasted into C outputs.

extern "C" {

HALIDE_BUFFER_HELPER_ATTRS
int _halide_buffer_get_dimensions(const halide_buffer_t *buf) {
    return buf->dimensions;
}

HALIDE_BUFFER_HELPER_ATTRS
uint8_t *_halide_buffer_get_host(const halide_buffer_t *buf) {
    return buf->host;
}

HALIDE_BUFFER_HELPER_ATTRS
uint64_t _halide_buffer_get_device(const halide_buffer_t *buf) {
    return buf->device;
}

HALIDE_BUFFER_HELPER_ATTRS
const struct halide_device_interface_t *_halide_buffer_get_device_interface(const halide_buffer_t *buf) {
    return buf->device_interface;
}

HALIDE_BUFFER_HELPER_ATTRS
int _halide_buffer_get_min(const halide_buffer_t *buf, int d) {
    return buf->dim[d].min;
}

HALIDE_BUFFER_HELPER_ATTRS
int _halide_buffer_get_max(const halide_buffer_t *buf, int d) {
    return buf->dim[d].min + buf->dim[d].extent - 1;
}

HALIDE_BUFFER_HELPER_ATTRS
int _halide_buffer_get_extent(const halide_buffer_t *buf, int d) {
    return buf->dim[d].extent;
}

HALIDE_BUFFER_HELPER_ATTRS
int _halide_buffer_get_stride(const halide_buffer_t *buf, int d) {
    return buf->dim[d].stride;
}

HALIDE_BUFFER_HELPER_ATTRS
int _halide_buffer_set_host_dirty(halide_buffer_t *buf, bool val) {
    buf->set_host_dirty(val);
    return 0;
}

HALIDE_BUFFER_HELPER_ATTRS
int _halide_buffer_set_device_dirty(halide_buffer_t *buf, bool val) {
    buf->set_device_dirty(val);
    return 0;
}

HALIDE_BUFFER_HELPER_ATTRS
bool _halide_buffer_get_host_dirty(const halide_buffer_t *buf) {
    return buf->host_dirty();
}

HALIDE_BUFFER_HELPER_ATTRS
bool _halide_buffer_get_device_dirty(const halide_buffer_t *buf) {
    return buf->device_dirty();
}

HALIDE_BUFFER_HELPER_ATTRS
halide_dimension_t *_halide_buffer_get_shape(halide_buffer_t *buf) {
    return buf->dim;
}

HALIDE_BUFFER_HELPER_ATTRS
bool _halide_buffer_is_bounds_query(const halide_buffer_t *buf) {
    return buf->host == nullptr && buf->device == 0;
}

HALIDE_BUFFER_HELPER_ATTRS
uint32_t _halide_buffer_get_type(const halide_buffer_t *buf) {
    return buf->type.as_u32();
}

HALIDE_BUFFER_HELPER_ATTRS
halide_buffer_t *_halide_buffer_init(halide_buffer_t *dst,
                                     halide_dimension_t *dst_shape,
                                     void *host,
                                     uint64_t device,
                                     const halide_device_interface_t *device_interface,
                                     int type_code, int type_bits,
                                     int dimensions,
                                     halide_dimension_t *shape,
                                     uint64_t flags) {
    dst->host = (uint8_t *)host;
    dst->device = device;
    dst->device_interface = device_interface;
    dst->type.code = (halide_type_code_t)type_code;
    dst->type.bits = (uint8_t)type_bits;
    dst->type.lanes = 1;
    dst->dimensions = dimensions;
    dst->dim = dst_shape;
    if (shape != dst->dim) {
        for (int i = 0; i < dimensions; i++) {
            dst->dim[i] = shape[i];
        }
    }
    dst->flags = flags;
    return dst;
}

HALIDE_BUFFER_HELPER_ATTRS
halide_buffer_t *_halide_buffer_init_from_buffer(halide_buffer_t *dst,
                                                 halide_dimension_t *dst_shape,
                                                 const halide_buffer_t *src) {
    dst->host = src->host;
    dst->device = src->device;
    dst->device_interface = src->device_interface;
    dst->type = src->type;
    dst->dimensions = src->dimensions;
    dst->dim = dst_shape;
    dst->flags = src->flags;
    for (int i = 0; i < dst->dimensions; i++) {
        dst->dim[i] = src->dim[i];
    }
    return dst;
}

HALIDE_BUFFER_HELPER_ATTRS
halide_buffer_t *_halide_buffer_crop(void *user_context,
                                     halide_buffer_t *dst,
                                     halide_dimension_t *dst_shape,
                                     const halide_buffer_t *src,
                                     const int *min, const int *extent) {
    *dst = *src;
    dst->dim = dst_shape;
    int64_t offset = 0;
    for (int i = 0; i < dst->dimensions; i++) {
        dst->dim[i] = src->dim[i];
        dst->dim[i].min = min[i];
        dst->dim[i].extent = extent[i];
        offset += (min[i] - src->dim[i].min) * (int64_t)src->dim[i].stride;
    }
    if (dst->host) {
        dst->host += offset * src->type.bytes();
    }
    dst->device_interface = nullptr;
    dst->device = 0;
    if (src->device_interface) {
        if (src->device_interface->device_crop(user_context, src, dst) != 0) {
            // This is uncommon: either a runtime error, or a backend that
            // doesn't replace the default definition of device_crop. But it
            // does happen, so let's return a nullptr here, and require the caller
            // to check the result.
            return nullptr;
        }
    }
    return dst;
}

// Called on return from an extern stage where the output buffer was a
// crop of some other larger buffer. This happens for extern stages
// with distinct store_at/compute_at levels. Each call to the stage
// only fills in part of the buffer.
HALIDE_BUFFER_HELPER_ATTRS
int _halide_buffer_retire_crop_after_extern_stage(void *user_context,
                                                  void *obj) {
    int result;
    halide_buffer_t **buffers = (halide_buffer_t **)obj;
    halide_buffer_t *crop = buffers[0];
    halide_buffer_t *parent = buffers[1];

    if (crop->device) {
        if (!parent->device) {
            // We have been given a device allocation by the extern
            // stage. It only represents the cropped region, so we
            // can't just give it to the parent.
            if (crop->device_dirty()) {
                result = crop->device_interface->copy_to_host(user_context, crop);
                if (result != 0) {
                    return result;
                }
            }
            result = crop->device_interface->device_free(user_context, crop);
            if (result != 0) {
                return result;
            }
        } else {
            // We are a crop of an existing device allocation.
            if (crop->device_dirty()) {
                parent->set_device_dirty();
            }
            result = crop->device_interface->device_release_crop(user_context, crop);
            if (result != 0) {
                return result;
            }
        }
    }
    if (crop->host_dirty()) {
        parent->set_host_dirty();
    }
    return 0;
}

HALIDE_BUFFER_HELPER_ATTRS
int _halide_buffer_retire_crops_after_extern_stage(void *user_context,
                                                   void *obj) {
    halide_buffer_t **buffers = (halide_buffer_t **)obj;
    while (*buffers) {
        _halide_buffer_retire_crop_after_extern_stage(user_context, buffers);
        buffers += 2;
    }
    return 0;
}

HALIDE_BUFFER_HELPER_ATTRS
halide_buffer_t *_halide_buffer_set_bounds(halide_buffer_t *buf,
                                           int dim, int min, int extent) {
    // This can be called with the result of _halide_buffer_crop(), which
    // can return nullptr if an error occurs -- so don't crash, just propagate
    // the nullptr result to our caller.
    if (buf != nullptr) {
        buf->dim[dim].min = min;
        buf->dim[dim].extent = extent;
    }
    return buf;
}
}

#undef HALIDE_BUFFER_HELPER_ATTRS


#ifndef HALIDE_MUST_USE_RESULT
#ifdef __has_attribute
#if __has_attribute(nodiscard)
#define HALIDE_MUST_USE_RESULT [[nodiscard]]
#elif __has_attribute(warn_unused_result)
#define HALIDE_MUST_USE_RESULT __attribute__((warn_unused_result))
#else
#define HALIDE_MUST_USE_RESULT
#endif
#else
#define HALIDE_MUST_USE_RESULT
#endif
#endif

#ifndef HALIDE_FUNCTION_ATTRS
#define HALIDE_FUNCTION_ATTRS
#endif



#ifdef __cplusplus
extern "C" {
#endif

int32_t search_quadtree(struct halide_buffer_t *, struct halide_buffer_t *, struct halide_buffer_t *, struct halide_buffer_t *, struct halide_buffer_t *, int32_t , struct halide_buffer_t *, struct halide_buffer_t *);
int32_t search_quadtree_faces(struct halide_buffer_t *, struct halide_buffer_t *, struct halide_buffer_t *, struct halide_buffer_t *, int32_t , struct halide_buffer_t *);

static HALIDE_FUNCTION_ATTRS
int foreground_mesh_verts_par_for_patched_canny_s0_p_fused_v14(void *__user_context, int32_t _patched_canny_s0_p_fused_v14, uint8_t *_closure_arg) {
 void * const _ucon = const_cast<void *>(__user_context);
 halide_maybe_unused(_ucon);
 auto *_3 = (void *)(nullptr);
 float _4 = float_from_bits(0 /* 0 */);
 struct {
  void * f_0;
  void * f_1;
  void * f_2;
  void * f_3;
  void * f_4;
  void * f_5;
  void * f_6;
  int32_t f_7;
  int32_t f_8;
  int32_t f_9;
  int32_t f_10;
  int32_t f_11;
  int32_t f_12;
  int32_t f_13;
  int32_t f_14;
  int32_t f_15;
  int32_t f_16;
  int32_t f_17;
  int32_t f_18;
  int32_t f_19;
  float f_20;
  int32_t f_21;
  int32_t f_22;
  int32_t f_23;
  int32_t f_24;
  int32_t f_25;
  int32_t f_26;
  int32_t f_27;
  int32_t f_28;
 } s0 = {
  _3,
  _3,
  _3,
  _3,
  _3,
  _3,
  _3,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  _4,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
 };
 auto *_5 = (&s0);
 auto _closure_prototype = _5;
 halide_maybe_unused(_closure_prototype);
 auto *_6 = ((decltype(_closure_prototype))_closure_arg)->f_0;
 auto _I_back_canny = _6;
 halide_maybe_unused(_I_back_canny);
 auto *_7 = ((decltype(_closure_prototype))_closure_arg)->f_1;
 auto _I_canny = _7;
 halide_maybe_unused(_I_canny);
 auto *_8 = ((decltype(_closure_prototype))_closure_arg)->f_2;
 auto _I_depth = _8;
 halide_maybe_unused(_I_depth);
 auto *_9 = ((decltype(_closure_prototype))_closure_arg)->f_3;
 auto _patch_coords = _9;
 halide_maybe_unused(_patch_coords);
 auto *_10 = ((decltype(_closure_prototype))_closure_arg)->f_4;
 auto _patched_b_canny = _10;
 halide_maybe_unused(_patched_b_canny);
 auto *_11 = ((decltype(_closure_prototype))_closure_arg)->f_5;
 auto _patched_canny = _11;
 halide_maybe_unused(_patched_canny);
 auto *_12 = ((decltype(_closure_prototype))_closure_arg)->f_6;
 auto _patched_depth = _12;
 halide_maybe_unused(_patched_depth);
 int32_t _13 = ((decltype(_closure_prototype))_closure_arg)->f_7;
 int32_t _14 = ((decltype(_closure_prototype))_closure_arg)->f_8;
 int32_t _15 = ((decltype(_closure_prototype))_closure_arg)->f_9;
 int32_t _16 = ((decltype(_closure_prototype))_closure_arg)->f_10;
 int32_t _17 = ((decltype(_closure_prototype))_closure_arg)->f_11;
 int32_t _18 = ((decltype(_closure_prototype))_closure_arg)->f_12;
 int32_t _19 = ((decltype(_closure_prototype))_closure_arg)->f_13;
 int32_t _20 = ((decltype(_closure_prototype))_closure_arg)->f_14;
 int32_t _21 = ((decltype(_closure_prototype))_closure_arg)->f_15;
 int32_t _22 = ((decltype(_closure_prototype))_closure_arg)->f_16;
 int32_t _23 = ((decltype(_closure_prototype))_closure_arg)->f_17;
 int32_t _24 = ((decltype(_closure_prototype))_closure_arg)->f_18;
 int32_t _25 = ((decltype(_closure_prototype))_closure_arg)->f_19;
 float _26 = ((decltype(_closure_prototype))_closure_arg)->f_20;
 int32_t _27 = ((decltype(_closure_prototype))_closure_arg)->f_21;
 int32_t _28 = ((decltype(_closure_prototype))_closure_arg)->f_22;
 int32_t _29 = ((decltype(_closure_prototype))_closure_arg)->f_23;
 int32_t _30 = ((decltype(_closure_prototype))_closure_arg)->f_24;
 int32_t _31 = ((decltype(_closure_prototype))_closure_arg)->f_25;
 int32_t _32 = ((decltype(_closure_prototype))_closure_arg)->f_26;
 int32_t _33 = ((decltype(_closure_prototype))_closure_arg)->f_27;
 int32_t _34 = ((decltype(_closure_prototype))_closure_arg)->f_28;
 int32_t _35 = _25 + 1;
 bool _36 = _patched_canny_s0_p_fused_v14 < _35;
 if (_36)
 {
  int32_t _37 = _patched_canny_s0_p_fused_v14 * 32;
  int32_t _38 = _37 + _23;
  int32_t _39 = _22 + -31;
  int32_t _40 = ::halide_cpp_min(_38, _39);
  int32_t _41 = _40 - _21;
  for (int _patched_canny_s0_p_v15 = 0; _patched_canny_s0_p_v15 < 0 + 32; _patched_canny_s0_p_v15++)
  {
   int32_t _42 = _patched_canny_s0_p_v15 + _40;
   float _43 = (float)(_42);
   float _44 = _43 / _26;
   float _45 = floor_f32(_44);
   float _46 = float_from_bits(1098907648 /* 16 */);
   float _47 = _45 * _46;
   int32_t _48 = (int32_t)(_47);
   int32_t _49 = _15 - _48;
   int32_t _50 = ::halide_cpp_min(_49, 17);
   int32_t _51 = ::halide_cpp_max(_48, -17);
   int32_t _52 = 0 - _51;
   int32_t _53 = ::halide_cpp_max(_50, _52);
   int32_t _54 = _patched_canny_s0_p_v15 + _41;
   int32_t _55 = _54 * 289;
   int32_t _56 = ::halide_cpp_min(_48, 0);
   int32_t _57 = ::halide_cpp_max(_56, -17);
   int32_t _58 = 0 - _57;
   for (int _patched_canny_s0_y_p = 0; _patched_canny_s0_y_p < 0 + _58; _patched_canny_s0_y_p++)
   {
    bool _59 = _42 < 0;
    int32_t _60 = (int32_t)(_59 ? -1 : 0);
    bool _61 = _14 == 0;
    int32_t _62 = (int32_t)(_61 ? -1 : 0);
    bool _63 = _14 < 0;
    int32_t _64 = (int32_t)(_63 ? -1 : 0);
    int32_t _65 = _42 * 16;
    int32_t _66 = _65 - _60;
    int32_t _67 = _14 | _62;
    int32_t _68 = _66 % _67;
    int32_t _69 = _14 ^ _64;
    int32_t _70 = ~_64;
    int32_t _71 = _69 + _70;
    int32_t _72 = _60 & _71;
    int32_t _73 = _68 + _72;
    int32_t _74 = ~_62;
    int32_t _75 = _73 & _74;
    float _76 = (float)(_42);
    float _77 = _76 / _26;
    float _78 = floor_f32(_77);
    float _79 = float_from_bits(1098907648 /* 16 */);
    float _80 = _78 * _79;
    int32_t _81 = (int32_t)(_80);
    int32_t _82 = _patched_canny_s0_y_p + _81;
    int32_t _83 = _15 + -1;
    int32_t _84 = ::halide_cpp_min(_82, _83);
    int32_t _85 = ::halide_cpp_max(_84, 0);
    int32_t _86 = _85 * _16;
    int32_t _87 = _86 - _27;
    int32_t _88 = _patched_canny_s0_y_p * 17;
    int32_t _89 = _88 + _55;
    for (int _patched_canny_s0_x_p = 0; _patched_canny_s0_x_p < 0 + 17; _patched_canny_s0_x_p++)
    {
     int32_t _90 = _patched_canny_s0_x_p + _75;
     int32_t _91 = _14 + -1;
     int32_t _92 = ::halide_cpp_min(_90, _91);
     int32_t _93 = ::halide_cpp_max(_92, 0);
     int32_t _94 = _93 + _87;
     uint8_t _95 = ((uint8_t *)_I_canny)[_94];
     int32_t _96 = _patched_canny_s0_x_p + _89;
     ((uint8_t *)_patched_canny)[_96] = _95;
    } // for _patched_canny_s0_x_p
   } // for _patched_canny_s0_y_p
   int32_t _97 = _patched_canny_s0_p_v15 + _40;
   int32_t _98 = ::halide_cpp_min(_48, 0);
   int32_t _99 = ::halide_cpp_max(_98, -17);
   int32_t _100 = _patched_canny_s0_p_v15 + _41;
   int32_t _101 = _100 * 289;
   bool _102 = _97 < 0;
   int32_t _103 = (int32_t)(_102 ? -1 : 0);
   bool _104 = _14 == 0;
   int32_t _105 = (int32_t)(_104 ? -1 : 0);
   bool _106 = _14 < 0;
   int32_t _107 = (int32_t)(_106 ? -1 : 0);
   int32_t _108 = _97 * 16;
   int32_t _109 = _108 - _103;
   int32_t _110 = _14 | _105;
   int32_t _111 = _109 % _110;
   int32_t _112 = _14 ^ _107;
   int32_t _113 = ~_107;
   int32_t _114 = _112 + _113;
   int32_t _115 = _103 & _114;
   int32_t _116 = _111 + _115;
   int32_t _117 = ~_105;
   int32_t _118 = _116 & _117;
   int32_t _119 = _14 - _118;
   int32_t _120 = ::halide_cpp_max(_53, 0);
   int32_t _121 = _120 + _99;
   for (int _patched_canny_s0_y_p_rebased = 0; _patched_canny_s0_y_p_rebased < 0 + _121; _patched_canny_s0_y_p_rebased++)
   {
    int32_t _122 = _patched_canny_s0_y_p_rebased - _99;
    int32_t _123 = ::halide_cpp_min(_119, 17);
    int32_t _124 = ::halide_cpp_max(_123, 0);
    bool _125 = _97 < 0;
    int32_t _126 = (int32_t)(_125 ? -1 : 0);
    bool _127 = _14 == 0;
    int32_t _128 = (int32_t)(_127 ? -1 : 0);
    bool _129 = _14 < 0;
    int32_t _130 = (int32_t)(_129 ? -1 : 0);
    int32_t _131 = _97 * 16;
    int32_t _132 = _131 - _126;
    int32_t _133 = _14 | _128;
    int32_t _134 = _132 % _133;
    int32_t _135 = _14 ^ _130;
    int32_t _136 = ~_130;
    int32_t _137 = _135 + _136;
    int32_t _138 = _126 & _137;
    int32_t _139 = _134 + _138;
    int32_t _140 = ~_128;
    int32_t _141 = _139 & _140;
    float _142 = (float)(_97);
    float _143 = _142 / _26;
    float _144 = floor_f32(_143);
    float _145 = float_from_bits(1098907648 /* 16 */);
    float _146 = _144 * _145;
    int32_t _147 = (int32_t)(_146);
    int32_t _148 = _122 + _147;
    int32_t _149 = _15 + -1;
    int32_t _150 = ::halide_cpp_min(_148, _149);
    int32_t _151 = ::halide_cpp_max(_150, 0);
    int32_t _152 = _151 * _16;
    int32_t _153 = _152 - _27;
    int32_t _154 = _122 * 17;
    int32_t _155 = _154 + _101;
    for (int _patched_canny_s0_x_p = 0; _patched_canny_s0_x_p < 0 + _124; _patched_canny_s0_x_p++)
    {
     int32_t _156 = _patched_canny_s0_x_p + _141;
     int32_t _157 = _14 + -1;
     int32_t _158 = ::halide_cpp_min(_156, _157);
     int32_t _159 = ::halide_cpp_max(_158, 0);
     int32_t _160 = _159 + _153;
     uint8_t _161 = ((uint8_t *)_I_canny)[_160];
     int32_t _162 = _patched_canny_s0_x_p + _155;
     ((uint8_t *)_patched_canny)[_162] = _161;
    } // for _patched_canny_s0_x_p
    int32_t _163 = ::halide_cpp_min(_119, 17);
    int32_t _164 = ::halide_cpp_max(_163, 0);
    int32_t _165 = _122 * 17;
    bool _166 = _97 < 0;
    int32_t _167 = (int32_t)(_166 ? -1 : 0);
    bool _168 = _14 == 0;
    int32_t _169 = (int32_t)(_168 ? -1 : 0);
    bool _170 = _14 < 0;
    int32_t _171 = (int32_t)(_170 ? -1 : 0);
    int32_t _172 = _97 * 16;
    int32_t _173 = _172 - _167;
    int32_t _174 = _14 | _169;
    int32_t _175 = _173 % _174;
    int32_t _176 = _14 ^ _171;
    int32_t _177 = ~_171;
    int32_t _178 = _176 + _177;
    int32_t _179 = _167 & _178;
    int32_t _180 = _175 + _179;
    int32_t _181 = ~_169;
    int32_t _182 = _180 & _181;
    float _183 = (float)(_97);
    float _184 = _183 / _26;
    float _185 = floor_f32(_184);
    float _186 = float_from_bits(1098907648 /* 16 */);
    float _187 = _185 * _186;
    int32_t _188 = (int32_t)(_187);
    int32_t _189 = _122 + _188;
    int32_t _190 = _15 + -1;
    int32_t _191 = ::halide_cpp_min(_189, _190);
    int32_t _192 = ::halide_cpp_max(_191, 0);
    int32_t _193 = _192 * _16;
    int32_t _194 = _193 - _27;
    int32_t _195 = 17 - _164;
    for (int _patched_canny_s0_x_p_rebased = 0; _patched_canny_s0_x_p_rebased < 0 + _195; _patched_canny_s0_x_p_rebased++)
    {
     int32_t _196 = _182 + _164;
     int32_t _197 = _196 + _patched_canny_s0_x_p_rebased;
     int32_t _198 = _14 + -1;
     int32_t _199 = ::halide_cpp_min(_197, _198);
     int32_t _200 = ::halide_cpp_max(_199, 0);
     int32_t _201 = _200 + _194;
     uint8_t _202 = ((uint8_t *)_I_canny)[_201];
     int32_t _203 = _101 + _164;
     int32_t _204 = _203 + _165;
     int32_t _205 = _204 + _patched_canny_s0_x_p_rebased;
     ((uint8_t *)_patched_canny)[_205] = _202;
    } // for _patched_canny_s0_x_p_rebased
   } // for _patched_canny_s0_y_p_rebased
   int32_t _206 = ::halide_cpp_max(_53, 0);
   int32_t _207 = _patched_canny_s0_p_v15 + _41;
   int32_t _208 = _207 * 289;
   int32_t _209 = _patched_canny_s0_p_v15 + _40;
   int32_t _210 = 17 - _206;
   for (int _patched_canny_s0_y_p_rebased = 0; _patched_canny_s0_y_p_rebased < 0 + _210; _patched_canny_s0_y_p_rebased++)
   {
    bool _211 = _209 < 0;
    int32_t _212 = (int32_t)(_211 ? -1 : 0);
    bool _213 = _14 == 0;
    int32_t _214 = (int32_t)(_213 ? -1 : 0);
    bool _215 = _14 < 0;
    int32_t _216 = (int32_t)(_215 ? -1 : 0);
    int32_t _217 = _209 * 16;
    int32_t _218 = _217 - _212;
    int32_t _219 = _14 | _214;
    int32_t _220 = _218 % _219;
    int32_t _221 = _14 ^ _216;
    int32_t _222 = ~_216;
    int32_t _223 = _221 + _222;
    int32_t _224 = _212 & _223;
    int32_t _225 = _220 + _224;
    int32_t _226 = ~_214;
    int32_t _227 = _225 & _226;
    float _228 = (float)(_209);
    float _229 = _228 / _26;
    float _230 = floor_f32(_229);
    float _231 = float_from_bits(1098907648 /* 16 */);
    float _232 = _230 * _231;
    int32_t _233 = (int32_t)(_232);
    int32_t _234 = _206 + _233;
    int32_t _235 = _234 + _patched_canny_s0_y_p_rebased;
    int32_t _236 = _15 + -1;
    int32_t _237 = ::halide_cpp_min(_235, _236);
    int32_t _238 = ::halide_cpp_max(_237, 0);
    int32_t _239 = _238 * _16;
    int32_t _240 = _239 - _27;
    int32_t _241 = _patched_canny_s0_y_p_rebased + _206;
    int32_t _242 = _241 * 17;
    int32_t _243 = _242 + _208;
    for (int _patched_canny_s0_x_p = 0; _patched_canny_s0_x_p < 0 + 17; _patched_canny_s0_x_p++)
    {
     int32_t _244 = _patched_canny_s0_x_p + _227;
     int32_t _245 = _14 + -1;
     int32_t _246 = ::halide_cpp_min(_244, _245);
     int32_t _247 = ::halide_cpp_max(_246, 0);
     int32_t _248 = _247 + _240;
     uint8_t _249 = ((uint8_t *)_I_canny)[_248];
     int32_t _250 = _patched_canny_s0_x_p + _243;
     ((uint8_t *)_patched_canny)[_250] = _249;
    } // for _patched_canny_s0_x_p
   } // for _patched_canny_s0_y_p_rebased
  } // for _patched_canny_s0_p_v15
  int32_t _251 = _patched_canny_s0_p_fused_v14 * 32;
  int32_t _252 = _251 + _18;
  int32_t _253 = _33 + -31;
  int32_t _254 = ::halide_cpp_min(_252, _253);
  int32_t _255 = _254 - _20;
  for (int _patched_b_canny_s0_p_v15 = 0; _patched_b_canny_s0_p_v15 < 0 + 32; _patched_b_canny_s0_p_v15++)
  {
   int32_t _256 = _patched_b_canny_s0_p_v15 + _254;
   float _257 = (float)(_256);
   float _258 = _257 / _26;
   float _259 = floor_f32(_258);
   float _260 = float_from_bits(1098907648 /* 16 */);
   float _261 = _259 * _260;
   int32_t _262 = (int32_t)(_261);
   int32_t _263 = _15 - _262;
   int32_t _264 = ::halide_cpp_min(_263, 17);
   int32_t _265 = ::halide_cpp_max(_262, -17);
   int32_t _266 = 0 - _265;
   int32_t _267 = ::halide_cpp_max(_264, _266);
   int32_t _268 = _patched_b_canny_s0_p_v15 + _255;
   int32_t _269 = _268 * 289;
   int32_t _270 = ::halide_cpp_min(_262, 0);
   int32_t _271 = ::halide_cpp_max(_270, -17);
   int32_t _272 = 0 - _271;
   for (int _patched_b_canny_s0_y_p = 0; _patched_b_canny_s0_y_p < 0 + _272; _patched_b_canny_s0_y_p++)
   {
    bool _273 = _256 < 0;
    int32_t _274 = (int32_t)(_273 ? -1 : 0);
    bool _275 = _14 == 0;
    int32_t _276 = (int32_t)(_275 ? -1 : 0);
    bool _277 = _14 < 0;
    int32_t _278 = (int32_t)(_277 ? -1 : 0);
    int32_t _279 = _256 * 16;
    int32_t _280 = _279 - _274;
    int32_t _281 = _14 | _276;
    int32_t _282 = _280 % _281;
    int32_t _283 = _14 ^ _278;
    int32_t _284 = ~_278;
    int32_t _285 = _283 + _284;
    int32_t _286 = _274 & _285;
    int32_t _287 = _282 + _286;
    int32_t _288 = ~_276;
    int32_t _289 = _287 & _288;
    float _290 = (float)(_256);
    float _291 = _290 / _26;
    float _292 = floor_f32(_291);
    float _293 = float_from_bits(1098907648 /* 16 */);
    float _294 = _292 * _293;
    int32_t _295 = (int32_t)(_294);
    int32_t _296 = _patched_b_canny_s0_y_p + _295;
    int32_t _297 = _15 + -1;
    int32_t _298 = ::halide_cpp_min(_296, _297);
    int32_t _299 = ::halide_cpp_max(_298, 0);
    int32_t _300 = _299 * _13;
    int32_t _301 = _300 - _28;
    int32_t _302 = _patched_b_canny_s0_y_p * 17;
    int32_t _303 = _302 + _269;
    for (int _patched_b_canny_s0_x_p = 0; _patched_b_canny_s0_x_p < 0 + 17; _patched_b_canny_s0_x_p++)
    {
     int32_t _304 = _patched_b_canny_s0_x_p + _289;
     int32_t _305 = _14 + -1;
     int32_t _306 = ::halide_cpp_min(_304, _305);
     int32_t _307 = ::halide_cpp_max(_306, 0);
     int32_t _308 = _307 + _301;
     uint8_t _309 = ((uint8_t *)_I_back_canny)[_308];
     int32_t _310 = _patched_b_canny_s0_x_p + _303;
     ((uint8_t *)_patched_b_canny)[_310] = _309;
    } // for _patched_b_canny_s0_x_p
   } // for _patched_b_canny_s0_y_p
   int32_t _311 = _patched_b_canny_s0_p_v15 + _254;
   int32_t _312 = ::halide_cpp_min(_262, 0);
   int32_t _313 = ::halide_cpp_max(_312, -17);
   int32_t _314 = _patched_b_canny_s0_p_v15 + _255;
   int32_t _315 = _314 * 289;
   bool _316 = _311 < 0;
   int32_t _317 = (int32_t)(_316 ? -1 : 0);
   bool _318 = _14 == 0;
   int32_t _319 = (int32_t)(_318 ? -1 : 0);
   bool _320 = _14 < 0;
   int32_t _321 = (int32_t)(_320 ? -1 : 0);
   int32_t _322 = _311 * 16;
   int32_t _323 = _322 - _317;
   int32_t _324 = _14 | _319;
   int32_t _325 = _323 % _324;
   int32_t _326 = _14 ^ _321;
   int32_t _327 = ~_321;
   int32_t _328 = _326 + _327;
   int32_t _329 = _317 & _328;
   int32_t _330 = _325 + _329;
   int32_t _331 = ~_319;
   int32_t _332 = _330 & _331;
   int32_t _333 = _14 - _332;
   int32_t _334 = ::halide_cpp_max(_267, 0);
   int32_t _335 = _334 + _313;
   for (int _patched_b_canny_s0_y_p_rebased = 0; _patched_b_canny_s0_y_p_rebased < 0 + _335; _patched_b_canny_s0_y_p_rebased++)
   {
    int32_t _336 = _patched_b_canny_s0_y_p_rebased - _313;
    int32_t _337 = ::halide_cpp_min(_333, 17);
    int32_t _338 = ::halide_cpp_max(_337, 0);
    bool _339 = _311 < 0;
    int32_t _340 = (int32_t)(_339 ? -1 : 0);
    bool _341 = _14 == 0;
    int32_t _342 = (int32_t)(_341 ? -1 : 0);
    bool _343 = _14 < 0;
    int32_t _344 = (int32_t)(_343 ? -1 : 0);
    int32_t _345 = _311 * 16;
    int32_t _346 = _345 - _340;
    int32_t _347 = _14 | _342;
    int32_t _348 = _346 % _347;
    int32_t _349 = _14 ^ _344;
    int32_t _350 = ~_344;
    int32_t _351 = _349 + _350;
    int32_t _352 = _340 & _351;
    int32_t _353 = _348 + _352;
    int32_t _354 = ~_342;
    int32_t _355 = _353 & _354;
    float _356 = (float)(_311);
    float _357 = _356 / _26;
    float _358 = floor_f32(_357);
    float _359 = float_from_bits(1098907648 /* 16 */);
    float _360 = _358 * _359;
    int32_t _361 = (int32_t)(_360);
    int32_t _362 = _336 + _361;
    int32_t _363 = _15 + -1;
    int32_t _364 = ::halide_cpp_min(_362, _363);
    int32_t _365 = ::halide_cpp_max(_364, 0);
    int32_t _366 = _365 * _13;
    int32_t _367 = _366 - _28;
    int32_t _368 = _336 * 17;
    int32_t _369 = _368 + _315;
    for (int _patched_b_canny_s0_x_p = 0; _patched_b_canny_s0_x_p < 0 + _338; _patched_b_canny_s0_x_p++)
    {
     int32_t _370 = _patched_b_canny_s0_x_p + _355;
     int32_t _371 = _14 + -1;
     int32_t _372 = ::halide_cpp_min(_370, _371);
     int32_t _373 = ::halide_cpp_max(_372, 0);
     int32_t _374 = _373 + _367;
     uint8_t _375 = ((uint8_t *)_I_back_canny)[_374];
     int32_t _376 = _patched_b_canny_s0_x_p + _369;
     ((uint8_t *)_patched_b_canny)[_376] = _375;
    } // for _patched_b_canny_s0_x_p
    int32_t _377 = ::halide_cpp_min(_333, 17);
    int32_t _378 = ::halide_cpp_max(_377, 0);
    int32_t _379 = _336 * 17;
    bool _380 = _311 < 0;
    int32_t _381 = (int32_t)(_380 ? -1 : 0);
    bool _382 = _14 == 0;
    int32_t _383 = (int32_t)(_382 ? -1 : 0);
    bool _384 = _14 < 0;
    int32_t _385 = (int32_t)(_384 ? -1 : 0);
    int32_t _386 = _311 * 16;
    int32_t _387 = _386 - _381;
    int32_t _388 = _14 | _383;
    int32_t _389 = _387 % _388;
    int32_t _390 = _14 ^ _385;
    int32_t _391 = ~_385;
    int32_t _392 = _390 + _391;
    int32_t _393 = _381 & _392;
    int32_t _394 = _389 + _393;
    int32_t _395 = ~_383;
    int32_t _396 = _394 & _395;
    float _397 = (float)(_311);
    float _398 = _397 / _26;
    float _399 = floor_f32(_398);
    float _400 = float_from_bits(1098907648 /* 16 */);
    float _401 = _399 * _400;
    int32_t _402 = (int32_t)(_401);
    int32_t _403 = _336 + _402;
    int32_t _404 = _15 + -1;
    int32_t _405 = ::halide_cpp_min(_403, _404);
    int32_t _406 = ::halide_cpp_max(_405, 0);
    int32_t _407 = _406 * _13;
    int32_t _408 = _407 - _28;
    int32_t _409 = 17 - _378;
    for (int _patched_b_canny_s0_x_p_rebased = 0; _patched_b_canny_s0_x_p_rebased < 0 + _409; _patched_b_canny_s0_x_p_rebased++)
    {
     int32_t _410 = _396 + _378;
     int32_t _411 = _410 + _patched_b_canny_s0_x_p_rebased;
     int32_t _412 = _14 + -1;
     int32_t _413 = ::halide_cpp_min(_411, _412);
     int32_t _414 = ::halide_cpp_max(_413, 0);
     int32_t _415 = _414 + _408;
     uint8_t _416 = ((uint8_t *)_I_back_canny)[_415];
     int32_t _417 = _315 + _378;
     int32_t _418 = _417 + _379;
     int32_t _419 = _418 + _patched_b_canny_s0_x_p_rebased;
     ((uint8_t *)_patched_b_canny)[_419] = _416;
    } // for _patched_b_canny_s0_x_p_rebased
   } // for _patched_b_canny_s0_y_p_rebased
   int32_t _420 = ::halide_cpp_max(_267, 0);
   int32_t _421 = _patched_b_canny_s0_p_v15 + _255;
   int32_t _422 = _421 * 289;
   int32_t _423 = _patched_b_canny_s0_p_v15 + _254;
   int32_t _424 = 17 - _420;
   for (int _patched_b_canny_s0_y_p_rebased = 0; _patched_b_canny_s0_y_p_rebased < 0 + _424; _patched_b_canny_s0_y_p_rebased++)
   {
    bool _425 = _423 < 0;
    int32_t _426 = (int32_t)(_425 ? -1 : 0);
    bool _427 = _14 == 0;
    int32_t _428 = (int32_t)(_427 ? -1 : 0);
    bool _429 = _14 < 0;
    int32_t _430 = (int32_t)(_429 ? -1 : 0);
    int32_t _431 = _423 * 16;
    int32_t _432 = _431 - _426;
    int32_t _433 = _14 | _428;
    int32_t _434 = _432 % _433;
    int32_t _435 = _14 ^ _430;
    int32_t _436 = ~_430;
    int32_t _437 = _435 + _436;
    int32_t _438 = _426 & _437;
    int32_t _439 = _434 + _438;
    int32_t _440 = ~_428;
    int32_t _441 = _439 & _440;
    float _442 = (float)(_423);
    float _443 = _442 / _26;
    float _444 = floor_f32(_443);
    float _445 = float_from_bits(1098907648 /* 16 */);
    float _446 = _444 * _445;
    int32_t _447 = (int32_t)(_446);
    int32_t _448 = _420 + _447;
    int32_t _449 = _448 + _patched_b_canny_s0_y_p_rebased;
    int32_t _450 = _15 + -1;
    int32_t _451 = ::halide_cpp_min(_449, _450);
    int32_t _452 = ::halide_cpp_max(_451, 0);
    int32_t _453 = _452 * _13;
    int32_t _454 = _453 - _28;
    int32_t _455 = _patched_b_canny_s0_y_p_rebased + _420;
    int32_t _456 = _455 * 17;
    int32_t _457 = _456 + _422;
    for (int _patched_b_canny_s0_x_p = 0; _patched_b_canny_s0_x_p < 0 + 17; _patched_b_canny_s0_x_p++)
    {
     int32_t _458 = _patched_b_canny_s0_x_p + _441;
     int32_t _459 = _14 + -1;
     int32_t _460 = ::halide_cpp_min(_458, _459);
     int32_t _461 = ::halide_cpp_max(_460, 0);
     int32_t _462 = _461 + _454;
     uint8_t _463 = ((uint8_t *)_I_back_canny)[_462];
     int32_t _464 = _patched_b_canny_s0_x_p + _457;
     ((uint8_t *)_patched_b_canny)[_464] = _463;
    } // for _patched_b_canny_s0_x_p
   } // for _patched_b_canny_s0_y_p_rebased
  } // for _patched_b_canny_s0_p_v15
  int32_t _465 = _patched_canny_s0_p_fused_v14 * 32;
  int32_t _466 = _465 + _18;
  int32_t _467 = _33 + -31;
  int32_t _468 = ::halide_cpp_min(_466, _467);
  int32_t _469 = _468 - _24;
  for (int _patched_depth_s0_p_v15 = 0; _patched_depth_s0_p_v15 < 0 + 32; _patched_depth_s0_p_v15++)
  {
   int32_t _470 = _patched_depth_s0_p_v15 + _468;
   float _471 = (float)(_470);
   float _472 = _471 / _26;
   float _473 = floor_f32(_472);
   float _474 = float_from_bits(1098907648 /* 16 */);
   float _475 = _473 * _474;
   int32_t _476 = (int32_t)(_475);
   int32_t _477 = _15 - _476;
   int32_t _478 = ::halide_cpp_min(_477, 17);
   int32_t _479 = ::halide_cpp_max(_476, -17);
   int32_t _480 = 0 - _479;
   int32_t _481 = ::halide_cpp_max(_478, _480);
   int32_t _482 = _patched_depth_s0_p_v15 + _469;
   int32_t _483 = _482 * 289;
   int32_t _484 = ::halide_cpp_min(_476, 0);
   int32_t _485 = ::halide_cpp_max(_484, -17);
   int32_t _486 = 0 - _485;
   for (int _patched_depth_s0_y_p = 0; _patched_depth_s0_y_p < 0 + _486; _patched_depth_s0_y_p++)
   {
    bool _487 = _470 < 0;
    int32_t _488 = (int32_t)(_487 ? -1 : 0);
    bool _489 = _14 == 0;
    int32_t _490 = (int32_t)(_489 ? -1 : 0);
    bool _491 = _14 < 0;
    int32_t _492 = (int32_t)(_491 ? -1 : 0);
    int32_t _493 = _470 * 16;
    int32_t _494 = _493 - _488;
    int32_t _495 = _14 | _490;
    int32_t _496 = _494 % _495;
    int32_t _497 = _14 ^ _492;
    int32_t _498 = ~_492;
    int32_t _499 = _497 + _498;
    int32_t _500 = _488 & _499;
    int32_t _501 = _496 + _500;
    int32_t _502 = ~_490;
    int32_t _503 = _501 & _502;
    float _504 = (float)(_470);
    float _505 = _504 / _26;
    float _506 = floor_f32(_505);
    float _507 = float_from_bits(1098907648 /* 16 */);
    float _508 = _506 * _507;
    int32_t _509 = (int32_t)(_508);
    int32_t _510 = _patched_depth_s0_y_p + _509;
    int32_t _511 = _15 + -1;
    int32_t _512 = ::halide_cpp_min(_510, _511);
    int32_t _513 = ::halide_cpp_max(_512, 0);
    int32_t _514 = _513 * _17;
    int32_t _515 = _514 - _29;
    int32_t _516 = _patched_depth_s0_y_p * 17;
    int32_t _517 = _516 + _483;
    for (int _patched_depth_s0_x_p = 0; _patched_depth_s0_x_p < 0 + 17; _patched_depth_s0_x_p++)
    {
     int32_t _518 = _patched_depth_s0_x_p + _503;
     int32_t _519 = _14 + -1;
     int32_t _520 = ::halide_cpp_min(_518, _519);
     int32_t _521 = ::halide_cpp_max(_520, 0);
     int32_t _522 = _521 + _515;
     uint8_t _523 = ((uint8_t *)_I_depth)[_522];
     int32_t _524 = _patched_depth_s0_x_p + _517;
     ((uint8_t *)_patched_depth)[_524] = _523;
    } // for _patched_depth_s0_x_p
   } // for _patched_depth_s0_y_p
   int32_t _525 = _patched_depth_s0_p_v15 + _468;
   int32_t _526 = ::halide_cpp_min(_476, 0);
   int32_t _527 = ::halide_cpp_max(_526, -17);
   int32_t _528 = _patched_depth_s0_p_v15 + _469;
   int32_t _529 = _528 * 289;
   bool _530 = _525 < 0;
   int32_t _531 = (int32_t)(_530 ? -1 : 0);
   bool _532 = _14 == 0;
   int32_t _533 = (int32_t)(_532 ? -1 : 0);
   bool _534 = _14 < 0;
   int32_t _535 = (int32_t)(_534 ? -1 : 0);
   int32_t _536 = _525 * 16;
   int32_t _537 = _536 - _531;
   int32_t _538 = _14 | _533;
   int32_t _539 = _537 % _538;
   int32_t _540 = _14 ^ _535;
   int32_t _541 = ~_535;
   int32_t _542 = _540 + _541;
   int32_t _543 = _531 & _542;
   int32_t _544 = _539 + _543;
   int32_t _545 = ~_533;
   int32_t _546 = _544 & _545;
   int32_t _547 = _14 - _546;
   int32_t _548 = ::halide_cpp_max(_481, 0);
   int32_t _549 = _548 + _527;
   for (int _patched_depth_s0_y_p_rebased = 0; _patched_depth_s0_y_p_rebased < 0 + _549; _patched_depth_s0_y_p_rebased++)
   {
    int32_t _550 = _patched_depth_s0_y_p_rebased - _527;
    int32_t _551 = ::halide_cpp_min(_547, 17);
    int32_t _552 = ::halide_cpp_max(_551, 0);
    bool _553 = _525 < 0;
    int32_t _554 = (int32_t)(_553 ? -1 : 0);
    bool _555 = _14 == 0;
    int32_t _556 = (int32_t)(_555 ? -1 : 0);
    bool _557 = _14 < 0;
    int32_t _558 = (int32_t)(_557 ? -1 : 0);
    int32_t _559 = _525 * 16;
    int32_t _560 = _559 - _554;
    int32_t _561 = _14 | _556;
    int32_t _562 = _560 % _561;
    int32_t _563 = _14 ^ _558;
    int32_t _564 = ~_558;
    int32_t _565 = _563 + _564;
    int32_t _566 = _554 & _565;
    int32_t _567 = _562 + _566;
    int32_t _568 = ~_556;
    int32_t _569 = _567 & _568;
    float _570 = (float)(_525);
    float _571 = _570 / _26;
    float _572 = floor_f32(_571);
    float _573 = float_from_bits(1098907648 /* 16 */);
    float _574 = _572 * _573;
    int32_t _575 = (int32_t)(_574);
    int32_t _576 = _550 + _575;
    int32_t _577 = _15 + -1;
    int32_t _578 = ::halide_cpp_min(_576, _577);
    int32_t _579 = ::halide_cpp_max(_578, 0);
    int32_t _580 = _579 * _17;
    int32_t _581 = _580 - _29;
    int32_t _582 = _550 * 17;
    int32_t _583 = _582 + _529;
    for (int _patched_depth_s0_x_p = 0; _patched_depth_s0_x_p < 0 + _552; _patched_depth_s0_x_p++)
    {
     int32_t _584 = _patched_depth_s0_x_p + _569;
     int32_t _585 = _14 + -1;
     int32_t _586 = ::halide_cpp_min(_584, _585);
     int32_t _587 = ::halide_cpp_max(_586, 0);
     int32_t _588 = _587 + _581;
     uint8_t _589 = ((uint8_t *)_I_depth)[_588];
     int32_t _590 = _patched_depth_s0_x_p + _583;
     ((uint8_t *)_patched_depth)[_590] = _589;
    } // for _patched_depth_s0_x_p
    int32_t _591 = ::halide_cpp_min(_547, 17);
    int32_t _592 = ::halide_cpp_max(_591, 0);
    int32_t _593 = _550 * 17;
    bool _594 = _525 < 0;
    int32_t _595 = (int32_t)(_594 ? -1 : 0);
    bool _596 = _14 == 0;
    int32_t _597 = (int32_t)(_596 ? -1 : 0);
    bool _598 = _14 < 0;
    int32_t _599 = (int32_t)(_598 ? -1 : 0);
    int32_t _600 = _525 * 16;
    int32_t _601 = _600 - _595;
    int32_t _602 = _14 | _597;
    int32_t _603 = _601 % _602;
    int32_t _604 = _14 ^ _599;
    int32_t _605 = ~_599;
    int32_t _606 = _604 + _605;
    int32_t _607 = _595 & _606;
    int32_t _608 = _603 + _607;
    int32_t _609 = ~_597;
    int32_t _610 = _608 & _609;
    float _611 = (float)(_525);
    float _612 = _611 / _26;
    float _613 = floor_f32(_612);
    float _614 = float_from_bits(1098907648 /* 16 */);
    float _615 = _613 * _614;
    int32_t _616 = (int32_t)(_615);
    int32_t _617 = _550 + _616;
    int32_t _618 = _15 + -1;
    int32_t _619 = ::halide_cpp_min(_617, _618);
    int32_t _620 = ::halide_cpp_max(_619, 0);
    int32_t _621 = _620 * _17;
    int32_t _622 = _621 - _29;
    int32_t _623 = 17 - _592;
    for (int _patched_depth_s0_x_p_rebased = 0; _patched_depth_s0_x_p_rebased < 0 + _623; _patched_depth_s0_x_p_rebased++)
    {
     int32_t _624 = _610 + _592;
     int32_t _625 = _624 + _patched_depth_s0_x_p_rebased;
     int32_t _626 = _14 + -1;
     int32_t _627 = ::halide_cpp_min(_625, _626);
     int32_t _628 = ::halide_cpp_max(_627, 0);
     int32_t _629 = _628 + _622;
     uint8_t _630 = ((uint8_t *)_I_depth)[_629];
     int32_t _631 = _529 + _592;
     int32_t _632 = _631 + _593;
     int32_t _633 = _632 + _patched_depth_s0_x_p_rebased;
     ((uint8_t *)_patched_depth)[_633] = _630;
    } // for _patched_depth_s0_x_p_rebased
   } // for _patched_depth_s0_y_p_rebased
   int32_t _634 = ::halide_cpp_max(_481, 0);
   int32_t _635 = _patched_depth_s0_p_v15 + _469;
   int32_t _636 = _635 * 289;
   int32_t _637 = _patched_depth_s0_p_v15 + _468;
   int32_t _638 = 17 - _634;
   for (int _patched_depth_s0_y_p_rebased = 0; _patched_depth_s0_y_p_rebased < 0 + _638; _patched_depth_s0_y_p_rebased++)
   {
    bool _639 = _637 < 0;
    int32_t _640 = (int32_t)(_639 ? -1 : 0);
    bool _641 = _14 == 0;
    int32_t _642 = (int32_t)(_641 ? -1 : 0);
    bool _643 = _14 < 0;
    int32_t _644 = (int32_t)(_643 ? -1 : 0);
    int32_t _645 = _637 * 16;
    int32_t _646 = _645 - _640;
    int32_t _647 = _14 | _642;
    int32_t _648 = _646 % _647;
    int32_t _649 = _14 ^ _644;
    int32_t _650 = ~_644;
    int32_t _651 = _649 + _650;
    int32_t _652 = _640 & _651;
    int32_t _653 = _648 + _652;
    int32_t _654 = ~_642;
    int32_t _655 = _653 & _654;
    float _656 = (float)(_637);
    float _657 = _656 / _26;
    float _658 = floor_f32(_657);
    float _659 = float_from_bits(1098907648 /* 16 */);
    float _660 = _658 * _659;
    int32_t _661 = (int32_t)(_660);
    int32_t _662 = _634 + _661;
    int32_t _663 = _662 + _patched_depth_s0_y_p_rebased;
    int32_t _664 = _15 + -1;
    int32_t _665 = ::halide_cpp_min(_663, _664);
    int32_t _666 = ::halide_cpp_max(_665, 0);
    int32_t _667 = _666 * _17;
    int32_t _668 = _667 - _29;
    int32_t _669 = _patched_depth_s0_y_p_rebased + _634;
    int32_t _670 = _669 * 17;
    int32_t _671 = _670 + _636;
    for (int _patched_depth_s0_x_p = 0; _patched_depth_s0_x_p < 0 + 17; _patched_depth_s0_x_p++)
    {
     int32_t _672 = _patched_depth_s0_x_p + _655;
     int32_t _673 = _14 + -1;
     int32_t _674 = ::halide_cpp_min(_672, _673);
     int32_t _675 = ::halide_cpp_max(_674, 0);
     int32_t _676 = _675 + _668;
     uint8_t _677 = ((uint8_t *)_I_depth)[_676];
     int32_t _678 = _patched_depth_s0_x_p + _671;
     ((uint8_t *)_patched_depth)[_678] = _677;
    } // for _patched_depth_s0_x_p
   } // for _patched_depth_s0_y_p_rebased
  } // for _patched_depth_s0_p_v15
  int32_t _679 = _patched_canny_s0_p_fused_v14 * 32;
  int32_t _680 = _679 + _23;
  int32_t _681 = _34 + -31;
  int32_t _682 = ::halide_cpp_min(_680, _681);
  int32_t _683 = _682 - _19;
  for (int _patch_coords_s0_p_v15 = 0; _patch_coords_s0_p_v15 < 0 + 32; _patch_coords_s0_p_v15++)
  {
   int32_t _684 = _patch_coords_s0_p_v15 + _683;
   int32_t _685 = _684 * 289;
   int32_t _686 = _patch_coords_s0_p_v15 + _682;
   for (int _patch_coords_s0_y_p = 0; _patch_coords_s0_y_p < 0 + 17; _patch_coords_s0_y_p++)
   {
    float _687 = (float)(_686);
    float _688 = _687 / _26;
    float _689 = floor_f32(_688);
    float _690 = float_from_bits(1098907648 /* 16 */);
    float _691 = _689 * _690;
    int32_t _692 = (int32_t)(_691);
    int32_t _693 = _patch_coords_s0_y_p + _692;
    int32_t _694 = _15 + -1;
    int32_t _695 = ::halide_cpp_min(_693, _694);
    int32_t _696 = ::halide_cpp_max(_695, 0);
    int32_t _697 = _696 * _14;
    bool _698 = _686 < 0;
    int32_t _699 = (int32_t)(_698 ? -1 : 0);
    bool _700 = _14 == 0;
    int32_t _701 = (int32_t)(_700 ? -1 : 0);
    bool _702 = _14 < 0;
    int32_t _703 = (int32_t)(_702 ? -1 : 0);
    int32_t _704 = _686 * 16;
    int32_t _705 = _704 - _699;
    int32_t _706 = _14 | _701;
    int32_t _707 = _705 % _706;
    int32_t _708 = _14 ^ _703;
    int32_t _709 = ~_703;
    int32_t _710 = _708 + _709;
    int32_t _711 = _699 & _710;
    int32_t _712 = _707 + _711;
    int32_t _713 = ~_701;
    int32_t _714 = _712 & _713;
    int32_t _715 = _patch_coords_s0_y_p * 17;
    int32_t _716 = _715 + _685;
    for (int _patch_coords_s0_x_p = 0; _patch_coords_s0_x_p < 0 + 17; _patch_coords_s0_x_p++)
    {
     int32_t _717 = _patch_coords_s0_x_p + _714;
     int32_t _718 = _14 + -1;
     int32_t _719 = ::halide_cpp_min(_717, _718);
     int32_t _720 = ::halide_cpp_max(_719, 0);
     int32_t _721 = _720 + _697;
     int32_t _722 = _patch_coords_s0_x_p + _716;
     ((int32_t *)_patch_coords)[_722] = _721;
    } // for _patch_coords_s0_x_p
   } // for _patch_coords_s0_y_p
  } // for _patch_coords_s0_p_v15
 } // if _36
 else
 {
  bool _723 = _patched_canny_s0_p_fused_v14 <= _30;
  if (_723)
  {
   int32_t _724 = _patched_canny_s0_p_fused_v14 * 32;
   int32_t _725 = _724 + _23;
   int32_t _726 = _22 + -31;
   int32_t _727 = ::halide_cpp_min(_725, _726);
   int32_t _728 = _727 - _21;
   for (int _patched_canny_s0_p_v15 = 0; _patched_canny_s0_p_v15 < 0 + 32; _patched_canny_s0_p_v15++)
   {
    int32_t _729 = _patched_canny_s0_p_v15 + _728;
    int32_t _730 = _729 * 289;
    int32_t _731 = _patched_canny_s0_p_v15 + _727;
    for (int _patched_canny_s0_y_p = 0; _patched_canny_s0_y_p < 0 + 17; _patched_canny_s0_y_p++)
    {
     bool _732 = _731 < 0;
     int32_t _733 = (int32_t)(_732 ? -1 : 0);
     bool _734 = _14 == 0;
     int32_t _735 = (int32_t)(_734 ? -1 : 0);
     bool _736 = _14 < 0;
     int32_t _737 = (int32_t)(_736 ? -1 : 0);
     int32_t _738 = _731 * 16;
     int32_t _739 = _738 - _733;
     int32_t _740 = _14 | _735;
     int32_t _741 = _739 % _740;
     int32_t _742 = _14 ^ _737;
     int32_t _743 = ~_737;
     int32_t _744 = _742 + _743;
     int32_t _745 = _733 & _744;
     int32_t _746 = _741 + _745;
     int32_t _747 = ~_735;
     int32_t _748 = _746 & _747;
     float _749 = (float)(_731);
     float _750 = _749 / _26;
     float _751 = floor_f32(_750);
     float _752 = float_from_bits(1098907648 /* 16 */);
     float _753 = _751 * _752;
     int32_t _754 = (int32_t)(_753);
     int32_t _755 = _patched_canny_s0_y_p + _754;
     int32_t _756 = _15 + -1;
     int32_t _757 = ::halide_cpp_min(_755, _756);
     int32_t _758 = ::halide_cpp_max(_757, 0);
     int32_t _759 = _758 * _16;
     int32_t _760 = _759 - _27;
     int32_t _761 = _patched_canny_s0_y_p * 17;
     int32_t _762 = _761 + _730;
     for (int _patched_canny_s0_x_p = 0; _patched_canny_s0_x_p < 0 + 17; _patched_canny_s0_x_p++)
     {
      int32_t _763 = _patched_canny_s0_x_p + _748;
      int32_t _764 = _14 + -1;
      int32_t _765 = ::halide_cpp_min(_763, _764);
      int32_t _766 = ::halide_cpp_max(_765, 0);
      int32_t _767 = _766 + _760;
      uint8_t _768 = ((uint8_t *)_I_canny)[_767];
      int32_t _769 = _patched_canny_s0_x_p + _762;
      ((uint8_t *)_patched_canny)[_769] = _768;
     } // for _patched_canny_s0_x_p
    } // for _patched_canny_s0_y_p
   } // for _patched_canny_s0_p_v15
  } // if _723
  bool _770 = _patched_canny_s0_p_fused_v14 <= _31;
  if (_770)
  {
   int32_t _771 = _patched_canny_s0_p_fused_v14 * 32;
   int32_t _772 = _771 + _18;
   int32_t _773 = _33 + -31;
   int32_t _774 = ::halide_cpp_min(_772, _773);
   int32_t _775 = _774 - _20;
   for (int _patched_b_canny_s0_p_v15 = 0; _patched_b_canny_s0_p_v15 < 0 + 32; _patched_b_canny_s0_p_v15++)
   {
    int32_t _776 = _patched_b_canny_s0_p_v15 + _775;
    int32_t _777 = _776 * 289;
    int32_t _778 = _patched_b_canny_s0_p_v15 + _774;
    for (int _patched_b_canny_s0_y_p = 0; _patched_b_canny_s0_y_p < 0 + 17; _patched_b_canny_s0_y_p++)
    {
     bool _779 = _778 < 0;
     int32_t _780 = (int32_t)(_779 ? -1 : 0);
     bool _781 = _14 == 0;
     int32_t _782 = (int32_t)(_781 ? -1 : 0);
     bool _783 = _14 < 0;
     int32_t _784 = (int32_t)(_783 ? -1 : 0);
     int32_t _785 = _778 * 16;
     int32_t _786 = _785 - _780;
     int32_t _787 = _14 | _782;
     int32_t _788 = _786 % _787;
     int32_t _789 = _14 ^ _784;
     int32_t _790 = ~_784;
     int32_t _791 = _789 + _790;
     int32_t _792 = _780 & _791;
     int32_t _793 = _788 + _792;
     int32_t _794 = ~_782;
     int32_t _795 = _793 & _794;
     float _796 = (float)(_778);
     float _797 = _796 / _26;
     float _798 = floor_f32(_797);
     float _799 = float_from_bits(1098907648 /* 16 */);
     float _800 = _798 * _799;
     int32_t _801 = (int32_t)(_800);
     int32_t _802 = _patched_b_canny_s0_y_p + _801;
     int32_t _803 = _15 + -1;
     int32_t _804 = ::halide_cpp_min(_802, _803);
     int32_t _805 = ::halide_cpp_max(_804, 0);
     int32_t _806 = _805 * _13;
     int32_t _807 = _806 - _28;
     int32_t _808 = _patched_b_canny_s0_y_p * 17;
     int32_t _809 = _808 + _777;
     for (int _patched_b_canny_s0_x_p = 0; _patched_b_canny_s0_x_p < 0 + 17; _patched_b_canny_s0_x_p++)
     {
      int32_t _810 = _patched_b_canny_s0_x_p + _795;
      int32_t _811 = _14 + -1;
      int32_t _812 = ::halide_cpp_min(_810, _811);
      int32_t _813 = ::halide_cpp_max(_812, 0);
      int32_t _814 = _813 + _807;
      uint8_t _815 = ((uint8_t *)_I_back_canny)[_814];
      int32_t _816 = _patched_b_canny_s0_x_p + _809;
      ((uint8_t *)_patched_b_canny)[_816] = _815;
     } // for _patched_b_canny_s0_x_p
    } // for _patched_b_canny_s0_y_p
   } // for _patched_b_canny_s0_p_v15
   int32_t _817 = _774 - _24;
   for (int _patched_depth_s0_p_v15 = 0; _patched_depth_s0_p_v15 < 0 + 32; _patched_depth_s0_p_v15++)
   {
    int32_t _818 = _patched_depth_s0_p_v15 + _817;
    int32_t _819 = _818 * 289;
    int32_t _820 = _patched_depth_s0_p_v15 + _774;
    for (int _patched_depth_s0_y_p = 0; _patched_depth_s0_y_p < 0 + 17; _patched_depth_s0_y_p++)
    {
     bool _821 = _820 < 0;
     int32_t _822 = (int32_t)(_821 ? -1 : 0);
     bool _823 = _14 == 0;
     int32_t _824 = (int32_t)(_823 ? -1 : 0);
     bool _825 = _14 < 0;
     int32_t _826 = (int32_t)(_825 ? -1 : 0);
     int32_t _827 = _820 * 16;
     int32_t _828 = _827 - _822;
     int32_t _829 = _14 | _824;
     int32_t _830 = _828 % _829;
     int32_t _831 = _14 ^ _826;
     int32_t _832 = ~_826;
     int32_t _833 = _831 + _832;
     int32_t _834 = _822 & _833;
     int32_t _835 = _830 + _834;
     int32_t _836 = ~_824;
     int32_t _837 = _835 & _836;
     float _838 = (float)(_820);
     float _839 = _838 / _26;
     float _840 = floor_f32(_839);
     float _841 = float_from_bits(1098907648 /* 16 */);
     float _842 = _840 * _841;
     int32_t _843 = (int32_t)(_842);
     int32_t _844 = _patched_depth_s0_y_p + _843;
     int32_t _845 = _15 + -1;
     int32_t _846 = ::halide_cpp_min(_844, _845);
     int32_t _847 = ::halide_cpp_max(_846, 0);
     int32_t _848 = _847 * _17;
     int32_t _849 = _848 - _29;
     int32_t _850 = _patched_depth_s0_y_p * 17;
     int32_t _851 = _850 + _819;
     for (int _patched_depth_s0_x_p = 0; _patched_depth_s0_x_p < 0 + 17; _patched_depth_s0_x_p++)
     {
      int32_t _852 = _patched_depth_s0_x_p + _837;
      int32_t _853 = _14 + -1;
      int32_t _854 = ::halide_cpp_min(_852, _853);
      int32_t _855 = ::halide_cpp_max(_854, 0);
      int32_t _856 = _855 + _849;
      uint8_t _857 = ((uint8_t *)_I_depth)[_856];
      int32_t _858 = _patched_depth_s0_x_p + _851;
      ((uint8_t *)_patched_depth)[_858] = _857;
     } // for _patched_depth_s0_x_p
    } // for _patched_depth_s0_y_p
   } // for _patched_depth_s0_p_v15
  } // if _770
  bool _859 = _patched_canny_s0_p_fused_v14 <= _32;
  if (_859)
  {
   int32_t _860 = _patched_canny_s0_p_fused_v14 * 32;
   int32_t _861 = _860 + _23;
   int32_t _862 = _34 + -31;
   int32_t _863 = ::halide_cpp_min(_861, _862);
   int32_t _864 = _863 - _19;
   for (int _patch_coords_s0_p_v15 = 0; _patch_coords_s0_p_v15 < 0 + 32; _patch_coords_s0_p_v15++)
   {
    int32_t _865 = _patch_coords_s0_p_v15 + _864;
    int32_t _866 = _865 * 289;
    int32_t _867 = _patch_coords_s0_p_v15 + _863;
    for (int _patch_coords_s0_y_p = 0; _patch_coords_s0_y_p < 0 + 17; _patch_coords_s0_y_p++)
    {
     float _868 = (float)(_867);
     float _869 = _868 / _26;
     float _870 = floor_f32(_869);
     float _871 = float_from_bits(1098907648 /* 16 */);
     float _872 = _870 * _871;
     int32_t _873 = (int32_t)(_872);
     int32_t _874 = _patch_coords_s0_y_p + _873;
     int32_t _875 = _15 + -1;
     int32_t _876 = ::halide_cpp_min(_874, _875);
     int32_t _877 = ::halide_cpp_max(_876, 0);
     int32_t _878 = _877 * _14;
     bool _879 = _867 < 0;
     int32_t _880 = (int32_t)(_879 ? -1 : 0);
     bool _881 = _14 == 0;
     int32_t _882 = (int32_t)(_881 ? -1 : 0);
     bool _883 = _14 < 0;
     int32_t _884 = (int32_t)(_883 ? -1 : 0);
     int32_t _885 = _867 * 16;
     int32_t _886 = _885 - _880;
     int32_t _887 = _14 | _882;
     int32_t _888 = _886 % _887;
     int32_t _889 = _14 ^ _884;
     int32_t _890 = ~_884;
     int32_t _891 = _889 + _890;
     int32_t _892 = _880 & _891;
     int32_t _893 = _888 + _892;
     int32_t _894 = ~_882;
     int32_t _895 = _893 & _894;
     int32_t _896 = _patch_coords_s0_y_p * 17;
     int32_t _897 = _896 + _866;
     for (int _patch_coords_s0_x_p = 0; _patch_coords_s0_x_p < 0 + 17; _patch_coords_s0_x_p++)
     {
      int32_t _898 = _patch_coords_s0_x_p + _895;
      int32_t _899 = _14 + -1;
      int32_t _900 = ::halide_cpp_min(_898, _899);
      int32_t _901 = ::halide_cpp_max(_900, 0);
      int32_t _902 = _901 + _878;
      int32_t _903 = _patch_coords_s0_x_p + _897;
      ((int32_t *)_patch_coords)[_903] = _902;
     } // for _patch_coords_s0_x_p
    } // for _patch_coords_s0_y_p
   } // for _patch_coords_s0_p_v15
  } // if _859
 } // if _36 else
 return 0;
}
static HALIDE_FUNCTION_ATTRS
int foreground_mesh_verts_par_for_sum_p_canny_s0_p_fused_v14(void *__user_context, int32_t _sum_p_canny_s0_p_fused_v14, uint8_t *_closure_arg__1) {
 void * const _ucon = const_cast<void *>(__user_context);
 halide_maybe_unused(_ucon);
 auto *_904 = (void *)(nullptr);
 struct {
  void * f_0;
  void * f_1;
  void * f_2;
  void * f_3;
  int32_t f_4;
  int32_t f_5;
  int32_t f_6;
  int32_t f_7;
  int32_t f_8;
  int32_t f_9;
 } s1 = {
  _904,
  _904,
  _904,
  _904,
  0,
  0,
  0,
  0,
  0,
  0
 };
 auto *_905 = (&s1);
 auto _closure_prototype__1 = _905;
 halide_maybe_unused(_closure_prototype__1);
 auto *_906 = ((decltype(_closure_prototype__1))_closure_arg__1)->f_0;
 auto _patched_b_canny = _906;
 halide_maybe_unused(_patched_b_canny);
 auto *_907 = ((decltype(_closure_prototype__1))_closure_arg__1)->f_1;
 auto _patched_canny = _907;
 halide_maybe_unused(_patched_canny);
 auto *_908 = ((decltype(_closure_prototype__1))_closure_arg__1)->f_2;
 auto _sum_p_b_canny = _908;
 halide_maybe_unused(_sum_p_b_canny);
 auto *_909 = ((decltype(_closure_prototype__1))_closure_arg__1)->f_3;
 auto _sum_p_canny = _909;
 halide_maybe_unused(_sum_p_canny);
 int32_t _910 = ((decltype(_closure_prototype__1))_closure_arg__1)->f_4;
 int32_t _911 = ((decltype(_closure_prototype__1))_closure_arg__1)->f_5;
 int32_t _912 = ((decltype(_closure_prototype__1))_closure_arg__1)->f_6;
 int32_t _913 = ((decltype(_closure_prototype__1))_closure_arg__1)->f_7;
 int32_t _914 = ((decltype(_closure_prototype__1))_closure_arg__1)->f_8;
 int32_t _915 = ((decltype(_closure_prototype__1))_closure_arg__1)->f_9;
 int32_t _916 = _sum_p_canny_s0_p_fused_v14 * 32;
 int32_t _917 = _916 + _910;
 int32_t _918 = _915 + -31;
 int32_t _919 = ::halide_cpp_min(_917, _918);
 int32_t _920 = _919 - _914;
 int32_t _921 = _919 - _912;
 for (int _sum_p_canny_s0_p_v15 = 0; _sum_p_canny_s0_p_v15 < 0 + 32; _sum_p_canny_s0_p_v15++)
 {
  {
   float _sum[1];
   // produce sum
   float _922 = float_from_bits(0 /* 0 */);
   _sum[0] = _922;
   int32_t _923 = _sum_p_canny_s0_p_v15 + _921;
   int32_t _924 = _923 * 289;
   for (int _sum_s1_r49__y = 0; _sum_s1_r49__y < 0 + 17; _sum_s1_r49__y++)
   {
    int32_t _925 = _sum_s1_r49__y * 17;
    int32_t _926 = _925 + _924;
    for (int _sum_s1_r49__x = 0; _sum_s1_r49__x < 0 + 17; _sum_s1_r49__x++)
    {
     float _927 = _sum[0];
     float _928 = float_from_bits(1065353216 /* 1 */);
     float _929 = float_from_bits(0 /* 0 */);
     uint8_t _930 = (uint8_t)(0ull);
     int32_t _931 = _sum_s1_r49__x + _926;
     uint8_t _932 = ((uint8_t *)_patched_canny)[_931];
     bool _933 = _930 < _932;
     float _934 = (float)(_933 ? _928 : _929);
     float _935 = _927 + _934;
     _sum[0] = _935;
    } // for _sum_s1_r49__x
   } // for _sum_s1_r49__y
   // consume sum
   float _936 = _sum[0];
   int32_t _937 = _sum_p_canny_s0_p_v15 + _920;
   ((float *)_sum_p_canny)[_937] = _936;
  } // alloc _sum
 } // for _sum_p_canny_s0_p_v15
 int32_t _938 = _919 - _913;
 int32_t _939 = _919 - _911;
 for (int _sum_p_b_canny_s0_p_v15 = 0; _sum_p_b_canny_s0_p_v15 < 0 + 32; _sum_p_b_canny_s0_p_v15++)
 {
  {
   float _sum__1[1];
   // produce sum$1
   float _940 = float_from_bits(0 /* 0 */);
   _sum__1[0] = _940;
   int32_t _941 = _sum_p_b_canny_s0_p_v15 + _939;
   int32_t _942 = _941 * 289;
   for (int _sum__1_s1_r49__y = 0; _sum__1_s1_r49__y < 0 + 17; _sum__1_s1_r49__y++)
   {
    int32_t _943 = _sum__1_s1_r49__y * 17;
    int32_t _944 = _943 + _942;
    for (int _sum__1_s1_r49__x = 0; _sum__1_s1_r49__x < 0 + 17; _sum__1_s1_r49__x++)
    {
     float _945 = _sum__1[0];
     float _946 = float_from_bits(1065353216 /* 1 */);
     float _947 = float_from_bits(0 /* 0 */);
     uint8_t _948 = (uint8_t)(0ull);
     int32_t _949 = _sum__1_s1_r49__x + _944;
     uint8_t _950 = ((uint8_t *)_patched_b_canny)[_949];
     bool _951 = _948 < _950;
     float _952 = (float)(_951 ? _946 : _947);
     float _953 = _945 + _952;
     _sum__1[0] = _953;
    } // for _sum__1_s1_r49__x
   } // for _sum__1_s1_r49__y
   // consume sum$1
   float _954 = _sum__1[0];
   int32_t _955 = _sum_p_b_canny_s0_p_v15 + _938;
   ((float *)_sum_p_b_canny)[_955] = _954;
  } // alloc _sum__1
 } // for _sum_p_b_canny_s0_p_v15
 return 0;
}
static HALIDE_FUNCTION_ATTRS
int foreground_mesh_verts_par_for_mean_depth_s0_p_fused_v14(void *__user_context, int32_t _mean_depth_s0_p_fused_v14, uint8_t *_closure_arg__2) {
 void * const _ucon = const_cast<void *>(__user_context);
 halide_maybe_unused(_ucon);
 auto *_956 = (void *)(nullptr);
 struct {
  void * f_0;
  void * f_1;
  void * f_2;
  void * f_3;
  void * f_4;
  void * f_5;
  void * f_6;
  int32_t f_7;
  int32_t f_8;
  int32_t f_9;
  int32_t f_10;
  int32_t f_11;
  int32_t f_12;
  int32_t f_13;
  int32_t f_14;
 } s2 = {
  _956,
  _956,
  _956,
  _956,
  _956,
  _956,
  _956,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
 };
 auto *_957 = (&s2);
 auto _closure_prototype__2 = _957;
 halide_maybe_unused(_closure_prototype__2);
 auto *_958 = ((decltype(_closure_prototype__2))_closure_arg__2)->f_0;
 auto _mean_b_depth = _958;
 halide_maybe_unused(_mean_b_depth);
 auto *_959 = ((decltype(_closure_prototype__2))_closure_arg__2)->f_1;
 auto _mean_depth = _959;
 halide_maybe_unused(_mean_depth);
 auto *_960 = ((decltype(_closure_prototype__2))_closure_arg__2)->f_2;
 auto _patched_b_canny = _960;
 halide_maybe_unused(_patched_b_canny);
 auto *_961 = ((decltype(_closure_prototype__2))_closure_arg__2)->f_3;
 auto _patched_canny = _961;
 halide_maybe_unused(_patched_canny);
 auto *_962 = ((decltype(_closure_prototype__2))_closure_arg__2)->f_4;
 auto _patched_depth = _962;
 halide_maybe_unused(_patched_depth);
 auto *_963 = ((decltype(_closure_prototype__2))_closure_arg__2)->f_5;
 auto _sum_p_b_canny = _963;
 halide_maybe_unused(_sum_p_b_canny);
 auto *_964 = ((decltype(_closure_prototype__2))_closure_arg__2)->f_6;
 auto _sum_p_canny = _964;
 halide_maybe_unused(_sum_p_canny);
 int32_t _965 = ((decltype(_closure_prototype__2))_closure_arg__2)->f_7;
 int32_t _966 = ((decltype(_closure_prototype__2))_closure_arg__2)->f_8;
 int32_t _967 = ((decltype(_closure_prototype__2))_closure_arg__2)->f_9;
 int32_t _968 = ((decltype(_closure_prototype__2))_closure_arg__2)->f_10;
 int32_t _969 = ((decltype(_closure_prototype__2))_closure_arg__2)->f_11;
 int32_t _970 = ((decltype(_closure_prototype__2))_closure_arg__2)->f_12;
 int32_t _971 = ((decltype(_closure_prototype__2))_closure_arg__2)->f_13;
 int32_t _972 = ((decltype(_closure_prototype__2))_closure_arg__2)->f_14;
 int32_t _973 = _mean_depth_s0_p_fused_v14 * 32;
 int32_t _974 = _973 + _965;
 int32_t _975 = _972 + -31;
 int32_t _976 = ::halide_cpp_min(_974, _975);
 int32_t _977 = _976 - _971;
 int32_t _978 = _976 - _969;
 int32_t _979 = _976 - _968;
 int32_t _980 = _976 - _966;
 for (int _mean_depth_s0_p_v15 = 0; _mean_depth_s0_p_v15 < 0 + 32; _mean_depth_s0_p_v15++)
 {
  {
   float _sum__2[1];
   // produce sum$2
   float _981 = float_from_bits(0 /* 0 */);
   _sum__2[0] = _981;
   int32_t _982 = _mean_depth_s0_p_v15 + _978;
   int32_t _983 = _982 * 289;
   int32_t _984 = _mean_depth_s0_p_v15 + _979;
   int32_t _985 = _984 * 289;
   int32_t _986 = _mean_depth_s0_p_v15 + _977;
   for (int _sum__2_s1_r49__y = 0; _sum__2_s1_r49__y < 0 + 17; _sum__2_s1_r49__y++)
   {
    int32_t _987 = _sum__2_s1_r49__y * 17;
    int32_t _988 = _983 + _987;
    int32_t _989 = _985 + _987;
    for (int _sum__2_s1_r49__x = 0; _sum__2_s1_r49__x < 0 + 17; _sum__2_s1_r49__x++)
    {
     float _990 = _sum__2[0];
     int32_t _991 = _sum__2_s1_r49__x + _988;
     uint8_t _992 = ((uint8_t *)_patched_depth)[_991];
     float _993 = (float)(_992);
     float _994 = float_from_bits(0 /* 0 */);
     uint8_t _995 = (uint8_t)(0ull);
     int32_t _996 = _sum__2_s1_r49__x + _989;
     uint8_t _997 = ((uint8_t *)_patched_canny)[_996];
     bool _998 = _995 < _997;
     float _999 = ((float *)_sum_p_canny)[_986];
     bool _1000 = _994 < _999;
     bool _1001 = _998 && _1000;
     float _1002 = (float)(_1001 ? _993 : _994);
     float _1003 = _990 + _1002;
     _sum__2[0] = _1003;
    } // for _sum__2_s1_r49__x
   } // for _sum__2_s1_r49__y
   // consume sum$2
   int32_t _1004 = _mean_depth_s0_p_v15 + _977;
   float _1005 = ((float *)_sum_p_canny)[_1004];
   float _1006 = _sum__2[0];
   float _1007 = float_from_bits(1065353216 /* 1 */);
   float _1008 = float_from_bits(0 /* 0 */);
   bool _1009 = _1008 < _1005;
   float _1010 = (float)(_1009 ? _1005 : _1007);
   float _1011 = _1006 / _1010;
   int32_t _1012 = _mean_depth_s0_p_v15 + _980;
   ((float *)_mean_depth)[_1012] = _1011;
  } // alloc _sum__2
 } // for _mean_depth_s0_p_v15
 int32_t _1013 = _976 - _970;
 int32_t _1014 = _976 - _969;
 int32_t _1015 = _976 - _967;
 int32_t _1016 = _976 - _966;
 for (int _mean_b_depth_s0_p_v15 = 0; _mean_b_depth_s0_p_v15 < 0 + 32; _mean_b_depth_s0_p_v15++)
 {
  {
   float _sum__3[1];
   // produce sum$3
   float _1017 = float_from_bits(0 /* 0 */);
   _sum__3[0] = _1017;
   int32_t _1018 = _mean_b_depth_s0_p_v15 + _1014;
   int32_t _1019 = _1018 * 289;
   int32_t _1020 = _mean_b_depth_s0_p_v15 + _1015;
   int32_t _1021 = _1020 * 289;
   int32_t _1022 = _mean_b_depth_s0_p_v15 + _1013;
   for (int _sum__3_s1_r49__y = 0; _sum__3_s1_r49__y < 0 + 17; _sum__3_s1_r49__y++)
   {
    int32_t _1023 = _sum__3_s1_r49__y * 17;
    int32_t _1024 = _1019 + _1023;
    int32_t _1025 = _1021 + _1023;
    for (int _sum__3_s1_r49__x = 0; _sum__3_s1_r49__x < 0 + 17; _sum__3_s1_r49__x++)
    {
     float _1026 = _sum__3[0];
     int32_t _1027 = _sum__3_s1_r49__x + _1024;
     uint8_t _1028 = ((uint8_t *)_patched_depth)[_1027];
     float _1029 = (float)(_1028);
     float _1030 = float_from_bits(0 /* 0 */);
     uint8_t _1031 = (uint8_t)(0ull);
     int32_t _1032 = _sum__3_s1_r49__x + _1025;
     uint8_t _1033 = ((uint8_t *)_patched_b_canny)[_1032];
     bool _1034 = _1031 < _1033;
     float _1035 = ((float *)_sum_p_b_canny)[_1022];
     bool _1036 = _1030 < _1035;
     bool _1037 = _1034 && _1036;
     float _1038 = (float)(_1037 ? _1029 : _1030);
     float _1039 = _1026 + _1038;
     _sum__3[0] = _1039;
    } // for _sum__3_s1_r49__x
   } // for _sum__3_s1_r49__y
   // consume sum$3
   int32_t _1040 = _mean_b_depth_s0_p_v15 + _1013;
   float _1041 = ((float *)_sum_p_b_canny)[_1040];
   float _1042 = _sum__3[0];
   float _1043 = float_from_bits(1065353216 /* 1 */);
   float _1044 = float_from_bits(0 /* 0 */);
   bool _1045 = _1044 < _1041;
   float _1046 = (float)(_1045 ? _1041 : _1043);
   float _1047 = _1042 / _1046;
   int32_t _1048 = _mean_b_depth_s0_p_v15 + _1016;
   ((float *)_mean_b_depth)[_1048] = _1047;
  } // alloc _sum__3
 } // for _mean_b_depth_s0_p_v15
 return 0;
}
static HALIDE_FUNCTION_ATTRS
int foreground_mesh_verts_par_for_labeled_s0_p_v14(void *__user_context, int32_t _labeled_s0_p_v14, uint8_t *_closure_arg__3) {
 void * const _ucon = const_cast<void *>(__user_context);
 halide_maybe_unused(_ucon);
 auto *_1049 = (struct halide_buffer_t *)(nullptr);
 struct {
  struct halide_buffer_t * f_0;
  struct halide_buffer_t * f_1;
  struct halide_buffer_t * f_2;
  struct halide_buffer_t * f_3;
  struct halide_buffer_t * f_4;
  struct halide_buffer_t * f_5;
  struct halide_buffer_t * f_6;
  int32_t f_7;
  int32_t f_8;
  int32_t f_9;
  int32_t f_10;
  int32_t f_11;
  int32_t f_12;
  int32_t f_13;
 } s3 = {
  _1049,
  _1049,
  _1049,
  _1049,
  _1049,
  _1049,
  _1049,
  0,
  0,
  0,
  0,
  0,
  0,
  0
 };
 auto *_1050 = (&s3);
 auto _closure_prototype__3 = _1050;
 halide_maybe_unused(_closure_prototype__3);
 auto *_1051 = ((decltype(_closure_prototype__3))_closure_arg__3)->f_0;
 auto _labeled_0_buffer = _1051;
 halide_maybe_unused(_labeled_0_buffer);
 auto *_1052 = ((decltype(_closure_prototype__3))_closure_arg__3)->f_1;
 auto _labeled_1_buffer = _1052;
 halide_maybe_unused(_labeled_1_buffer);
 auto *_1053 = ((decltype(_closure_prototype__3))_closure_arg__3)->f_2;
 auto _mean_b_depth_buffer = _1053;
 halide_maybe_unused(_mean_b_depth_buffer);
 auto *_1054 = ((decltype(_closure_prototype__3))_closure_arg__3)->f_3;
 auto _mean_depth_buffer = _1054;
 halide_maybe_unused(_mean_depth_buffer);
 auto *_1055 = ((decltype(_closure_prototype__3))_closure_arg__3)->f_4;
 auto _patch_coords_buffer = _1055;
 halide_maybe_unused(_patch_coords_buffer);
 auto *_1056 = ((decltype(_closure_prototype__3))_closure_arg__3)->f_5;
 auto _patched_canny_buffer = _1056;
 halide_maybe_unused(_patched_canny_buffer);
 auto *_1057 = ((decltype(_closure_prototype__3))_closure_arg__3)->f_6;
 auto _patched_depth_buffer = _1057;
 halide_maybe_unused(_patched_depth_buffer);
 int32_t _1058 = ((decltype(_closure_prototype__3))_closure_arg__3)->f_7;
 int32_t _1059 = ((decltype(_closure_prototype__3))_closure_arg__3)->f_8;
 int32_t _1060 = ((decltype(_closure_prototype__3))_closure_arg__3)->f_9;
 int32_t _1061 = ((decltype(_closure_prototype__3))_closure_arg__3)->f_10;
 int32_t _1062 = ((decltype(_closure_prototype__3))_closure_arg__3)->f_11;
 int32_t _1063 = ((decltype(_closure_prototype__3))_closure_arg__3)->f_12;
 int32_t _1064 = ((decltype(_closure_prototype__3))_closure_arg__3)->f_13;
 bool _1065 = _labeled_s0_p_v14 < _1060;
 if (_1065)
 {
  halide_buffer_t b2;
  auto *_1066 = &b2;
  uint64_t a0[6];
  auto *_1067 = (struct halide_dimension_t *)(&a0);
  int32_t _1068 = _labeled_s0_p_v14 * 32;
  int32_t _1069 = _1068 + _1058;
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s4 = {
   0,
   0,
   _1069
  };
  auto *_1070 = (int32_t const *)(&s4);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s5 = {
   17,
   17,
   32
  };
  auto *_1071 = (int32_t const *)(&s5);
  auto *_1072 = _halide_buffer_crop(_ucon, _1066, _1067, _labeled_1_buffer, _1070, _1071);
  auto _labeled_1_tmp_buffer = _1072;
  halide_maybe_unused(_labeled_1_tmp_buffer);
  halide_buffer_t b3;
  auto *_1073 = &b3;
  uint64_t a1[6];
  auto *_1074 = (struct halide_dimension_t *)(&a1);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s6 = {
   0,
   0,
   _1069
  };
  auto *_1075 = (int32_t const *)(&s6);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s7 = {
   17,
   17,
   32
  };
  auto *_1076 = (int32_t const *)(&s7);
  auto *_1077 = _halide_buffer_crop(_ucon, _1073, _1074, _labeled_0_buffer, _1075, _1076);
  auto _labeled_0_tmp_buffer = _1077;
  halide_maybe_unused(_labeled_0_tmp_buffer);
  halide_buffer_t b4;
  auto *_1078 = &b4;
  uint64_t a2[6];
  auto *_1079 = (struct halide_dimension_t *)(&a2);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s8 = {
   0,
   0,
   _1059
  };
  auto *_1080 = (int32_t const *)(&s8);
  int32_t _1081 = _1061 + 1;
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s9 = {
   17,
   17,
   _1081
  };
  auto *_1082 = (int32_t const *)(&s9);
  auto *_1083 = _halide_buffer_crop(_ucon, _1078, _1079, _patch_coords_buffer, _1080, _1082);
  auto _patch_coords_0_tmp_buffer = _1083;
  halide_maybe_unused(_patch_coords_0_tmp_buffer);
  halide_buffer_t b5;
  auto *_1084 = &b5;
  uint64_t a3[6];
  auto *_1085 = (struct halide_dimension_t *)(&a3);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s10 = {
   0,
   0,
   _1058
  };
  auto *_1086 = (int32_t const *)(&s10);
  int32_t _1087 = _1064 + 1;
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s11 = {
   17,
   17,
   _1087
  };
  auto *_1088 = (int32_t const *)(&s11);
  auto *_1089 = _halide_buffer_crop(_ucon, _1084, _1085, _patched_depth_buffer, _1086, _1088);
  auto _patched_depth_0_tmp_buffer = _1089;
  halide_maybe_unused(_patched_depth_0_tmp_buffer);
  halide_buffer_t b6;
  auto *_1090 = &b6;
  uint64_t a4[2];
  auto *_1091 = (struct halide_dimension_t *)(&a4);
  struct {
   int32_t f_0;
  } s12 = {
   _1058
  };
  auto *_1092 = (int32_t const *)(&s12);
  struct {
   int32_t f_0;
  } s13 = {
   _1087
  };
  auto *_1093 = (int32_t const *)(&s13);
  auto *_1094 = _halide_buffer_crop(_ucon, _1090, _1091, _mean_b_depth_buffer, _1092, _1093);
  auto _mean_b_depth_0_tmp_buffer = _1094;
  halide_maybe_unused(_mean_b_depth_0_tmp_buffer);
  halide_buffer_t b7;
  auto *_1095 = &b7;
  uint64_t a5[2];
  auto *_1096 = (struct halide_dimension_t *)(&a5);
  struct {
   int32_t f_0;
  } s14 = {
   _1058
  };
  auto *_1097 = (int32_t const *)(&s14);
  struct {
   int32_t f_0;
  } s15 = {
   _1087
  };
  auto *_1098 = (int32_t const *)(&s15);
  auto *_1099 = _halide_buffer_crop(_ucon, _1095, _1096, _mean_depth_buffer, _1097, _1098);
  auto _mean_depth_0_tmp_buffer = _1099;
  halide_maybe_unused(_mean_depth_0_tmp_buffer);
  halide_buffer_t b8;
  auto *_1100 = &b8;
  uint64_t a6[6];
  auto *_1101 = (struct halide_dimension_t *)(&a6);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s16 = {
   0,
   0,
   _1059
  };
  auto *_1102 = (int32_t const *)(&s16);
  int32_t _1103 = _1062 + 1;
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s17 = {
   17,
   17,
   _1103
  };
  auto *_1104 = (int32_t const *)(&s17);
  auto *_1105 = _halide_buffer_crop(_ucon, _1100, _1101, _patched_canny_buffer, _1102, _1104);
  auto _patched_canny_0_tmp_buffer = _1105;
  halide_maybe_unused(_patched_canny_0_tmp_buffer);
  uint64_t _1106 = (uint64_t)(_patched_canny_0_tmp_buffer);
  uint64_t _1107 = (uint64_t)(0ull);
  bool _1108 = _1106 != _1107;
  if (!_1108)
  {
   int32_t _1109 = halide_error_device_crop_failed(_ucon);
   return _1109;
  }
  uint64_t _1110 = (uint64_t)(_mean_depth_0_tmp_buffer);
  uint64_t _1111 = (uint64_t)(0ull);
  bool _1112 = _1110 != _1111;
  if (!_1112)
  {
   int32_t _1113 = halide_error_device_crop_failed(_ucon);
   return _1113;
  }
  uint64_t _1114 = (uint64_t)(_mean_b_depth_0_tmp_buffer);
  uint64_t _1115 = (uint64_t)(0ull);
  bool _1116 = _1114 != _1115;
  if (!_1116)
  {
   int32_t _1117 = halide_error_device_crop_failed(_ucon);
   return _1117;
  }
  uint64_t _1118 = (uint64_t)(_patched_depth_0_tmp_buffer);
  uint64_t _1119 = (uint64_t)(0ull);
  bool _1120 = _1118 != _1119;
  if (!_1120)
  {
   int32_t _1121 = halide_error_device_crop_failed(_ucon);
   return _1121;
  }
  uint64_t _1122 = (uint64_t)(_patch_coords_0_tmp_buffer);
  uint64_t _1123 = (uint64_t)(0ull);
  bool _1124 = _1122 != _1123;
  if (!_1124)
  {
   int32_t _1125 = halide_error_device_crop_failed(_ucon);
   return _1125;
  }
  uint64_t _1126 = (uint64_t)(_labeled_0_tmp_buffer);
  uint64_t _1127 = (uint64_t)(0ull);
  bool _1128 = _1126 != _1127;
  if (!_1128)
  {
   int32_t _1129 = halide_error_device_crop_failed(_ucon);
   return _1129;
  }
  uint64_t _1130 = (uint64_t)(_labeled_1_tmp_buffer);
  uint64_t _1131 = (uint64_t)(0ull);
  bool _1132 = _1130 != _1131;
  if (!_1132)
  {
   int32_t _1133 = halide_error_device_crop_failed(_ucon);
   return _1133;
  }
  int32_t _1134 = search_quadtree(_patched_canny_0_tmp_buffer, _mean_depth_0_tmp_buffer, _mean_b_depth_0_tmp_buffer, _patched_depth_0_tmp_buffer, _patch_coords_0_tmp_buffer, 16, _labeled_0_tmp_buffer, _labeled_1_tmp_buffer);
  auto *_1135 = (struct halide_buffer_t *)(nullptr);
  struct {
   struct halide_buffer_t * f_0;
   struct halide_buffer_t * f_1;
   struct halide_buffer_t * f_2;
   struct halide_buffer_t * f_3;
   struct halide_buffer_t * f_4;
   struct halide_buffer_t * f_5;
   struct halide_buffer_t * f_6;
   struct halide_buffer_t * f_7;
   struct halide_buffer_t * f_8;
   struct halide_buffer_t * f_9;
   struct halide_buffer_t * f_10;
   struct halide_buffer_t * f_11;
   struct halide_buffer_t * f_12;
   struct halide_buffer_t * f_13;
   struct halide_buffer_t * f_14;
  } s18 = {
   _patched_canny_0_tmp_buffer,
   _patched_canny_buffer,
   _mean_depth_0_tmp_buffer,
   _mean_depth_buffer,
   _mean_b_depth_0_tmp_buffer,
   _mean_b_depth_buffer,
   _patched_depth_0_tmp_buffer,
   _patched_depth_buffer,
   _patch_coords_0_tmp_buffer,
   _patch_coords_buffer,
   _labeled_0_tmp_buffer,
   _labeled_0_buffer,
   _labeled_1_tmp_buffer,
   _labeled_1_buffer,
   _1135
  };
  auto *_1136 = (&s18);
  int32_t _1137 = _halide_buffer_retire_crops_after_extern_stage(_ucon, _1136);
  halide_maybe_unused(_1137);
  bool _1138 = _1134 == 0;
  if (!_1138)
  {
   int32_t _1139 = halide_error_extern_stage_failed(_ucon, "search_quadtree", _1134);
   return _1139;
  }
 } // if _1065
 else
 {
  halide_buffer_t b9;
  auto *_1140 = &b9;
  uint64_t a7[6];
  auto *_1141 = (struct halide_dimension_t *)(&a7);
  int32_t _1142 = _1063 + -31;
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s19 = {
   0,
   0,
   _1142
  };
  auto *_1143 = (int32_t const *)(&s19);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s20 = {
   17,
   17,
   32
  };
  auto *_1144 = (int32_t const *)(&s20);
  auto *_1145 = _halide_buffer_crop(_ucon, _1140, _1141, _labeled_1_buffer, _1143, _1144);
  auto _labeled_1_tmp_buffer = _1145;
  halide_maybe_unused(_labeled_1_tmp_buffer);
  halide_buffer_t b10;
  auto *_1146 = &b10;
  uint64_t a8[6];
  auto *_1147 = (struct halide_dimension_t *)(&a8);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s21 = {
   0,
   0,
   _1142
  };
  auto *_1148 = (int32_t const *)(&s21);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s22 = {
   17,
   17,
   32
  };
  auto *_1149 = (int32_t const *)(&s22);
  auto *_1150 = _halide_buffer_crop(_ucon, _1146, _1147, _labeled_0_buffer, _1148, _1149);
  auto _labeled_0_tmp_buffer = _1150;
  halide_maybe_unused(_labeled_0_tmp_buffer);
  halide_buffer_t b11;
  auto *_1151 = &b11;
  uint64_t a9[6];
  auto *_1152 = (struct halide_dimension_t *)(&a9);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s23 = {
   0,
   0,
   _1059
  };
  auto *_1153 = (int32_t const *)(&s23);
  int32_t _1154 = _1061 + 1;
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s24 = {
   17,
   17,
   _1154
  };
  auto *_1155 = (int32_t const *)(&s24);
  auto *_1156 = _halide_buffer_crop(_ucon, _1151, _1152, _patch_coords_buffer, _1153, _1155);
  auto _patch_coords_0_tmp_buffer = _1156;
  halide_maybe_unused(_patch_coords_0_tmp_buffer);
  halide_buffer_t b12;
  auto *_1157 = &b12;
  uint64_t a10[6];
  auto *_1158 = (struct halide_dimension_t *)(&a10);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s25 = {
   0,
   0,
   _1058
  };
  auto *_1159 = (int32_t const *)(&s25);
  int32_t _1160 = _1064 + 1;
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s26 = {
   17,
   17,
   _1160
  };
  auto *_1161 = (int32_t const *)(&s26);
  auto *_1162 = _halide_buffer_crop(_ucon, _1157, _1158, _patched_depth_buffer, _1159, _1161);
  auto _patched_depth_0_tmp_buffer = _1162;
  halide_maybe_unused(_patched_depth_0_tmp_buffer);
  halide_buffer_t b13;
  auto *_1163 = &b13;
  uint64_t a11[2];
  auto *_1164 = (struct halide_dimension_t *)(&a11);
  struct {
   int32_t f_0;
  } s27 = {
   _1058
  };
  auto *_1165 = (int32_t const *)(&s27);
  struct {
   int32_t f_0;
  } s28 = {
   _1160
  };
  auto *_1166 = (int32_t const *)(&s28);
  auto *_1167 = _halide_buffer_crop(_ucon, _1163, _1164, _mean_b_depth_buffer, _1165, _1166);
  auto _mean_b_depth_0_tmp_buffer = _1167;
  halide_maybe_unused(_mean_b_depth_0_tmp_buffer);
  halide_buffer_t b14;
  auto *_1168 = &b14;
  uint64_t a12[2];
  auto *_1169 = (struct halide_dimension_t *)(&a12);
  struct {
   int32_t f_0;
  } s29 = {
   _1058
  };
  auto *_1170 = (int32_t const *)(&s29);
  struct {
   int32_t f_0;
  } s30 = {
   _1160
  };
  auto *_1171 = (int32_t const *)(&s30);
  auto *_1172 = _halide_buffer_crop(_ucon, _1168, _1169, _mean_depth_buffer, _1170, _1171);
  auto _mean_depth_0_tmp_buffer = _1172;
  halide_maybe_unused(_mean_depth_0_tmp_buffer);
  halide_buffer_t b15;
  auto *_1173 = &b15;
  uint64_t a13[6];
  auto *_1174 = (struct halide_dimension_t *)(&a13);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s31 = {
   0,
   0,
   _1059
  };
  auto *_1175 = (int32_t const *)(&s31);
  int32_t _1176 = _1062 + 1;
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s32 = {
   17,
   17,
   _1176
  };
  auto *_1177 = (int32_t const *)(&s32);
  auto *_1178 = _halide_buffer_crop(_ucon, _1173, _1174, _patched_canny_buffer, _1175, _1177);
  auto _patched_canny_0_tmp_buffer = _1178;
  halide_maybe_unused(_patched_canny_0_tmp_buffer);
  uint64_t _1179 = (uint64_t)(_patched_canny_0_tmp_buffer);
  uint64_t _1180 = (uint64_t)(0ull);
  bool _1181 = _1179 != _1180;
  if (!_1181)
  {
   int32_t _1182 = halide_error_device_crop_failed(_ucon);
   return _1182;
  }
  uint64_t _1183 = (uint64_t)(_mean_depth_0_tmp_buffer);
  uint64_t _1184 = (uint64_t)(0ull);
  bool _1185 = _1183 != _1184;
  if (!_1185)
  {
   int32_t _1186 = halide_error_device_crop_failed(_ucon);
   return _1186;
  }
  uint64_t _1187 = (uint64_t)(_mean_b_depth_0_tmp_buffer);
  uint64_t _1188 = (uint64_t)(0ull);
  bool _1189 = _1187 != _1188;
  if (!_1189)
  {
   int32_t _1190 = halide_error_device_crop_failed(_ucon);
   return _1190;
  }
  uint64_t _1191 = (uint64_t)(_patched_depth_0_tmp_buffer);
  uint64_t _1192 = (uint64_t)(0ull);
  bool _1193 = _1191 != _1192;
  if (!_1193)
  {
   int32_t _1194 = halide_error_device_crop_failed(_ucon);
   return _1194;
  }
  uint64_t _1195 = (uint64_t)(_patch_coords_0_tmp_buffer);
  uint64_t _1196 = (uint64_t)(0ull);
  bool _1197 = _1195 != _1196;
  if (!_1197)
  {
   int32_t _1198 = halide_error_device_crop_failed(_ucon);
   return _1198;
  }
  uint64_t _1199 = (uint64_t)(_labeled_0_tmp_buffer);
  uint64_t _1200 = (uint64_t)(0ull);
  bool _1201 = _1199 != _1200;
  if (!_1201)
  {
   int32_t _1202 = halide_error_device_crop_failed(_ucon);
   return _1202;
  }
  uint64_t _1203 = (uint64_t)(_labeled_1_tmp_buffer);
  uint64_t _1204 = (uint64_t)(0ull);
  bool _1205 = _1203 != _1204;
  if (!_1205)
  {
   int32_t _1206 = halide_error_device_crop_failed(_ucon);
   return _1206;
  }
  int32_t _1207 = search_quadtree(_patched_canny_0_tmp_buffer, _mean_depth_0_tmp_buffer, _mean_b_depth_0_tmp_buffer, _patched_depth_0_tmp_buffer, _patch_coords_0_tmp_buffer, 16, _labeled_0_tmp_buffer, _labeled_1_tmp_buffer);
  auto *_1208 = (struct halide_buffer_t *)(nullptr);
  struct {
   struct halide_buffer_t * f_0;
   struct halide_buffer_t * f_1;
   struct halide_buffer_t * f_2;
   struct halide_buffer_t * f_3;
   struct halide_buffer_t * f_4;
   struct halide_buffer_t * f_5;
   struct halide_buffer_t * f_6;
   struct halide_buffer_t * f_7;
   struct halide_buffer_t * f_8;
   struct halide_buffer_t * f_9;
   struct halide_buffer_t * f_10;
   struct halide_buffer_t * f_11;
   struct halide_buffer_t * f_12;
   struct halide_buffer_t * f_13;
   struct halide_buffer_t * f_14;
  } s33 = {
   _patched_canny_0_tmp_buffer,
   _patched_canny_buffer,
   _mean_depth_0_tmp_buffer,
   _mean_depth_buffer,
   _mean_b_depth_0_tmp_buffer,
   _mean_b_depth_buffer,
   _patched_depth_0_tmp_buffer,
   _patched_depth_buffer,
   _patch_coords_0_tmp_buffer,
   _patch_coords_buffer,
   _labeled_0_tmp_buffer,
   _labeled_0_buffer,
   _labeled_1_tmp_buffer,
   _labeled_1_buffer,
   _1208
  };
  auto *_1209 = (&s33);
  int32_t _1210 = _halide_buffer_retire_crops_after_extern_stage(_ucon, _1209);
  halide_maybe_unused(_1210);
  bool _1211 = _1207 == 0;
  if (!_1211)
  {
   int32_t _1212 = halide_error_extern_stage_failed(_ucon, "search_quadtree", _1207);
   return _1212;
  }
 } // if _1065 else
 return 0;
}
static HALIDE_FUNCTION_ATTRS
int foreground_mesh_verts_par_for_patch_init_faces_s0_p_v14(void *__user_context, int32_t _patch_init_faces_s0_p_v14, uint8_t *_closure_arg__4) {
 void * const _ucon = const_cast<void *>(__user_context);
 halide_maybe_unused(_ucon);
 auto *_1213 = (void *)(nullptr);
 struct {
  void * f_0;
  int32_t f_1;
  int32_t f_2;
  int32_t f_3;
 } s34 = {
  _1213,
  0,
  0,
  0
 };
 auto *_1214 = (&s34);
 auto _closure_prototype__4 = _1214;
 halide_maybe_unused(_closure_prototype__4);
 auto *_1215 = ((decltype(_closure_prototype__4))_closure_arg__4)->f_0;
 auto _patch_init_faces = _1215;
 halide_maybe_unused(_patch_init_faces);
 int32_t _1216 = ((decltype(_closure_prototype__4))_closure_arg__4)->f_1;
 int32_t _1217 = ((decltype(_closure_prototype__4))_closure_arg__4)->f_2;
 int32_t _1218 = ((decltype(_closure_prototype__4))_closure_arg__4)->f_3;
 int32_t _1219 = _patch_init_faces_s0_p_v14 * 32;
 int32_t _1220 = _1219 + _1217;
 int32_t _1221 = _1216 + -32;
 int32_t _1222 = ::halide_cpp_min(_1220, _1221);
 int32_t _1223 = _1222 - _1218;
 for (int _patch_init_faces_s0_p_v15 = 0; _patch_init_faces_s0_p_v15 < 0 + 32; _patch_init_faces_s0_p_v15++)
 {
  int32_t _1224 = _patch_init_faces_s0_p_v15 + _1223;
  int32_t _1225 = _1224 * 2316;
  for (int _patch_init_faces_s0_f = 0; _patch_init_faces_s0_f < 0 + 579; _patch_init_faces_s0_f++)
  {
   int32_t _1226 = _patch_init_faces_s0_f * 4;
   int32_t _1227 = _1226 + _1225;
   for (int _patch_init_faces_s0_c = 0; _patch_init_faces_s0_c < 0 + 4; _patch_init_faces_s0_c++)
   {
    int32_t _1228 = _patch_init_faces_s0_c + _1227;
    ((int32_t *)_patch_init_faces)[_1228] = -1;
   } // for _patch_init_faces_s0_c
  } // for _patch_init_faces_s0_f
 } // for _patch_init_faces_s0_p_v15
 return 0;
}
static HALIDE_FUNCTION_ATTRS
int foreground_mesh_verts_par_for_patch_faces_s0_p_v14(void *__user_context, int32_t _patch_faces_s0_p_v14, uint8_t *_closure_arg__5) {
 void * const _ucon = const_cast<void *>(__user_context);
 halide_maybe_unused(_ucon);
 auto *_1229 = (struct halide_buffer_t *)(nullptr);
 struct {
  struct halide_buffer_t * f_0;
  struct halide_buffer_t * f_1;
  struct halide_buffer_t * f_2;
  struct halide_buffer_t * f_3;
  struct halide_buffer_t * f_4;
  int32_t f_5;
  int32_t f_6;
  int32_t f_7;
  int32_t f_8;
  int32_t f_9;
  int32_t f_10;
  int32_t f_11;
  int32_t f_12;
  int32_t f_13;
  int32_t f_14;
  int32_t f_15;
 } s35 = {
  _1229,
  _1229,
  _1229,
  _1229,
  _1229,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
 };
 auto *_1230 = (&s35);
 auto _closure_prototype__5 = _1230;
 halide_maybe_unused(_closure_prototype__5);
 auto *_1231 = ((decltype(_closure_prototype__5))_closure_arg__5)->f_0;
 auto _out_labeled_buffer = _1231;
 halide_maybe_unused(_out_labeled_buffer);
 auto *_1232 = ((decltype(_closure_prototype__5))_closure_arg__5)->f_1;
 auto _patch_coords_buffer = _1232;
 halide_maybe_unused(_patch_coords_buffer);
 auto *_1233 = ((decltype(_closure_prototype__5))_closure_arg__5)->f_2;
 auto _patch_faces_buffer = _1233;
 halide_maybe_unused(_patch_faces_buffer);
 auto *_1234 = ((decltype(_closure_prototype__5))_closure_arg__5)->f_3;
 auto _patch_init_faces_buffer = _1234;
 halide_maybe_unused(_patch_init_faces_buffer);
 auto *_1235 = ((decltype(_closure_prototype__5))_closure_arg__5)->f_4;
 auto _patched_canny_buffer = _1235;
 halide_maybe_unused(_patched_canny_buffer);
 int32_t _1236 = ((decltype(_closure_prototype__5))_closure_arg__5)->f_5;
 int32_t _1237 = ((decltype(_closure_prototype__5))_closure_arg__5)->f_6;
 int32_t _1238 = ((decltype(_closure_prototype__5))_closure_arg__5)->f_7;
 int32_t _1239 = ((decltype(_closure_prototype__5))_closure_arg__5)->f_8;
 int32_t _1240 = ((decltype(_closure_prototype__5))_closure_arg__5)->f_9;
 int32_t _1241 = ((decltype(_closure_prototype__5))_closure_arg__5)->f_10;
 int32_t _1242 = ((decltype(_closure_prototype__5))_closure_arg__5)->f_11;
 int32_t _1243 = ((decltype(_closure_prototype__5))_closure_arg__5)->f_12;
 int32_t _1244 = ((decltype(_closure_prototype__5))_closure_arg__5)->f_13;
 int32_t _1245 = ((decltype(_closure_prototype__5))_closure_arg__5)->f_14;
 int32_t _1246 = ((decltype(_closure_prototype__5))_closure_arg__5)->f_15;
 bool _1247 = _patch_faces_s0_p_v14 < _1241;
 if (_1247)
 {
  halide_buffer_t b16;
  auto *_1248 = &b16;
  uint64_t a14[6];
  auto *_1249 = (struct halide_dimension_t *)(&a14);
  int32_t _1250 = _patch_faces_s0_p_v14 * 32;
  int32_t _1251 = _1250 + _1239;
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s36 = {
   _1242,
   _1243,
   _1251
  };
  auto *_1252 = (int32_t const *)(&s36);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s37 = {
   _1236,
   _1237,
   32
  };
  auto *_1253 = (int32_t const *)(&s37);
  auto *_1254 = _halide_buffer_crop(_ucon, _1248, _1249, _patch_faces_buffer, _1252, _1253);
  auto _patch_faces_0_tmp_buffer = _1254;
  halide_maybe_unused(_patch_faces_0_tmp_buffer);
  halide_buffer_t b17;
  auto *_1255 = &b17;
  uint64_t a15[6];
  auto *_1256 = (struct halide_dimension_t *)(&a15);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s38 = {
   0,
   0,
   _1239
  };
  auto *_1257 = (int32_t const *)(&s38);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s39 = {
   4,
   579,
   _1246
  };
  auto *_1258 = (int32_t const *)(&s39);
  auto *_1259 = _halide_buffer_crop(_ucon, _1255, _1256, _patch_init_faces_buffer, _1257, _1258);
  auto _patch_init_faces_0_tmp_buffer = _1259;
  halide_maybe_unused(_patch_init_faces_0_tmp_buffer);
  halide_buffer_t b18;
  auto *_1260 = &b18;
  uint64_t a16[6];
  auto *_1261 = (struct halide_dimension_t *)(&a16);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s40 = {
   0,
   0,
   _1239
  };
  auto *_1262 = (int32_t const *)(&s40);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s41 = {
   17,
   17,
   _1246
  };
  auto *_1263 = (int32_t const *)(&s41);
  auto *_1264 = _halide_buffer_crop(_ucon, _1260, _1261, _out_labeled_buffer, _1262, _1263);
  auto _out_labeled_0_tmp_buffer = _1264;
  halide_maybe_unused(_out_labeled_0_tmp_buffer);
  halide_buffer_t b19;
  auto *_1265 = &b19;
  uint64_t a17[6];
  auto *_1266 = (struct halide_dimension_t *)(&a17);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s42 = {
   0,
   0,
   _1240
  };
  auto *_1267 = (int32_t const *)(&s42);
  int32_t _1268 = _1244 + 1;
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s43 = {
   17,
   17,
   _1268
  };
  auto *_1269 = (int32_t const *)(&s43);
  auto *_1270 = _halide_buffer_crop(_ucon, _1265, _1266, _patch_coords_buffer, _1267, _1269);
  auto _patch_coords_0_tmp_buffer = _1270;
  halide_maybe_unused(_patch_coords_0_tmp_buffer);
  halide_buffer_t b20;
  auto *_1271 = &b20;
  uint64_t a18[6];
  auto *_1272 = (struct halide_dimension_t *)(&a18);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s44 = {
   0,
   0,
   _1240
  };
  auto *_1273 = (int32_t const *)(&s44);
  int32_t _1274 = _1245 + 1;
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s45 = {
   17,
   17,
   _1274
  };
  auto *_1275 = (int32_t const *)(&s45);
  auto *_1276 = _halide_buffer_crop(_ucon, _1271, _1272, _patched_canny_buffer, _1273, _1275);
  auto _patched_canny_0_tmp_buffer = _1276;
  halide_maybe_unused(_patched_canny_0_tmp_buffer);
  uint64_t _1277 = (uint64_t)(_patched_canny_0_tmp_buffer);
  uint64_t _1278 = (uint64_t)(0ull);
  bool _1279 = _1277 != _1278;
  if (!_1279)
  {
   int32_t _1280 = halide_error_device_crop_failed(_ucon);
   return _1280;
  }
  uint64_t _1281 = (uint64_t)(_patch_coords_0_tmp_buffer);
  uint64_t _1282 = (uint64_t)(0ull);
  bool _1283 = _1281 != _1282;
  if (!_1283)
  {
   int32_t _1284 = halide_error_device_crop_failed(_ucon);
   return _1284;
  }
  uint64_t _1285 = (uint64_t)(_out_labeled_0_tmp_buffer);
  uint64_t _1286 = (uint64_t)(0ull);
  bool _1287 = _1285 != _1286;
  if (!_1287)
  {
   int32_t _1288 = halide_error_device_crop_failed(_ucon);
   return _1288;
  }
  uint64_t _1289 = (uint64_t)(_patch_init_faces_0_tmp_buffer);
  uint64_t _1290 = (uint64_t)(0ull);
  bool _1291 = _1289 != _1290;
  if (!_1291)
  {
   int32_t _1292 = halide_error_device_crop_failed(_ucon);
   return _1292;
  }
  uint64_t _1293 = (uint64_t)(_patch_faces_0_tmp_buffer);
  uint64_t _1294 = (uint64_t)(0ull);
  bool _1295 = _1293 != _1294;
  if (!_1295)
  {
   int32_t _1296 = halide_error_device_crop_failed(_ucon);
   return _1296;
  }
  int32_t _1297 = search_quadtree_faces(_patched_canny_0_tmp_buffer, _patch_coords_0_tmp_buffer, _out_labeled_0_tmp_buffer, _patch_init_faces_0_tmp_buffer, 16, _patch_faces_0_tmp_buffer);
  auto *_1298 = (struct halide_buffer_t *)(nullptr);
  struct {
   struct halide_buffer_t * f_0;
   struct halide_buffer_t * f_1;
   struct halide_buffer_t * f_2;
   struct halide_buffer_t * f_3;
   struct halide_buffer_t * f_4;
   struct halide_buffer_t * f_5;
   struct halide_buffer_t * f_6;
   struct halide_buffer_t * f_7;
   struct halide_buffer_t * f_8;
   struct halide_buffer_t * f_9;
   struct halide_buffer_t * f_10;
  } s46 = {
   _patched_canny_0_tmp_buffer,
   _patched_canny_buffer,
   _patch_coords_0_tmp_buffer,
   _patch_coords_buffer,
   _out_labeled_0_tmp_buffer,
   _out_labeled_buffer,
   _patch_init_faces_0_tmp_buffer,
   _patch_init_faces_buffer,
   _patch_faces_0_tmp_buffer,
   _patch_faces_buffer,
   _1298
  };
  auto *_1299 = (&s46);
  int32_t _1300 = _halide_buffer_retire_crops_after_extern_stage(_ucon, _1299);
  halide_maybe_unused(_1300);
  bool _1301 = _1297 == 0;
  if (!_1301)
  {
   int32_t _1302 = halide_error_extern_stage_failed(_ucon, "search_quadtree_faces", _1297);
   return _1302;
  }
 } // if _1247
 else
 {
  halide_buffer_t b21;
  auto *_1303 = &b21;
  uint64_t a19[6];
  auto *_1304 = (struct halide_dimension_t *)(&a19);
  int32_t _1305 = _1238 + -32;
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s47 = {
   _1242,
   _1243,
   _1305
  };
  auto *_1306 = (int32_t const *)(&s47);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s48 = {
   _1236,
   _1237,
   32
  };
  auto *_1307 = (int32_t const *)(&s48);
  auto *_1308 = _halide_buffer_crop(_ucon, _1303, _1304, _patch_faces_buffer, _1306, _1307);
  auto _patch_faces_0_tmp_buffer = _1308;
  halide_maybe_unused(_patch_faces_0_tmp_buffer);
  halide_buffer_t b22;
  auto *_1309 = &b22;
  uint64_t a20[6];
  auto *_1310 = (struct halide_dimension_t *)(&a20);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s49 = {
   0,
   0,
   _1239
  };
  auto *_1311 = (int32_t const *)(&s49);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s50 = {
   4,
   579,
   _1246
  };
  auto *_1312 = (int32_t const *)(&s50);
  auto *_1313 = _halide_buffer_crop(_ucon, _1309, _1310, _patch_init_faces_buffer, _1311, _1312);
  auto _patch_init_faces_0_tmp_buffer = _1313;
  halide_maybe_unused(_patch_init_faces_0_tmp_buffer);
  halide_buffer_t b23;
  auto *_1314 = &b23;
  uint64_t a21[6];
  auto *_1315 = (struct halide_dimension_t *)(&a21);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s51 = {
   0,
   0,
   _1239
  };
  auto *_1316 = (int32_t const *)(&s51);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s52 = {
   17,
   17,
   _1246
  };
  auto *_1317 = (int32_t const *)(&s52);
  auto *_1318 = _halide_buffer_crop(_ucon, _1314, _1315, _out_labeled_buffer, _1316, _1317);
  auto _out_labeled_0_tmp_buffer = _1318;
  halide_maybe_unused(_out_labeled_0_tmp_buffer);
  halide_buffer_t b24;
  auto *_1319 = &b24;
  uint64_t a22[6];
  auto *_1320 = (struct halide_dimension_t *)(&a22);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s53 = {
   0,
   0,
   _1240
  };
  auto *_1321 = (int32_t const *)(&s53);
  int32_t _1322 = _1244 + 1;
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s54 = {
   17,
   17,
   _1322
  };
  auto *_1323 = (int32_t const *)(&s54);
  auto *_1324 = _halide_buffer_crop(_ucon, _1319, _1320, _patch_coords_buffer, _1321, _1323);
  auto _patch_coords_0_tmp_buffer = _1324;
  halide_maybe_unused(_patch_coords_0_tmp_buffer);
  halide_buffer_t b25;
  auto *_1325 = &b25;
  uint64_t a23[6];
  auto *_1326 = (struct halide_dimension_t *)(&a23);
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s55 = {
   0,
   0,
   _1240
  };
  auto *_1327 = (int32_t const *)(&s55);
  int32_t _1328 = _1245 + 1;
  struct {
   int32_t f_0;
   int32_t f_1;
   int32_t f_2;
  } s56 = {
   17,
   17,
   _1328
  };
  auto *_1329 = (int32_t const *)(&s56);
  auto *_1330 = _halide_buffer_crop(_ucon, _1325, _1326, _patched_canny_buffer, _1327, _1329);
  auto _patched_canny_0_tmp_buffer = _1330;
  halide_maybe_unused(_patched_canny_0_tmp_buffer);
  uint64_t _1331 = (uint64_t)(_patched_canny_0_tmp_buffer);
  uint64_t _1332 = (uint64_t)(0ull);
  bool _1333 = _1331 != _1332;
  if (!_1333)
  {
   int32_t _1334 = halide_error_device_crop_failed(_ucon);
   return _1334;
  }
  uint64_t _1335 = (uint64_t)(_patch_coords_0_tmp_buffer);
  uint64_t _1336 = (uint64_t)(0ull);
  bool _1337 = _1335 != _1336;
  if (!_1337)
  {
   int32_t _1338 = halide_error_device_crop_failed(_ucon);
   return _1338;
  }
  uint64_t _1339 = (uint64_t)(_out_labeled_0_tmp_buffer);
  uint64_t _1340 = (uint64_t)(0ull);
  bool _1341 = _1339 != _1340;
  if (!_1341)
  {
   int32_t _1342 = halide_error_device_crop_failed(_ucon);
   return _1342;
  }
  uint64_t _1343 = (uint64_t)(_patch_init_faces_0_tmp_buffer);
  uint64_t _1344 = (uint64_t)(0ull);
  bool _1345 = _1343 != _1344;
  if (!_1345)
  {
   int32_t _1346 = halide_error_device_crop_failed(_ucon);
   return _1346;
  }
  uint64_t _1347 = (uint64_t)(_patch_faces_0_tmp_buffer);
  uint64_t _1348 = (uint64_t)(0ull);
  bool _1349 = _1347 != _1348;
  if (!_1349)
  {
   int32_t _1350 = halide_error_device_crop_failed(_ucon);
   return _1350;
  }
  int32_t _1351 = search_quadtree_faces(_patched_canny_0_tmp_buffer, _patch_coords_0_tmp_buffer, _out_labeled_0_tmp_buffer, _patch_init_faces_0_tmp_buffer, 16, _patch_faces_0_tmp_buffer);
  auto *_1352 = (struct halide_buffer_t *)(nullptr);
  struct {
   struct halide_buffer_t * f_0;
   struct halide_buffer_t * f_1;
   struct halide_buffer_t * f_2;
   struct halide_buffer_t * f_3;
   struct halide_buffer_t * f_4;
   struct halide_buffer_t * f_5;
   struct halide_buffer_t * f_6;
   struct halide_buffer_t * f_7;
   struct halide_buffer_t * f_8;
   struct halide_buffer_t * f_9;
   struct halide_buffer_t * f_10;
  } s57 = {
   _patched_canny_0_tmp_buffer,
   _patched_canny_buffer,
   _patch_coords_0_tmp_buffer,
   _patch_coords_buffer,
   _out_labeled_0_tmp_buffer,
   _out_labeled_buffer,
   _patch_init_faces_0_tmp_buffer,
   _patch_init_faces_buffer,
   _patch_faces_0_tmp_buffer,
   _patch_faces_buffer,
   _1352
  };
  auto *_1353 = (&s57);
  int32_t _1354 = _halide_buffer_retire_crops_after_extern_stage(_ucon, _1353);
  halide_maybe_unused(_1354);
  bool _1355 = _1351 == 0;
  if (!_1355)
  {
   int32_t _1356 = halide_error_extern_stage_failed(_ucon, "search_quadtree_faces", _1351);
   return _1356;
  }
 } // if _1247 else
 return 0;
}
static HALIDE_FUNCTION_ATTRS
int foreground_mesh_verts_par_for_P_fore_faces_s0_p_v14(void *__user_context, int32_t _P_fore_faces_s0_p_v14, uint8_t *_closure_arg__6) {
 void * const _ucon = const_cast<void *>(__user_context);
 halide_maybe_unused(_ucon);
 auto *_1357 = (void *)(nullptr);
 struct {
  void * f_0;
  void * f_1;
  int32_t f_2;
  int32_t f_3;
  int32_t f_4;
  int32_t f_5;
  int32_t f_6;
  int32_t f_7;
  int32_t f_8;
  int32_t f_9;
  int32_t f_10;
  int32_t f_11;
  int32_t f_12;
  int32_t f_13;
  int32_t f_14;
 } s58 = {
  _1357,
  _1357,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
 };
 auto *_1358 = (&s58);
 auto _closure_prototype__6 = _1358;
 halide_maybe_unused(_closure_prototype__6);
 auto *_1359 = ((decltype(_closure_prototype__6))_closure_arg__6)->f_0;
 auto _P_fore_faces = _1359;
 halide_maybe_unused(_P_fore_faces);
 auto *_1360 = ((decltype(_closure_prototype__6))_closure_arg__6)->f_1;
 auto _patch_faces = _1360;
 halide_maybe_unused(_patch_faces);
 int32_t _1361 = ((decltype(_closure_prototype__6))_closure_arg__6)->f_2;
 int32_t _1362 = ((decltype(_closure_prototype__6))_closure_arg__6)->f_3;
 int32_t _1363 = ((decltype(_closure_prototype__6))_closure_arg__6)->f_4;
 int32_t _1364 = ((decltype(_closure_prototype__6))_closure_arg__6)->f_5;
 int32_t _1365 = ((decltype(_closure_prototype__6))_closure_arg__6)->f_6;
 int32_t _1366 = ((decltype(_closure_prototype__6))_closure_arg__6)->f_7;
 int32_t _1367 = ((decltype(_closure_prototype__6))_closure_arg__6)->f_8;
 int32_t _1368 = ((decltype(_closure_prototype__6))_closure_arg__6)->f_9;
 int32_t _1369 = ((decltype(_closure_prototype__6))_closure_arg__6)->f_10;
 int32_t _1370 = ((decltype(_closure_prototype__6))_closure_arg__6)->f_11;
 int32_t _1371 = ((decltype(_closure_prototype__6))_closure_arg__6)->f_12;
 int32_t _1372 = ((decltype(_closure_prototype__6))_closure_arg__6)->f_13;
 int32_t _1373 = ((decltype(_closure_prototype__6))_closure_arg__6)->f_14;
 int32_t _1374 = _P_fore_faces_s0_p_v14 * 32;
 int32_t _1375 = _1363 + -32;
 int32_t _1376 = ::halide_cpp_min(_1374, _1375);
 int32_t _1377 = _1376 + _1371;
 int32_t _1378 = _1365 + _1376;
 for (int _P_fore_faces_s0_p_v15 = 0; _P_fore_faces_s0_p_v15 < 0 + 32; _P_fore_faces_s0_p_v15++)
 {
  int32_t _1379 = _P_fore_faces_s0_p_v15 + _1378;
  int32_t _1380 = _1379 * _1367;
  int32_t _1381 = _1380 + _1373;
  int32_t _1382 = _P_fore_faces_s0_p_v15 + _1377;
  int32_t _1383 = _1382 * _1370;
  int32_t _1384 = _1383 + _1369;
  for (int _P_fore_faces_s0_f_rebased = 0; _P_fore_faces_s0_f_rebased < 0 + _1362; _P_fore_faces_s0_f_rebased++)
  {
   int32_t _1385 = _P_fore_faces_s0_f_rebased + _1372;
   int32_t _1386 = _1385 * _1368;
   int32_t _1387 = _1386 + _1384;
   int32_t _1388 = _1364 + _P_fore_faces_s0_f_rebased;
   int32_t _1389 = _1388 * _1366;
   int32_t _1390 = _1389 + _1381;
   for (int _P_fore_faces_s0_c_rebased = 0; _P_fore_faces_s0_c_rebased < 0 + _1361; _P_fore_faces_s0_c_rebased++)
   {
    int32_t _1391 = _P_fore_faces_s0_c_rebased + _1387;
    int32_t _1392 = ((int32_t *)_patch_faces)[_1391];
    int32_t _1393 = _P_fore_faces_s0_c_rebased + _1390;
    ((int32_t *)_P_fore_faces)[_1393] = _1392;
   } // for _P_fore_faces_s0_c_rebased
  } // for _P_fore_faces_s0_f_rebased
 } // for _P_fore_faces_s0_p_v15
 return 0;
}
static HALIDE_FUNCTION_ATTRS
int foreground_mesh_verts_par_for_P_Nfaces_s0_p_rebased(void *__user_context, int32_t _P_Nfaces_s0_p_rebased, uint8_t *_closure_arg__7) {
 void * const _ucon = const_cast<void *>(__user_context);
 halide_maybe_unused(_ucon);
 auto *_1394 = (void *)(nullptr);
 struct {
  void * f_0;
  void * f_1;
  int32_t f_2;
  int32_t f_3;
  int32_t f_4;
  int32_t f_5;
  int32_t f_6;
 } s59 = {
  _1394,
  _1394,
  0,
  0,
  0,
  0,
  0
 };
 auto *_1395 = (&s59);
 auto _closure_prototype__7 = _1395;
 halide_maybe_unused(_closure_prototype__7);
 auto *_1396 = ((decltype(_closure_prototype__7))_closure_arg__7)->f_0;
 auto _P_Nfaces = _1396;
 halide_maybe_unused(_P_Nfaces);
 auto *_1397 = ((decltype(_closure_prototype__7))_closure_arg__7)->f_1;
 auto _patch_faces = _1397;
 halide_maybe_unused(_patch_faces);
 int32_t _1398 = ((decltype(_closure_prototype__7))_closure_arg__7)->f_2;
 int32_t _1399 = ((decltype(_closure_prototype__7))_closure_arg__7)->f_3;
 int32_t _1400 = ((decltype(_closure_prototype__7))_closure_arg__7)->f_4;
 int32_t _1401 = ((decltype(_closure_prototype__7))_closure_arg__7)->f_5;
 int32_t _1402 = ((decltype(_closure_prototype__7))_closure_arg__7)->f_6;
 {
  int32_t _sum__4[1];
  // produce sum$4
  _sum__4[0] = 0;
  int32_t _1403 = _P_Nfaces_s0_p_rebased + _1400;
  int32_t _1404 = _1403 * _1399;
  int32_t _1405 = _1404 - _1401;
  for (int _sum__4_s1_r108__x = 0; _sum__4_s1_r108__x < 0 + 578; _sum__4_s1_r108__x++)
  {
   int32_t _1406 = _sum__4_s1_r108__x - _1402;
   int32_t _1407 = _1406 * _1398;
   int32_t _1408 = _1407 + _1405;
   int32_t _1409 = _sum__4[0];
   int32_t _1410 = _1408 + 2;
   int32_t _1411 = ((int32_t *)_patch_faces)[_1410];
   int32_t _1412 = ((int32_t *)_patch_faces)[_1408];
   int32_t _1413 = _1408 + 1;
   int32_t _1414 = ((int32_t *)_patch_faces)[_1413];
   int32_t _1415 = ::halide_cpp_min(_1412, _1414);
   int32_t _1416 = ::halide_cpp_min(_1411, _1415);
   bool _1417 = _1416 < 0;
   int32_t _1418 = (int32_t)(_1417 ? 0 : 1);
   int32_t _1419 = _1409 + _1418;
   _sum__4[0] = _1419;
  } // for _sum__4_s1_r108__x
  // consume sum$4
  int32_t _1420 = _sum__4[0];
  ((int32_t *)_P_Nfaces)[_P_Nfaces_s0_p_rebased] = _1420;
 } // alloc _sum__4
 return 0;
}
HALIDE_FUNCTION_ATTRS
int foreground_mesh_verts(struct halide_buffer_t *_I_canny_buffer, struct halide_buffer_t *_I_back_canny_buffer, struct halide_buffer_t *_I_depth_buffer, struct halide_buffer_t *_P_fore_faces_buffer, struct halide_buffer_t *_P_Nfaces_buffer, struct halide_buffer_t *_I_Vlabels_buffer, struct halide_buffer_t *_I_ForeMask_buffer) {
 void * const _ucon = nullptr;
 halide_maybe_unused(_ucon);
 uint64_t _1421 = (uint64_t)(_P_fore_faces_buffer);
 uint64_t _1422 = (uint64_t)(0ull);
 bool _1423 = _1421 != _1422;
 if (!_1423)
 {
  int32_t _1424 = halide_error_buffer_argument_is_null(_ucon, "P_fore_faces");
  return _1424;
 }
 uint64_t _1425 = (uint64_t)(_P_Nfaces_buffer);
 uint64_t _1426 = (uint64_t)(0ull);
 bool _1427 = _1425 != _1426;
 if (!_1427)
 {
  int32_t _1428 = halide_error_buffer_argument_is_null(_ucon, "P_Nfaces");
  return _1428;
 }
 uint64_t _1429 = (uint64_t)(_I_depth_buffer);
 uint64_t _1430 = (uint64_t)(0ull);
 bool _1431 = _1429 != _1430;
 if (!_1431)
 {
  int32_t _1432 = halide_error_buffer_argument_is_null(_ucon, "I_depth");
  return _1432;
 }
 uint64_t _1433 = (uint64_t)(_I_canny_buffer);
 uint64_t _1434 = (uint64_t)(0ull);
 bool _1435 = _1433 != _1434;
 if (!_1435)
 {
  int32_t _1436 = halide_error_buffer_argument_is_null(_ucon, "I_canny");
  return _1436;
 }
 uint64_t _1437 = (uint64_t)(_I_back_canny_buffer);
 uint64_t _1438 = (uint64_t)(0ull);
 bool _1439 = _1437 != _1438;
 if (!_1439)
 {
  int32_t _1440 = halide_error_buffer_argument_is_null(_ucon, "I_back_canny");
  return _1440;
 }
 uint64_t _1441 = (uint64_t)(_I_Vlabels_buffer);
 uint64_t _1442 = (uint64_t)(0ull);
 bool _1443 = _1441 != _1442;
 if (!_1443)
 {
  int32_t _1444 = halide_error_buffer_argument_is_null(_ucon, "I_Vlabels");
  return _1444;
 }
 uint64_t _1445 = (uint64_t)(_I_ForeMask_buffer);
 uint64_t _1446 = (uint64_t)(0ull);
 bool _1447 = _1445 != _1446;
 if (!_1447)
 {
  int32_t _1448 = halide_error_buffer_argument_is_null(_ucon, "I_ForeMask");
  return _1448;
 }
 auto *_1449 = _halide_buffer_get_host(_I_ForeMask_buffer);
 auto _I_ForeMask = _1449;
 halide_maybe_unused(_I_ForeMask);
 uint32_t _1450 = _halide_buffer_get_type(_I_ForeMask_buffer);
 bool _1451 = _halide_buffer_get_device_dirty(_I_ForeMask_buffer);
 int32_t _1452 = _halide_buffer_get_dimensions(_I_ForeMask_buffer);
 int32_t _1453 = _halide_buffer_get_min(_I_ForeMask_buffer, 0);
 int32_t _1454 = _halide_buffer_get_extent(_I_ForeMask_buffer, 0);
 int32_t _1455 = _halide_buffer_get_stride(_I_ForeMask_buffer, 0);
 int32_t _1456 = _halide_buffer_get_min(_I_ForeMask_buffer, 1);
 int32_t _1457 = _halide_buffer_get_extent(_I_ForeMask_buffer, 1);
 int32_t _1458 = _halide_buffer_get_stride(_I_ForeMask_buffer, 1);
 auto *_1459 = _halide_buffer_get_host(_I_Vlabels_buffer);
 auto _I_Vlabels = _1459;
 halide_maybe_unused(_I_Vlabels);
 uint32_t _1460 = _halide_buffer_get_type(_I_Vlabels_buffer);
 bool _1461 = _halide_buffer_get_device_dirty(_I_Vlabels_buffer);
 int32_t _1462 = _halide_buffer_get_dimensions(_I_Vlabels_buffer);
 int32_t _1463 = _halide_buffer_get_min(_I_Vlabels_buffer, 0);
 int32_t _1464 = _halide_buffer_get_extent(_I_Vlabels_buffer, 0);
 int32_t _1465 = _halide_buffer_get_stride(_I_Vlabels_buffer, 0);
 int32_t _1466 = _halide_buffer_get_min(_I_Vlabels_buffer, 1);
 int32_t _1467 = _halide_buffer_get_extent(_I_Vlabels_buffer, 1);
 int32_t _1468 = _halide_buffer_get_stride(_I_Vlabels_buffer, 1);
 auto *_1469 = _halide_buffer_get_host(_I_back_canny_buffer);
 auto _I_back_canny = _1469;
 halide_maybe_unused(_I_back_canny);
 uint32_t _1470 = _halide_buffer_get_type(_I_back_canny_buffer);
 bool _1471 = _halide_buffer_get_device_dirty(_I_back_canny_buffer);
 int32_t _1472 = _halide_buffer_get_dimensions(_I_back_canny_buffer);
 int32_t _1473 = _halide_buffer_get_min(_I_back_canny_buffer, 0);
 int32_t _1474 = _halide_buffer_get_extent(_I_back_canny_buffer, 0);
 int32_t _1475 = _halide_buffer_get_stride(_I_back_canny_buffer, 0);
 int32_t _1476 = _halide_buffer_get_min(_I_back_canny_buffer, 1);
 int32_t _1477 = _halide_buffer_get_extent(_I_back_canny_buffer, 1);
 int32_t _1478 = _halide_buffer_get_stride(_I_back_canny_buffer, 1);
 auto *_1479 = _halide_buffer_get_host(_I_canny_buffer);
 auto _I_canny = _1479;
 halide_maybe_unused(_I_canny);
 uint32_t _1480 = _halide_buffer_get_type(_I_canny_buffer);
 bool _1481 = _halide_buffer_get_device_dirty(_I_canny_buffer);
 int32_t _1482 = _halide_buffer_get_dimensions(_I_canny_buffer);
 int32_t _1483 = _halide_buffer_get_min(_I_canny_buffer, 0);
 int32_t _1484 = _halide_buffer_get_extent(_I_canny_buffer, 0);
 int32_t _1485 = _halide_buffer_get_stride(_I_canny_buffer, 0);
 int32_t _1486 = _halide_buffer_get_min(_I_canny_buffer, 1);
 int32_t _1487 = _halide_buffer_get_extent(_I_canny_buffer, 1);
 int32_t _1488 = _halide_buffer_get_stride(_I_canny_buffer, 1);
 auto *_1489 = _halide_buffer_get_host(_I_depth_buffer);
 auto _I_depth = _1489;
 halide_maybe_unused(_I_depth);
 uint32_t _1490 = _halide_buffer_get_type(_I_depth_buffer);
 bool _1491 = _halide_buffer_get_device_dirty(_I_depth_buffer);
 int32_t _1492 = _halide_buffer_get_dimensions(_I_depth_buffer);
 int32_t _1493 = _halide_buffer_get_min(_I_depth_buffer, 0);
 int32_t _1494 = _halide_buffer_get_extent(_I_depth_buffer, 0);
 int32_t _1495 = _halide_buffer_get_stride(_I_depth_buffer, 0);
 int32_t _1496 = _halide_buffer_get_min(_I_depth_buffer, 1);
 int32_t _1497 = _halide_buffer_get_extent(_I_depth_buffer, 1);
 int32_t _1498 = _halide_buffer_get_stride(_I_depth_buffer, 1);
 auto *_1499 = _halide_buffer_get_host(_P_Nfaces_buffer);
 auto _P_Nfaces = _1499;
 halide_maybe_unused(_P_Nfaces);
 uint32_t _1500 = _halide_buffer_get_type(_P_Nfaces_buffer);
 bool _1501 = _halide_buffer_get_device_dirty(_P_Nfaces_buffer);
 int32_t _1502 = _halide_buffer_get_dimensions(_P_Nfaces_buffer);
 int32_t _1503 = _halide_buffer_get_min(_P_Nfaces_buffer, 0);
 int32_t _1504 = _halide_buffer_get_extent(_P_Nfaces_buffer, 0);
 int32_t _1505 = _halide_buffer_get_stride(_P_Nfaces_buffer, 0);
 auto *_1506 = _halide_buffer_get_host(_P_fore_faces_buffer);
 auto _P_fore_faces = _1506;
 halide_maybe_unused(_P_fore_faces);
 uint32_t _1507 = _halide_buffer_get_type(_P_fore_faces_buffer);
 bool _1508 = _halide_buffer_get_device_dirty(_P_fore_faces_buffer);
 int32_t _1509 = _halide_buffer_get_dimensions(_P_fore_faces_buffer);
 int32_t _1510 = _halide_buffer_get_min(_P_fore_faces_buffer, 0);
 int32_t _1511 = _halide_buffer_get_extent(_P_fore_faces_buffer, 0);
 int32_t _1512 = _halide_buffer_get_stride(_P_fore_faces_buffer, 0);
 int32_t _1513 = _halide_buffer_get_min(_P_fore_faces_buffer, 1);
 int32_t _1514 = _halide_buffer_get_extent(_P_fore_faces_buffer, 1);
 int32_t _1515 = _halide_buffer_get_stride(_P_fore_faces_buffer, 1);
 int32_t _1516 = _halide_buffer_get_min(_P_fore_faces_buffer, 2);
 int32_t _1517 = _halide_buffer_get_extent(_P_fore_faces_buffer, 2);
 int32_t _1518 = _halide_buffer_get_stride(_P_fore_faces_buffer, 2);
 int32_t _1519 = _1517 + _1516;
 int32_t _1520 = _1504 + _1503;
 int32_t _1521 = ::halide_cpp_max(_1519, _1520);
 int32_t _1522 = ::halide_cpp_min(_1503, _1516);
 float _1523 = (float)(_1484);
 float _1524 = float_from_bits(1031798784 /* 0.0625 */);
 float _1525 = _1523 * _1524;
 float _1526 = floor_f32(_1525);
 int32_t _1527 = (int32_t)(_1526);
 float _1528 = (float)(_1527);
 int32_t _1529 = _1521 + -1;
 float _1530 = (float)(_1529);
 float _1531 = (float)(_1522);
 float _1532 = float_from_bits(0 /* 0 */);
 bool _1533 = _1532 < _1528;
 float _1534 = (float)(_1533 ? _1530 : _1531);
 float _1535 = _1534 / _1528;
 float _1536 = floor_f32(_1535);
 float _1537 = float_from_bits(1098907648 /* 16 */);
 float _1538 = _1536 * _1537;
 int32_t _1539 = (int32_t)(_1538);
 int32_t _1540 = _1539 + 17;
 int32_t _1541 = ::halide_cpp_min(_1540, _1487);
 int32_t _1542 = _1467 + _1466;
 int32_t _1543 = ::halide_cpp_max(_1541, _1542);
 int32_t _1544 = _1487 + -1;
 float _1545 = (float)(_1533 ? _1531 : _1530);
 float _1546 = _1545 / _1528;
 float _1547 = floor_f32(_1546);
 float _1548 = _1547 * _1537;
 int32_t _1549 = (int32_t)(_1548);
 int32_t _1550 = ::halide_cpp_min(_1544, _1549);
 int32_t _1551 = ::halide_cpp_max(_1550, 0);
 int32_t _1552 = ::halide_cpp_min(_1551, _1466);
 int32_t _1553 = -1 - _1484;
 int32_t _1554 = ::halide_cpp_max(_1484, 1);
 int32_t _1555 = _1554 + -1;
 int32_t _1556 = ::halide_cpp_max(_1553, _1555);
 int32_t _1557 = _1556 + 17;
 int32_t _1558 = ::halide_cpp_min(_1557, _1484);
 int32_t _1559 = _1464 + _1463;
 int32_t _1560 = ::halide_cpp_max(_1558, _1559);
 bool _1561 = _1527 < 0;
 float _1562 = (float)(_1552);
 float _1563 = _1562 * _1524;
 float _1564 = floor_f32(_1563);
 int32_t _1565 = (int32_t)(_1564);
 int32_t _1566 = ::halide_cpp_max(_1543, 1);
 int32_t _1567 = _1566 + -1;
 float _1568 = (float)(_1567);
 float _1569 = _1568 * _1524;
 float _1570 = floor_f32(_1569);
 int32_t _1571 = (int32_t)(_1570);
 int32_t _1572 = (int32_t)(_1561 ? _1565 : _1571);
 int32_t _1573 = _1572 * _1527;
 int32_t _1574 = ::halide_cpp_max(_1560, 1);
 int32_t _1575 = _1574 + -1;
 float _1576 = (float)(_1575);
 float _1577 = _1576 * _1524;
 float _1578 = floor_f32(_1577);
 int32_t _1579 = (int32_t)(_1578);
 int32_t _1580 = _1573 + _1579;
 float _1581 = (float)(_1456);
 float _1582 = _1581 * _1524;
 float _1583 = floor_f32(_1582);
 int32_t _1584 = (int32_t)(_1583);
 int32_t _1585 = _1457 + _1456;
 int32_t _1586 = _1585 + -1;
 float _1587 = (float)(_1586);
 float _1588 = _1587 * _1524;
 float _1589 = floor_f32(_1588);
 int32_t _1590 = (int32_t)(_1589);
 int32_t _1591 = (int32_t)(_1561 ? _1584 : _1590);
 int32_t _1592 = _1591 * _1527;
 int32_t _1593 = _1454 + _1453;
 int32_t _1594 = _1593 + -1;
 float _1595 = (float)(_1594);
 float _1596 = _1595 * _1524;
 float _1597 = floor_f32(_1596);
 int32_t _1598 = (int32_t)(_1597);
 int32_t _1599 = _1592 + _1598;
 int32_t _1600 = ::halide_cpp_max(_1580, _1599);
 int32_t _1601 = ::halide_cpp_min(_1527, 0);
 int32_t _1602 = _1600 - _1601;
 int32_t _1603 = (int32_t)(_1561 ? _1571 : _1565);
 int32_t _1604 = _1603 * _1527;
 int32_t _1605 = ::halide_cpp_min(_1463, 0);
 float _1606 = (float)(_1605);
 float _1607 = _1606 * _1524;
 float _1608 = floor_f32(_1607);
 int32_t _1609 = (int32_t)(_1608);
 int32_t _1610 = _1604 + _1609;
 int32_t _1611 = (int32_t)(_1561 ? _1590 : _1584);
 int32_t _1612 = _1611 * _1527;
 float _1613 = (float)(_1453);
 float _1614 = _1613 * _1524;
 float _1615 = floor_f32(_1614);
 int32_t _1616 = (int32_t)(_1615);
 int32_t _1617 = _1612 + _1616;
 int32_t _1618 = _1617 - _1527;
 int32_t _1619 = ::halide_cpp_max(_1618, 0);
 int32_t _1620 = ::halide_cpp_max(_1527, 0);
 int32_t _1621 = _1610 - _1527;
 int32_t _1622 = ::halide_cpp_max(_1621, 0);
 int32_t _1623 = ::halide_cpp_max(_1617, 1);
 int32_t _1624 = _1623 + -1;
 int32_t _1625 = ::halide_cpp_min(_1624, _1617);
 int32_t _1626 = ::halide_cpp_min(_1619, _1625);
 int32_t _1627 = ::halide_cpp_min(_1626, _1617);
 int32_t _1628 = ::halide_cpp_min(_1619, _1627);
 int32_t _1629 = _1617 - _1620;
 int32_t _1630 = ::halide_cpp_max(_1629, 1);
 int32_t _1631 = _1630 + -1;
 int32_t _1632 = ::halide_cpp_min(_1628, _1631);
 int32_t _1633 = ::halide_cpp_min(_1632, _1617);
 int32_t _1634 = ::halide_cpp_min(_1633, _1610);
 int32_t _1635 = ::halide_cpp_max(_1610, 1);
 int32_t _1636 = _1635 + -1;
 int32_t _1637 = ::halide_cpp_min(_1634, _1636);
 int32_t _1638 = ::halide_cpp_min(_1622, _1637);
 int32_t _1639 = ::halide_cpp_min(_1638, _1610);
 int32_t _1640 = _1610 - _1620;
 int32_t _1641 = ::halide_cpp_max(_1640, 1);
 int32_t _1642 = _1641 + -1;
 int32_t _1643 = ::halide_cpp_min(_1639, _1642);
 int32_t _1644 = ::halide_cpp_max(_1521, 1);
 int32_t _1645 = _1644 + -1;
 int32_t _1646 = ::halide_cpp_max(_1645, _1602);
 int32_t _1647 = ::halide_cpp_min(_1643, _1522);
 int32_t _1648 = ::halide_cpp_max(_1529, _1602);
 int32_t _1649 = ::halide_cpp_max(_1558, _1560);
 int32_t _1650 = ::halide_cpp_max(_1649, 1);
 int32_t _1651 = _1650 - _1605;
 int32_t _1652 = ::halide_cpp_max(_1541, _1543);
 int32_t _1653 = ::halide_cpp_max(_1652, 1);
 int32_t _1654 = ::halide_cpp_min(_1551, _1552);
 int32_t _1655 = _1653 - _1654;
 int32_t _1656 = ::halide_cpp_max(_1602, 0);
 int32_t _1657 = _1656 - _1643;
 int32_t _1658 = _1657 >> 5;
 int32_t _1659 = _1658 * 32;
 int32_t _1660 = _1659 + _1643;
 int32_t _1661 = _1656 + -31;
 int32_t _1662 = ::halide_cpp_min(_1660, _1661);
 int32_t _1663 = ::halide_cpp_min(_1661, _1643);
 float _1664 = (float)(_1663);
 int32_t _1665 = _1662 + 31;
 float _1666 = (float)(_1665);
 float _1667 = (float)(_1533 ? _1666 : _1664);
 float _1668 = _1667 / _1528;
 float _1669 = floor_f32(_1668);
 float _1670 = _1669 * _1537;
 int32_t _1671 = (int32_t)(_1670);
 int32_t _1672 = ::halide_cpp_max(_1671, -16);
 int32_t _1673 = _1672 + 17;
 int32_t _1674 = ::halide_cpp_min(_1673, _1487);
 int32_t _1675 = ::halide_cpp_max(_1674, 1);
 float _1676 = (float)(_1533 ? _1664 : _1666);
 float _1677 = _1676 / _1528;
 float _1678 = floor_f32(_1677);
 float _1679 = _1678 * _1537;
 int32_t _1680 = (int32_t)(_1679);
 int32_t _1681 = ::halide_cpp_min(_1544, _1680);
 int32_t _1682 = ::halide_cpp_max(_1681, 0);
 int32_t _1683 = _1675 - _1682;
 int32_t _1684 = _1683 + -1;
 int32_t _1685 = _1660 + 31;
 int32_t _1686 = ::halide_cpp_min(_1656, _1685);
 float _1687 = (float)(_1686);
 float _1688 = (float)(_1533 ? _1664 : _1687);
 float _1689 = _1688 / _1528;
 float _1690 = floor_f32(_1689);
 float _1691 = _1690 * _1537;
 int32_t _1692 = (int32_t)(_1691);
 int32_t _1693 = ::halide_cpp_min(_1544, _1692);
 int32_t _1694 = ::halide_cpp_max(_1693, 0);
 int32_t _1695 = _1646 - _1647;
 int32_t _1696 = _1695 >> 5;
 int32_t _1697 = _1696 * 32;
 int32_t _1698 = _1697 + _1647;
 int32_t _1699 = _1646 + -31;
 int32_t _1700 = ::halide_cpp_min(_1698, _1699);
 int32_t _1701 = ::halide_cpp_min(_1699, _1647);
 float _1702 = (float)(_1701);
 int32_t _1703 = _1700 + 31;
 float _1704 = (float)(_1703);
 float _1705 = (float)(_1533 ? _1704 : _1702);
 float _1706 = _1705 / _1528;
 float _1707 = floor_f32(_1706);
 float _1708 = _1707 * _1537;
 int32_t _1709 = (int32_t)(_1708);
 int32_t _1710 = ::halide_cpp_max(_1709, -16);
 int32_t _1711 = _1710 + 17;
 int32_t _1712 = ::halide_cpp_min(_1711, _1487);
 int32_t _1713 = ::halide_cpp_max(_1712, 1);
 float _1714 = (float)(_1533 ? _1702 : _1704);
 float _1715 = _1714 / _1528;
 float _1716 = floor_f32(_1715);
 float _1717 = _1716 * _1537;
 int32_t _1718 = (int32_t)(_1717);
 int32_t _1719 = ::halide_cpp_min(_1544, _1718);
 int32_t _1720 = ::halide_cpp_max(_1719, 0);
 int32_t _1721 = _1713 - _1720;
 int32_t _1722 = _1721 + -1;
 int32_t _1723 = _1698 + 31;
 int32_t _1724 = ::halide_cpp_min(_1723, _1646);
 float _1725 = (float)(_1724);
 float _1726 = (float)(_1533 ? _1702 : _1725);
 float _1727 = _1726 / _1528;
 float _1728 = floor_f32(_1727);
 float _1729 = _1728 * _1537;
 int32_t _1730 = (int32_t)(_1729);
 int32_t _1731 = ::halide_cpp_min(_1544, _1730);
 int32_t _1732 = ::halide_cpp_max(_1731, 0);
 bool _1733 = _halide_buffer_is_bounds_query(_I_ForeMask_buffer);
 if (_1733)
 {
  auto *_1734 = _halide_buffer_get_shape(_I_ForeMask_buffer);
  auto *_1735 = (void *)(nullptr);
  uint64_t _1736 = (uint64_t)(0ull);
  auto *_1737 = (struct halide_device_interface_t *)(nullptr);
  struct halide_dimension_t s60[2] = {
   {_1453, _1454, 1, 0},
   {_1456, _1457, _1454, 0},
  };
  auto *_1738 = s60;
  auto *_1739 = _halide_buffer_init(_I_ForeMask_buffer, _1734, _1735, _1736, _1737, 0, 32, 2, _1738, _1736);
  halide_maybe_unused(_1739);
 } // if _1733
 bool _1740 = _halide_buffer_is_bounds_query(_I_Vlabels_buffer);
 if (_1740)
 {
  auto *_1741 = _halide_buffer_get_shape(_I_Vlabels_buffer);
  auto *_1742 = (void *)(nullptr);
  uint64_t _1743 = (uint64_t)(0ull);
  auto *_1744 = (struct halide_device_interface_t *)(nullptr);
  int32_t _1745 = ::halide_cpp_min(_1463, 0);
  struct halide_dimension_t s61[2] = {
   {_1745, _1651, 1, 0},
   {_1654, _1655, _1651, 0},
  };
  auto *_1746 = s61;
  auto *_1747 = _halide_buffer_init(_I_Vlabels_buffer, _1741, _1742, _1743, _1744, 0, 32, 2, _1746, _1743);
  halide_maybe_unused(_1747);
 } // if _1740
 bool _1748 = _halide_buffer_is_bounds_query(_I_back_canny_buffer);
 if (_1748)
 {
  int32_t _1749 = ::halide_cpp_max(_1558, 1);
  auto *_1750 = _halide_buffer_get_shape(_I_back_canny_buffer);
  auto *_1751 = (void *)(nullptr);
  uint64_t _1752 = (uint64_t)(0ull);
  auto *_1753 = (struct halide_device_interface_t *)(nullptr);
  int32_t _1754 = _1684 + 1;
  struct halide_dimension_t s62[2] = {
   {0, _1749, 1, 0},
   {_1694, _1754, _1749, 0},
  };
  auto *_1755 = s62;
  auto *_1756 = _halide_buffer_init(_I_back_canny_buffer, _1750, _1751, _1752, _1753, 1, 8, 2, _1755, _1752);
  halide_maybe_unused(_1756);
 } // if _1748
 bool _1757 = _halide_buffer_is_bounds_query(_I_canny_buffer);
 if (_1757)
 {
  int32_t _1758 = ::halide_cpp_max(_1558, 1);
  auto *_1759 = _halide_buffer_get_shape(_I_canny_buffer);
  auto *_1760 = (void *)(nullptr);
  uint64_t _1761 = (uint64_t)(0ull);
  auto *_1762 = (struct halide_device_interface_t *)(nullptr);
  int32_t _1763 = _1722 + 1;
  struct halide_dimension_t s63[2] = {
   {0, _1758, 1, 0},
   {_1732, _1763, _1758, 0},
  };
  auto *_1764 = s63;
  auto *_1765 = _halide_buffer_init(_I_canny_buffer, _1759, _1760, _1761, _1762, 1, 8, 2, _1764, _1761);
  halide_maybe_unused(_1765);
 } // if _1757
 bool _1766 = _halide_buffer_is_bounds_query(_I_depth_buffer);
 if (_1766)
 {
  int32_t _1767 = ::halide_cpp_max(_1558, 1);
  auto *_1768 = _halide_buffer_get_shape(_I_depth_buffer);
  auto *_1769 = (void *)(nullptr);
  uint64_t _1770 = (uint64_t)(0ull);
  auto *_1771 = (struct halide_device_interface_t *)(nullptr);
  int32_t _1772 = _1684 + 1;
  struct halide_dimension_t s64[2] = {
   {0, _1767, 1, 0},
   {_1694, _1772, _1767, 0},
  };
  auto *_1773 = s64;
  auto *_1774 = _halide_buffer_init(_I_depth_buffer, _1768, _1769, _1770, _1771, 1, 8, 2, _1773, _1770);
  halide_maybe_unused(_1774);
 } // if _1766
 bool _1775 = _halide_buffer_is_bounds_query(_P_Nfaces_buffer);
 if (_1775)
 {
  auto *_1776 = _halide_buffer_get_shape(_P_Nfaces_buffer);
  auto *_1777 = (void *)(nullptr);
  uint64_t _1778 = (uint64_t)(0ull);
  auto *_1779 = (struct halide_device_interface_t *)(nullptr);
  struct halide_dimension_t s65[1] = {
   {_1503, _1504, 1, 0},
  };
  auto *_1780 = s65;
  auto *_1781 = _halide_buffer_init(_P_Nfaces_buffer, _1776, _1777, _1778, _1779, 0, 32, 1, _1780, _1778);
  halide_maybe_unused(_1781);
 } // if _1775
 bool _1782 = _halide_buffer_is_bounds_query(_P_fore_faces_buffer);
 if (_1782)
 {
  auto *_1783 = _halide_buffer_get_shape(_P_fore_faces_buffer);
  auto *_1784 = (void *)(nullptr);
  uint64_t _1785 = (uint64_t)(0ull);
  auto *_1786 = (struct halide_device_interface_t *)(nullptr);
  int32_t _1787 = ::halide_cpp_min(_1517, 32);
  int32_t _1788 = _1787 + _1516;
  int32_t _1789 = _1788 + -32;
  int32_t _1790 = ::halide_cpp_max(_1517, 32);
  int32_t _1791 = _1511 * _1514;
  struct halide_dimension_t s66[3] = {
   {_1510, _1511, 1, 0},
   {_1513, _1514, _1511, 0},
   {_1789, _1790, _1791, 0},
  };
  auto *_1792 = s66;
  auto *_1793 = _halide_buffer_init(_P_fore_faces_buffer, _1783, _1784, _1785, _1786, 0, 32, 3, _1792, _1785);
  halide_maybe_unused(_1793);
 } // if _1782
 bool _1794 = _halide_buffer_is_bounds_query(_P_fore_faces_buffer);
 bool _1795 = _halide_buffer_is_bounds_query(_P_Nfaces_buffer);
 bool _1796 = _halide_buffer_is_bounds_query(_I_depth_buffer);
 bool _1797 = _halide_buffer_is_bounds_query(_I_canny_buffer);
 bool _1798 = _halide_buffer_is_bounds_query(_I_back_canny_buffer);
 bool _1799 = _halide_buffer_is_bounds_query(_I_ForeMask_buffer);
 bool _1800 = _halide_buffer_is_bounds_query(_I_Vlabels_buffer);
 bool _1801 = _1799 || _1800;
 bool _1802 = _1798 || _1801;
 bool _1803 = _1797 || _1802;
 bool _1804 = _1796 || _1803;
 bool _1805 = _1795 || _1804;
 bool _1806 = _1794 || _1805;
 bool _1807 = !(_1806);
 if (_1807)
 {
  uint32_t _1808 = (uint32_t)(73728ull);
  bool _1809 = _1450 == _1808;
  if (!_1809)
  {
   uint32_t _1810 = (uint32_t)(73728ull);
   int32_t _1811 = halide_error_bad_type(_ucon, "Output buffer I_ForeMask", _1450, _1810);
   return _1811;
  }
  bool _1812 = _1452 == 2;
  if (!_1812)
  {
   int32_t _1813 = halide_error_bad_dimensions(_ucon, "Output buffer I_ForeMask", _1452, 2);
   return _1813;
  }
  uint32_t _1814 = (uint32_t)(73728ull);
  bool _1815 = _1460 == _1814;
  if (!_1815)
  {
   uint32_t _1816 = (uint32_t)(73728ull);
   int32_t _1817 = halide_error_bad_type(_ucon, "Output buffer I_Vlabels", _1460, _1816);
   return _1817;
  }
  bool _1818 = _1462 == 2;
  if (!_1818)
  {
   int32_t _1819 = halide_error_bad_dimensions(_ucon, "Output buffer I_Vlabels", _1462, 2);
   return _1819;
  }
  uint32_t _1820 = (uint32_t)(67585ull);
  bool _1821 = _1470 == _1820;
  if (!_1821)
  {
   uint32_t _1822 = (uint32_t)(67585ull);
   int32_t _1823 = halide_error_bad_type(_ucon, "Input buffer I_back_canny", _1470, _1822);
   return _1823;
  }
  bool _1824 = _1472 == 2;
  if (!_1824)
  {
   int32_t _1825 = halide_error_bad_dimensions(_ucon, "Input buffer I_back_canny", _1472, 2);
   return _1825;
  }
  uint32_t _1826 = (uint32_t)(67585ull);
  bool _1827 = _1480 == _1826;
  if (!_1827)
  {
   uint32_t _1828 = (uint32_t)(67585ull);
   int32_t _1829 = halide_error_bad_type(_ucon, "Input buffer I_canny", _1480, _1828);
   return _1829;
  }
  bool _1830 = _1482 == 2;
  if (!_1830)
  {
   int32_t _1831 = halide_error_bad_dimensions(_ucon, "Input buffer I_canny", _1482, 2);
   return _1831;
  }
  uint32_t _1832 = (uint32_t)(67585ull);
  bool _1833 = _1490 == _1832;
  if (!_1833)
  {
   uint32_t _1834 = (uint32_t)(67585ull);
   int32_t _1835 = halide_error_bad_type(_ucon, "Input buffer I_depth", _1490, _1834);
   return _1835;
  }
  bool _1836 = _1492 == 2;
  if (!_1836)
  {
   int32_t _1837 = halide_error_bad_dimensions(_ucon, "Input buffer I_depth", _1492, 2);
   return _1837;
  }
  uint32_t _1838 = (uint32_t)(73728ull);
  bool _1839 = _1500 == _1838;
  if (!_1839)
  {
   uint32_t _1840 = (uint32_t)(73728ull);
   int32_t _1841 = halide_error_bad_type(_ucon, "Output buffer P_Nfaces", _1500, _1840);
   return _1841;
  }
  bool _1842 = _1502 == 1;
  if (!_1842)
  {
   int32_t _1843 = halide_error_bad_dimensions(_ucon, "Output buffer P_Nfaces", _1502, 1);
   return _1843;
  }
  uint32_t _1844 = (uint32_t)(73728ull);
  bool _1845 = _1507 == _1844;
  if (!_1845)
  {
   uint32_t _1846 = (uint32_t)(73728ull);
   int32_t _1847 = halide_error_bad_type(_ucon, "Output buffer P_fore_faces", _1507, _1846);
   return _1847;
  }
  bool _1848 = _1509 == 3;
  if (!_1848)
  {
   int32_t _1849 = halide_error_bad_dimensions(_ucon, "Output buffer P_fore_faces", _1509, 3);
   return _1849;
  }
  bool _1850 = 0 <= _1454;
  if (!_1850)
  {
   int32_t _1851 = halide_error_buffer_extents_negative(_ucon, "Output buffer I_ForeMask", 0, _1454);
   return _1851;
  }
  bool _1852 = 0 <= _1457;
  if (!_1852)
  {
   int32_t _1853 = halide_error_buffer_extents_negative(_ucon, "Output buffer I_ForeMask", 1, _1457);
   return _1853;
  }
  bool _1854 = _1463 <= 0;
  int32_t _1855 = ::halide_cpp_min(_1463, 0);
  int32_t _1856 = _1855 + _1651;
  int32_t _1857 = _1464 + _1463;
  bool _1858 = _1856 <= _1857;
  bool _1859 = _1854 && _1858;
  if (!_1859)
  {
   int32_t _1860 = ::halide_cpp_min(_1463, 0);
   int32_t _1861 = _1860 + _1651;
   int32_t _1862 = _1861 + -1;
   int32_t _1863 = _1464 + _1463;
   int32_t _1864 = _1863 + -1;
   int32_t _1865 = halide_error_access_out_of_bounds(_ucon, "Output buffer I_Vlabels", 0, _1860, _1862, _1463, _1864);
   return _1865;
  }
  bool _1866 = 0 <= _1464;
  if (!_1866)
  {
   int32_t _1867 = halide_error_buffer_extents_negative(_ucon, "Output buffer I_Vlabels", 0, _1464);
   return _1867;
  }
  bool _1868 = _1466 <= _1654;
  int32_t _1869 = _1655 + _1654;
  int32_t _1870 = _1467 + _1466;
  bool _1871 = _1869 <= _1870;
  bool _1872 = _1868 && _1871;
  if (!_1872)
  {
   int32_t _1873 = _1655 + _1654;
   int32_t _1874 = _1873 + -1;
   int32_t _1875 = _1467 + _1466;
   int32_t _1876 = _1875 + -1;
   int32_t _1877 = halide_error_access_out_of_bounds(_ucon, "Output buffer I_Vlabels", 1, _1654, _1874, _1466, _1876);
   return _1877;
  }
  bool _1878 = 0 <= _1467;
  if (!_1878)
  {
   int32_t _1879 = halide_error_buffer_extents_negative(_ucon, "Output buffer I_Vlabels", 1, _1467);
   return _1879;
  }
  bool _1880 = _1473 <= 0;
  int32_t _1881 = ::halide_cpp_max(_1558, 1);
  int32_t _1882 = _1474 + _1473;
  bool _1883 = _1881 <= _1882;
  bool _1884 = _1880 && _1883;
  if (!_1884)
  {
   int32_t _1885 = ::halide_cpp_max(_1558, 1);
   int32_t _1886 = _1885 + -1;
   int32_t _1887 = _1474 + _1473;
   int32_t _1888 = _1887 + -1;
   int32_t _1889 = halide_error_access_out_of_bounds(_ucon, "Input buffer I_back_canny", 0, 0, _1886, _1473, _1888);
   return _1889;
  }
  bool _1890 = 0 <= _1474;
  if (!_1890)
  {
   int32_t _1891 = halide_error_buffer_extents_negative(_ucon, "Input buffer I_back_canny", 0, _1474);
   return _1891;
  }
  bool _1892 = _1476 <= _1694;
  int32_t _1893 = _1684 + _1694;
  int32_t _1894 = _1893 + 1;
  int32_t _1895 = _1477 + _1476;
  bool _1896 = _1894 <= _1895;
  bool _1897 = _1892 && _1896;
  if (!_1897)
  {
   int32_t _1898 = _1684 + _1694;
   int32_t _1899 = _1477 + _1476;
   int32_t _1900 = _1899 + -1;
   int32_t _1901 = halide_error_access_out_of_bounds(_ucon, "Input buffer I_back_canny", 1, _1694, _1898, _1476, _1900);
   return _1901;
  }
  bool _1902 = 0 <= _1477;
  if (!_1902)
  {
   int32_t _1903 = halide_error_buffer_extents_negative(_ucon, "Input buffer I_back_canny", 1, _1477);
   return _1903;
  }
  bool _1904 = _1483 <= 0;
  int32_t _1905 = ::halide_cpp_max(_1558, 1);
  int32_t _1906 = _1484 + _1483;
  bool _1907 = _1905 <= _1906;
  bool _1908 = _1904 && _1907;
  if (!_1908)
  {
   int32_t _1909 = ::halide_cpp_max(_1558, 1);
   int32_t _1910 = _1909 + -1;
   int32_t _1911 = _1484 + _1483;
   int32_t _1912 = _1911 + -1;
   int32_t _1913 = halide_error_access_out_of_bounds(_ucon, "Input buffer I_canny", 0, 0, _1910, _1483, _1912);
   return _1913;
  }
  bool _1914 = 0 <= _1484;
  if (!_1914)
  {
   int32_t _1915 = halide_error_buffer_extents_negative(_ucon, "Input buffer I_canny", 0, _1484);
   return _1915;
  }
  bool _1916 = _1486 <= _1732;
  int32_t _1917 = _1722 + _1732;
  int32_t _1918 = _1917 + 1;
  int32_t _1919 = _1487 + _1486;
  bool _1920 = _1918 <= _1919;
  bool _1921 = _1916 && _1920;
  if (!_1921)
  {
   int32_t _1922 = _1722 + _1732;
   int32_t _1923 = _1487 + _1486;
   int32_t _1924 = _1923 + -1;
   int32_t _1925 = halide_error_access_out_of_bounds(_ucon, "Input buffer I_canny", 1, _1732, _1922, _1486, _1924);
   return _1925;
  }
  bool _1926 = 0 <= _1487;
  if (!_1926)
  {
   int32_t _1927 = halide_error_buffer_extents_negative(_ucon, "Input buffer I_canny", 1, _1487);
   return _1927;
  }
  bool _1928 = _1493 <= 0;
  int32_t _1929 = ::halide_cpp_max(_1558, 1);
  int32_t _1930 = _1494 + _1493;
  bool _1931 = _1929 <= _1930;
  bool _1932 = _1928 && _1931;
  if (!_1932)
  {
   int32_t _1933 = ::halide_cpp_max(_1558, 1);
   int32_t _1934 = _1933 + -1;
   int32_t _1935 = _1494 + _1493;
   int32_t _1936 = _1935 + -1;
   int32_t _1937 = halide_error_access_out_of_bounds(_ucon, "Input buffer I_depth", 0, 0, _1934, _1493, _1936);
   return _1937;
  }
  bool _1938 = 0 <= _1494;
  if (!_1938)
  {
   int32_t _1939 = halide_error_buffer_extents_negative(_ucon, "Input buffer I_depth", 0, _1494);
   return _1939;
  }
  bool _1940 = _1496 <= _1694;
  int32_t _1941 = _1684 + _1694;
  int32_t _1942 = _1941 + 1;
  int32_t _1943 = _1497 + _1496;
  bool _1944 = _1942 <= _1943;
  bool _1945 = _1940 && _1944;
  if (!_1945)
  {
   int32_t _1946 = _1684 + _1694;
   int32_t _1947 = _1497 + _1496;
   int32_t _1948 = _1947 + -1;
   int32_t _1949 = halide_error_access_out_of_bounds(_ucon, "Input buffer I_depth", 1, _1694, _1946, _1496, _1948);
   return _1949;
  }
  bool _1950 = 0 <= _1497;
  if (!_1950)
  {
   int32_t _1951 = halide_error_buffer_extents_negative(_ucon, "Input buffer I_depth", 1, _1497);
   return _1951;
  }
  bool _1952 = 0 <= _1504;
  if (!_1952)
  {
   int32_t _1953 = halide_error_buffer_extents_negative(_ucon, "Output buffer P_Nfaces", 0, _1504);
   return _1953;
  }
  bool _1954 = 0 <= _1511;
  if (!_1954)
  {
   int32_t _1955 = halide_error_buffer_extents_negative(_ucon, "Output buffer P_fore_faces", 0, _1511);
   return _1955;
  }
  bool _1956 = 0 <= _1514;
  if (!_1956)
  {
   int32_t _1957 = halide_error_buffer_extents_negative(_ucon, "Output buffer P_fore_faces", 1, _1514);
   return _1957;
  }
  bool _1958 = 32 <= _1517;
  if (!_1958)
  {
   int32_t _1959 = _1517 + _1516;
   int32_t _1960 = ::halide_cpp_min(_1517, 32);
   int32_t _1961 = _1960 + _1516;
   int32_t _1962 = _1961 + -32;
   int32_t _1963 = _1959 + -1;
   int32_t _1964 = halide_error_access_out_of_bounds(_ucon, "Output buffer P_fore_faces", 2, _1962, _1963, _1516, _1963);
   return _1964;
  }
  bool _1965 = _1455 == 1;
  if (!_1965)
  {
   int32_t _1966 = halide_error_constraint_violated(_ucon, "I_ForeMask.stride.0", _1455, "1", 1);
   return _1966;
  }
  bool _1967 = _1465 == 1;
  if (!_1967)
  {
   int32_t _1968 = halide_error_constraint_violated(_ucon, "I_Vlabels.stride.0", _1465, "1", 1);
   return _1968;
  }
  bool _1969 = _1475 == 1;
  if (!_1969)
  {
   int32_t _1970 = halide_error_constraint_violated(_ucon, "I_back_canny.stride.0", _1475, "1", 1);
   return _1970;
  }
  bool _1971 = _1485 == 1;
  if (!_1971)
  {
   int32_t _1972 = halide_error_constraint_violated(_ucon, "I_canny.stride.0", _1485, "1", 1);
   return _1972;
  }
  bool _1973 = _1495 == 1;
  if (!_1973)
  {
   int32_t _1974 = halide_error_constraint_violated(_ucon, "I_depth.stride.0", _1495, "1", 1);
   return _1974;
  }
  bool _1975 = _1505 == 1;
  if (!_1975)
  {
   int32_t _1976 = halide_error_constraint_violated(_ucon, "P_Nfaces.stride.0", _1505, "1", 1);
   return _1976;
  }
  bool _1977 = _1512 == 1;
  if (!_1977)
  {
   int32_t _1978 = halide_error_constraint_violated(_ucon, "P_fore_faces.stride.0", _1512, "1", 1);
   return _1978;
  }
  int64_t _1979 = (int64_t)(_1457);
  int64_t _1980 = (int64_t)(_1454);
  int64_t _1981 = _1979 * _1980;
  int64_t _1982 = (int64_t)(_1467);
  int64_t _1983 = (int64_t)(_1464);
  int64_t _1984 = _1982 * _1983;
  int64_t _1985 = (int64_t)(_1477);
  int64_t _1986 = (int64_t)(_1474);
  int64_t _1987 = _1985 * _1986;
  int64_t _1988 = (int64_t)(_1487);
  int64_t _1989 = (int64_t)(_1484);
  int64_t _1990 = _1988 * _1989;
  int64_t _1991 = (int64_t)(_1497);
  int64_t _1992 = (int64_t)(_1494);
  int64_t _1993 = _1991 * _1992;
  int64_t _1994 = (int64_t)(_1514);
  int64_t _1995 = (int64_t)(_1511);
  int64_t _1996 = _1994 * _1995;
  int64_t _1997 = (int64_t)(_1517);
  int64_t _1998 = _1996 * _1997;
  uint64_t _1999 = (uint64_t)(_1454);
  uint64_t _2000 = (uint64_t)(2147483647ull);
  bool _2001 = _1999 <= _2000;
  if (!_2001)
  {
   uint64_t _2002 = (uint64_t)(_1454);
   uint64_t _2003 = (uint64_t)(2147483647ull);
   int32_t _2004 = halide_error_buffer_allocation_too_large(_ucon, "I_ForeMask", _2002, _2003);
   return _2004;
  }
  int64_t _2005 = (int64_t)(_1457);
  int64_t _2006 = (int64_t)(_1458);
  int64_t _2007 = _2005 * _2006;
  int64_t _2008 = (int64_t)(0ll);
  int64_t _2009 = _2008 - _2007;
  bool _2010 = _2007 > _2008;
  int64_t _2011 = (int64_t)(_2010 ? _2007 : _2009);
  uint64_t _2012 = (uint64_t)(_2011);
  uint64_t _2013 = _2012;
  uint64_t _2014 = (uint64_t)(2147483647ull);
  bool _2015 = _2013 <= _2014;
  if (!_2015)
  {
   int64_t _2016 = (int64_t)(_1457);
   int64_t _2017 = (int64_t)(_1458);
   int64_t _2018 = _2016 * _2017;
   int64_t _2019 = (int64_t)(0ll);
   int64_t _2020 = _2019 - _2018;
   bool _2021 = _2018 > _2019;
   int64_t _2022 = (int64_t)(_2021 ? _2018 : _2020);
   uint64_t _2023 = (uint64_t)(_2022);
   uint64_t _2024 = _2023;
   uint64_t _2025 = (uint64_t)(2147483647ull);
   int32_t _2026 = halide_error_buffer_allocation_too_large(_ucon, "I_ForeMask", _2024, _2025);
   return _2026;
  }
  int64_t _2027 = (int64_t)(2147483647ll);
  bool _2028 = _1981 <= _2027;
  if (!_2028)
  {
   int64_t _2029 = (int64_t)(2147483647ll);
   int32_t _2030 = halide_error_buffer_extents_too_large(_ucon, "I_ForeMask", _1981, _2029);
   return _2030;
  }
  uint64_t _2031 = (uint64_t)(_1464);
  uint64_t _2032 = (uint64_t)(2147483647ull);
  bool _2033 = _2031 <= _2032;
  if (!_2033)
  {
   uint64_t _2034 = (uint64_t)(_1464);
   uint64_t _2035 = (uint64_t)(2147483647ull);
   int32_t _2036 = halide_error_buffer_allocation_too_large(_ucon, "I_Vlabels", _2034, _2035);
   return _2036;
  }
  int64_t _2037 = (int64_t)(_1467);
  int64_t _2038 = (int64_t)(_1468);
  int64_t _2039 = _2037 * _2038;
  int64_t _2040 = (int64_t)(0ll);
  int64_t _2041 = _2040 - _2039;
  bool _2042 = _2039 > _2040;
  int64_t _2043 = (int64_t)(_2042 ? _2039 : _2041);
  uint64_t _2044 = (uint64_t)(_2043);
  uint64_t _2045 = _2044;
  uint64_t _2046 = (uint64_t)(2147483647ull);
  bool _2047 = _2045 <= _2046;
  if (!_2047)
  {
   int64_t _2048 = (int64_t)(_1467);
   int64_t _2049 = (int64_t)(_1468);
   int64_t _2050 = _2048 * _2049;
   int64_t _2051 = (int64_t)(0ll);
   int64_t _2052 = _2051 - _2050;
   bool _2053 = _2050 > _2051;
   int64_t _2054 = (int64_t)(_2053 ? _2050 : _2052);
   uint64_t _2055 = (uint64_t)(_2054);
   uint64_t _2056 = _2055;
   uint64_t _2057 = (uint64_t)(2147483647ull);
   int32_t _2058 = halide_error_buffer_allocation_too_large(_ucon, "I_Vlabels", _2056, _2057);
   return _2058;
  }
  int64_t _2059 = (int64_t)(2147483647ll);
  bool _2060 = _1984 <= _2059;
  if (!_2060)
  {
   int64_t _2061 = (int64_t)(2147483647ll);
   int32_t _2062 = halide_error_buffer_extents_too_large(_ucon, "I_Vlabels", _1984, _2061);
   return _2062;
  }
  uint64_t _2063 = (uint64_t)(_1474);
  uint64_t _2064 = (uint64_t)(2147483647ull);
  bool _2065 = _2063 <= _2064;
  if (!_2065)
  {
   uint64_t _2066 = (uint64_t)(_1474);
   uint64_t _2067 = (uint64_t)(2147483647ull);
   int32_t _2068 = halide_error_buffer_allocation_too_large(_ucon, "I_back_canny", _2066, _2067);
   return _2068;
  }
  int64_t _2069 = (int64_t)(_1477);
  int64_t _2070 = (int64_t)(_1478);
  int64_t _2071 = _2069 * _2070;
  int64_t _2072 = (int64_t)(0ll);
  int64_t _2073 = _2072 - _2071;
  bool _2074 = _2071 > _2072;
  int64_t _2075 = (int64_t)(_2074 ? _2071 : _2073);
  uint64_t _2076 = (uint64_t)(_2075);
  uint64_t _2077 = _2076;
  uint64_t _2078 = (uint64_t)(2147483647ull);
  bool _2079 = _2077 <= _2078;
  if (!_2079)
  {
   int64_t _2080 = (int64_t)(_1477);
   int64_t _2081 = (int64_t)(_1478);
   int64_t _2082 = _2080 * _2081;
   int64_t _2083 = (int64_t)(0ll);
   int64_t _2084 = _2083 - _2082;
   bool _2085 = _2082 > _2083;
   int64_t _2086 = (int64_t)(_2085 ? _2082 : _2084);
   uint64_t _2087 = (uint64_t)(_2086);
   uint64_t _2088 = _2087;
   uint64_t _2089 = (uint64_t)(2147483647ull);
   int32_t _2090 = halide_error_buffer_allocation_too_large(_ucon, "I_back_canny", _2088, _2089);
   return _2090;
  }
  int64_t _2091 = (int64_t)(2147483647ll);
  bool _2092 = _1987 <= _2091;
  if (!_2092)
  {
   int64_t _2093 = (int64_t)(2147483647ll);
   int32_t _2094 = halide_error_buffer_extents_too_large(_ucon, "I_back_canny", _1987, _2093);
   return _2094;
  }
  uint64_t _2095 = (uint64_t)(_1484);
  uint64_t _2096 = (uint64_t)(2147483647ull);
  bool _2097 = _2095 <= _2096;
  if (!_2097)
  {
   uint64_t _2098 = (uint64_t)(_1484);
   uint64_t _2099 = (uint64_t)(2147483647ull);
   int32_t _2100 = halide_error_buffer_allocation_too_large(_ucon, "I_canny", _2098, _2099);
   return _2100;
  }
  int64_t _2101 = (int64_t)(_1487);
  int64_t _2102 = (int64_t)(_1488);
  int64_t _2103 = _2101 * _2102;
  int64_t _2104 = (int64_t)(0ll);
  int64_t _2105 = _2104 - _2103;
  bool _2106 = _2103 > _2104;
  int64_t _2107 = (int64_t)(_2106 ? _2103 : _2105);
  uint64_t _2108 = (uint64_t)(_2107);
  uint64_t _2109 = _2108;
  uint64_t _2110 = (uint64_t)(2147483647ull);
  bool _2111 = _2109 <= _2110;
  if (!_2111)
  {
   int64_t _2112 = (int64_t)(_1487);
   int64_t _2113 = (int64_t)(_1488);
   int64_t _2114 = _2112 * _2113;
   int64_t _2115 = (int64_t)(0ll);
   int64_t _2116 = _2115 - _2114;
   bool _2117 = _2114 > _2115;
   int64_t _2118 = (int64_t)(_2117 ? _2114 : _2116);
   uint64_t _2119 = (uint64_t)(_2118);
   uint64_t _2120 = _2119;
   uint64_t _2121 = (uint64_t)(2147483647ull);
   int32_t _2122 = halide_error_buffer_allocation_too_large(_ucon, "I_canny", _2120, _2121);
   return _2122;
  }
  int64_t _2123 = (int64_t)(2147483647ll);
  bool _2124 = _1990 <= _2123;
  if (!_2124)
  {
   int64_t _2125 = (int64_t)(2147483647ll);
   int32_t _2126 = halide_error_buffer_extents_too_large(_ucon, "I_canny", _1990, _2125);
   return _2126;
  }
  uint64_t _2127 = (uint64_t)(_1494);
  uint64_t _2128 = (uint64_t)(2147483647ull);
  bool _2129 = _2127 <= _2128;
  if (!_2129)
  {
   uint64_t _2130 = (uint64_t)(_1494);
   uint64_t _2131 = (uint64_t)(2147483647ull);
   int32_t _2132 = halide_error_buffer_allocation_too_large(_ucon, "I_depth", _2130, _2131);
   return _2132;
  }
  int64_t _2133 = (int64_t)(_1497);
  int64_t _2134 = (int64_t)(_1498);
  int64_t _2135 = _2133 * _2134;
  int64_t _2136 = (int64_t)(0ll);
  int64_t _2137 = _2136 - _2135;
  bool _2138 = _2135 > _2136;
  int64_t _2139 = (int64_t)(_2138 ? _2135 : _2137);
  uint64_t _2140 = (uint64_t)(_2139);
  uint64_t _2141 = _2140;
  uint64_t _2142 = (uint64_t)(2147483647ull);
  bool _2143 = _2141 <= _2142;
  if (!_2143)
  {
   int64_t _2144 = (int64_t)(_1497);
   int64_t _2145 = (int64_t)(_1498);
   int64_t _2146 = _2144 * _2145;
   int64_t _2147 = (int64_t)(0ll);
   int64_t _2148 = _2147 - _2146;
   bool _2149 = _2146 > _2147;
   int64_t _2150 = (int64_t)(_2149 ? _2146 : _2148);
   uint64_t _2151 = (uint64_t)(_2150);
   uint64_t _2152 = _2151;
   uint64_t _2153 = (uint64_t)(2147483647ull);
   int32_t _2154 = halide_error_buffer_allocation_too_large(_ucon, "I_depth", _2152, _2153);
   return _2154;
  }
  int64_t _2155 = (int64_t)(2147483647ll);
  bool _2156 = _1993 <= _2155;
  if (!_2156)
  {
   int64_t _2157 = (int64_t)(2147483647ll);
   int32_t _2158 = halide_error_buffer_extents_too_large(_ucon, "I_depth", _1993, _2157);
   return _2158;
  }
  uint64_t _2159 = (uint64_t)(_1504);
  uint64_t _2160 = (uint64_t)(2147483647ull);
  bool _2161 = _2159 <= _2160;
  if (!_2161)
  {
   uint64_t _2162 = (uint64_t)(_1504);
   uint64_t _2163 = (uint64_t)(2147483647ull);
   int32_t _2164 = halide_error_buffer_allocation_too_large(_ucon, "P_Nfaces", _2162, _2163);
   return _2164;
  }
  uint64_t _2165 = (uint64_t)(_1511);
  uint64_t _2166 = (uint64_t)(2147483647ull);
  bool _2167 = _2165 <= _2166;
  if (!_2167)
  {
   uint64_t _2168 = (uint64_t)(_1511);
   uint64_t _2169 = (uint64_t)(2147483647ull);
   int32_t _2170 = halide_error_buffer_allocation_too_large(_ucon, "P_fore_faces", _2168, _2169);
   return _2170;
  }
  int64_t _2171 = (int64_t)(_1514);
  int64_t _2172 = (int64_t)(_1515);
  int64_t _2173 = _2171 * _2172;
  int64_t _2174 = (int64_t)(0ll);
  int64_t _2175 = _2174 - _2173;
  bool _2176 = _2173 > _2174;
  int64_t _2177 = (int64_t)(_2176 ? _2173 : _2175);
  uint64_t _2178 = (uint64_t)(_2177);
  uint64_t _2179 = _2178;
  uint64_t _2180 = (uint64_t)(2147483647ull);
  bool _2181 = _2179 <= _2180;
  if (!_2181)
  {
   int64_t _2182 = (int64_t)(_1514);
   int64_t _2183 = (int64_t)(_1515);
   int64_t _2184 = _2182 * _2183;
   int64_t _2185 = (int64_t)(0ll);
   int64_t _2186 = _2185 - _2184;
   bool _2187 = _2184 > _2185;
   int64_t _2188 = (int64_t)(_2187 ? _2184 : _2186);
   uint64_t _2189 = (uint64_t)(_2188);
   uint64_t _2190 = _2189;
   uint64_t _2191 = (uint64_t)(2147483647ull);
   int32_t _2192 = halide_error_buffer_allocation_too_large(_ucon, "P_fore_faces", _2190, _2191);
   return _2192;
  }
  int64_t _2193 = (int64_t)(2147483647ll);
  bool _2194 = _1996 <= _2193;
  if (!_2194)
  {
   int64_t _2195 = (int64_t)(2147483647ll);
   int32_t _2196 = halide_error_buffer_extents_too_large(_ucon, "P_fore_faces", _1996, _2195);
   return _2196;
  }
  int64_t _2197 = (int64_t)(_1517);
  int64_t _2198 = (int64_t)(_1518);
  int64_t _2199 = _2197 * _2198;
  int64_t _2200 = (int64_t)(0ll);
  int64_t _2201 = _2200 - _2199;
  bool _2202 = _2199 > _2200;
  int64_t _2203 = (int64_t)(_2202 ? _2199 : _2201);
  uint64_t _2204 = (uint64_t)(_2203);
  uint64_t _2205 = _2204;
  uint64_t _2206 = (uint64_t)(2147483647ull);
  bool _2207 = _2205 <= _2206;
  if (!_2207)
  {
   int64_t _2208 = (int64_t)(_1517);
   int64_t _2209 = (int64_t)(_1518);
   int64_t _2210 = _2208 * _2209;
   int64_t _2211 = (int64_t)(0ll);
   int64_t _2212 = _2211 - _2210;
   bool _2213 = _2210 > _2211;
   int64_t _2214 = (int64_t)(_2213 ? _2210 : _2212);
   uint64_t _2215 = (uint64_t)(_2214);
   uint64_t _2216 = _2215;
   uint64_t _2217 = (uint64_t)(2147483647ull);
   int32_t _2218 = halide_error_buffer_allocation_too_large(_ucon, "P_fore_faces", _2216, _2217);
   return _2218;
  }
  int64_t _2219 = (int64_t)(2147483647ll);
  bool _2220 = _1998 <= _2219;
  if (!_2220)
  {
   int64_t _2221 = (int64_t)(2147483647ll);
   int32_t _2222 = halide_error_buffer_extents_too_large(_ucon, "P_fore_faces", _1998, _2221);
   return _2222;
  }
  bool _2223 = !(_1451);
  if (!_2223)
  {
   int32_t _2224 = halide_error_device_dirty_with_no_device_support(_ucon, "Output buffer I_ForeMask");
   return _2224;
  }
  bool _2225 = !(_1461);
  if (!_2225)
  {
   int32_t _2226 = halide_error_device_dirty_with_no_device_support(_ucon, "Output buffer I_Vlabels");
   return _2226;
  }
  bool _2227 = !(_1471);
  if (!_2227)
  {
   int32_t _2228 = halide_error_device_dirty_with_no_device_support(_ucon, "Input buffer I_back_canny");
   return _2228;
  }
  bool _2229 = !(_1481);
  if (!_2229)
  {
   int32_t _2230 = halide_error_device_dirty_with_no_device_support(_ucon, "Input buffer I_canny");
   return _2230;
  }
  bool _2231 = !(_1491);
  if (!_2231)
  {
   int32_t _2232 = halide_error_device_dirty_with_no_device_support(_ucon, "Input buffer I_depth");
   return _2232;
  }
  bool _2233 = !(_1501);
  if (!_2233)
  {
   int32_t _2234 = halide_error_device_dirty_with_no_device_support(_ucon, "Output buffer P_Nfaces");
   return _2234;
  }
  bool _2235 = !(_1508);
  if (!_2235)
  {
   int32_t _2236 = halide_error_device_dirty_with_no_device_support(_ucon, "Output buffer P_fore_faces");
   return _2236;
  }
  auto *_2237 = (void *)(nullptr);
  bool _2238 = _I_ForeMask != _2237;
  if (!_2238)
  {
   int32_t _2239 = halide_error_host_is_null(_ucon, "Output buffer I_ForeMask");
   return _2239;
  }
  auto *_2240 = (void *)(nullptr);
  bool _2241 = _I_Vlabels != _2240;
  if (!_2241)
  {
   int32_t _2242 = halide_error_host_is_null(_ucon, "Output buffer I_Vlabels");
   return _2242;
  }
  auto *_2243 = (void *)(nullptr);
  bool _2244 = _I_back_canny != _2243;
  if (!_2244)
  {
   int32_t _2245 = halide_error_host_is_null(_ucon, "Input buffer I_back_canny");
   return _2245;
  }
  auto *_2246 = (void *)(nullptr);
  bool _2247 = _I_canny != _2246;
  if (!_2247)
  {
   int32_t _2248 = halide_error_host_is_null(_ucon, "Input buffer I_canny");
   return _2248;
  }
  auto *_2249 = (void *)(nullptr);
  bool _2250 = _I_depth != _2249;
  if (!_2250)
  {
   int32_t _2251 = halide_error_host_is_null(_ucon, "Input buffer I_depth");
   return _2251;
  }
  auto *_2252 = (void *)(nullptr);
  bool _2253 = _P_Nfaces != _2252;
  if (!_2253)
  {
   int32_t _2254 = halide_error_host_is_null(_ucon, "Output buffer P_Nfaces");
   return _2254;
  }
  auto *_2255 = (void *)(nullptr);
  bool _2256 = _P_fore_faces != _2255;
  if (!_2256)
  {
   int32_t _2257 = halide_error_host_is_null(_ucon, "Output buffer P_fore_faces");
   return _2257;
  }
  int32_t _2258 = ::halide_cpp_max(_1602, 0);
  int32_t _2259 = ::halide_cpp_min(_2258, _1646);
  int32_t _2260 = _2259 + -31;
  int32_t _2261 = ::halide_cpp_min(_2260, _1647);
  int32_t _2262 = ::halide_cpp_min(_2261, _1643);
  int32_t _2263 = _1646 - _1647;
  int32_t _2264 = _2263 >> 5;
  int32_t _2265 = _2264 * 32;
  int32_t _2266 = _2265 + _1647;
  int32_t _2267 = _2266 + 31;
  int32_t _2268 = ::halide_cpp_min(_2267, _1646);
  int32_t _2269 = _2258 - _1643;
  int32_t _2270 = _2269 >> 5;
  int32_t _2271 = _2270 * 32;
  int32_t _2272 = _2271 + _1643;
  int32_t _2273 = _2272 + 31;
  int32_t _2274 = ::halide_cpp_min(_2258, _2273);
  int32_t _2275 = ::halide_cpp_max(_2268, _2274);
  int32_t _2276 = _2275 - _2262;
  {
   int64_t _2277 = 17;
   int64_t _2278 = _2277 * 17;
   int32_t _2279 = _2276 + 1;
   int64_t _2280 = (_2278 > ((int64_t(1) << 31) - 1)) ? _2278 : (_2278 * _2279);
   if ((_2280 > ((int64_t(1) << 31) - 1)) || ((_2280 * sizeof(uint8_t )) > ((int64_t(1) << 31) - 1)))
   {
    halide_error(_ucon, "32-bit signed overflow computing size of allocation patched_canny\n");
    return -1;
   } // overflow test patched_canny
   int64_t _2281 = _2280;
   uint8_t *_patched_canny = (uint8_t  *)halide_malloc(_ucon, sizeof(uint8_t )*_2281);
   if (!((_patched_canny != nullptr) || (_2281 == 0)))
   {
    int32_t _2282 = halide_error_out_of_memory(_ucon);
    return _2282;
   }
   HalideFreeHelper<halide_free> _patched_canny_free(_ucon, _patched_canny);
   int32_t _2283 = _2276 + 1;
   struct halide_dimension_t s67[3] = {
    {0, 17, 1, 0},
    {0, 17, 17, 0},
    {_2262, _2283, 289, 0},
   };
   auto *_2284 = s67;
   auto _t3858 = _2284;
   halide_maybe_unused(_t3858);
   halide_buffer_t b26;
   auto *_2285 = &b26;
   uint64_t _2286 = (uint64_t)(0ull);
   auto *_2287 = (struct halide_device_interface_t *)(nullptr);
   auto *_2288 = _halide_buffer_init(_2285, _t3858, _patched_canny, _2286, _2287, 1, 8, 3, _t3858, _2286);
   auto _patched_canny_buffer = _2288;
   halide_maybe_unused(_patched_canny_buffer);
   int32_t _2289 = ::halide_cpp_max(_1648, 0);
   int32_t _2290 = _2289 + -31;
   int32_t _2291 = ::halide_cpp_min(_2290, _1647);
   int32_t _2292 = _2289 - _1647;
   int32_t _2293 = _2292 >> 5;
   int32_t _2294 = _2293 * 32;
   int32_t _2295 = _2294 + _1647;
   int32_t _2296 = _2295 + 31;
   int32_t _2297 = ::halide_cpp_min(_2289, _2296);
   {
    int64_t _2298 = 17;
    int64_t _2299 = _2298 * 17;
    int32_t _2300 = _2297 - _2291;
    int32_t _2301 = _2300 + 1;
    int64_t _2302 = (_2299 > ((int64_t(1) << 31) - 1)) ? _2299 : (_2299 * _2301);
    if ((_2302 > ((int64_t(1) << 31) - 1)) || ((_2302 * sizeof(int32_t )) > ((int64_t(1) << 31) - 1)))
    {
     halide_error(_ucon, "32-bit signed overflow computing size of allocation patch_coords\n");
     return -1;
    } // overflow test patch_coords
    int64_t _2303 = _2302;
    int32_t *_patch_coords = (int32_t  *)halide_malloc(_ucon, sizeof(int32_t )*_2303);
    if (!((_patch_coords != nullptr) || (_2303 == 0)))
    {
     int32_t _2304 = halide_error_out_of_memory(_ucon);
     return _2304;
    }
    HalideFreeHelper<halide_free> _patch_coords_free(_ucon, _patch_coords);
    int32_t _2305 = _2297 - _2291;
    int32_t _2306 = _2305 + 1;
    struct halide_dimension_t s68[3] = {
     {0, 17, 1, 0},
     {0, 17, 17, 0},
     {_2291, _2306, 289, 0},
    };
    auto *_2307 = s68;
    auto _t3860 = _2307;
    halide_maybe_unused(_t3860);
    halide_buffer_t b27;
    auto *_2308 = &b27;
    uint64_t _2309 = (uint64_t)(0ull);
    auto *_2310 = (struct halide_device_interface_t *)(nullptr);
    auto *_2311 = _halide_buffer_init(_2308, _t3860, _patch_coords, _2309, _2310, 0, 32, 3, _t3860, _2309);
    auto _patch_coords_buffer = _2311;
    halide_maybe_unused(_patch_coords_buffer);
    int32_t _2312 = ::halide_cpp_max(_1602, 0);
    int32_t _2313 = _2312 + -31;
    int32_t _2314 = ::halide_cpp_min(_2313, _1643);
    int32_t _2315 = _2312 - _1643;
    int32_t _2316 = _2315 >> 5;
    int32_t _2317 = _2316 * 32;
    int32_t _2318 = _2317 + _1643;
    int32_t _2319 = _2318 + 31;
    int32_t _2320 = ::halide_cpp_min(_2312, _2319);
    int32_t _2321 = _2320 - _2314;
    {
     int64_t _2322 = 17;
     int64_t _2323 = _2322 * 17;
     int32_t _2324 = _2321 + 1;
     int64_t _2325 = (_2323 > ((int64_t(1) << 31) - 1)) ? _2323 : (_2323 * _2324);
     if ((_2325 > ((int64_t(1) << 31) - 1)) || ((_2325 * sizeof(uint8_t )) > ((int64_t(1) << 31) - 1)))
     {
      halide_error(_ucon, "32-bit signed overflow computing size of allocation patched_depth\n");
      return -1;
     } // overflow test patched_depth
     int64_t _2326 = _2325;
     uint8_t *_patched_depth = (uint8_t  *)halide_malloc(_ucon, sizeof(uint8_t )*_2326);
     if (!((_patched_depth != nullptr) || (_2326 == 0)))
     {
      int32_t _2327 = halide_error_out_of_memory(_ucon);
      return _2327;
     }
     HalideFreeHelper<halide_free> _patched_depth_free(_ucon, _patched_depth);
     int32_t _2328 = _2321 + 1;
     struct halide_dimension_t s69[3] = {
      {0, 17, 1, 0},
      {0, 17, 17, 0},
      {_2314, _2328, 289, 0},
     };
     auto *_2329 = s69;
     auto _t3862 = _2329;
     halide_maybe_unused(_t3862);
     halide_buffer_t b28;
     auto *_2330 = &b28;
     uint64_t _2331 = (uint64_t)(0ull);
     auto *_2332 = (struct halide_device_interface_t *)(nullptr);
     auto *_2333 = _halide_buffer_init(_2330, _t3862, _patched_depth, _2331, _2332, 1, 8, 3, _t3862, _2331);
     auto _patched_depth_buffer = _2333;
     halide_maybe_unused(_patched_depth_buffer);
     int32_t _2334 = ::halide_cpp_max(_1602, 0);
     int32_t _2335 = _2334 + -31;
     int32_t _2336 = ::halide_cpp_min(_2335, _1643);
     {
      int64_t _2337 = 17;
      int64_t _2338 = _2337 * 17;
      int32_t _2339 = _2321 + 1;
      int64_t _2340 = (_2338 > ((int64_t(1) << 31) - 1)) ? _2338 : (_2338 * _2339);
      if ((_2340 > ((int64_t(1) << 31) - 1)) || ((_2340 * sizeof(uint8_t )) > ((int64_t(1) << 31) - 1)))
      {
       halide_error(_ucon, "32-bit signed overflow computing size of allocation patched_b_canny\n");
       return -1;
      } // overflow test patched_b_canny
      int64_t _2341 = _2340;
      uint8_t *_patched_b_canny = (uint8_t  *)halide_malloc(_ucon, sizeof(uint8_t )*_2341);
      if (!((_patched_b_canny != nullptr) || (_2341 == 0)))
      {
       int32_t _2342 = halide_error_out_of_memory(_ucon);
       return _2342;
      }
      HalideFreeHelper<halide_free> _patched_b_canny_free(_ucon, _patched_b_canny);
      int32_t _2343 = ::halide_cpp_max(_1648, _1646);
      int32_t _2344 = _2343 - _1647;
      int32_t _2345 = ::halide_cpp_max(_1602, 0);
      int32_t _2346 = _2345 - _1643;
      int32_t _2347 = ::halide_cpp_max(_2344, _2346);
      // produce patched_b_canny
      // produce patched_depth
      // produce patch_coords
      // produce patched_canny
      int32_t _2348 = _1646 - _1647;
      int32_t _2349 = ::halide_cpp_min(_2348, _2346);
      int32_t _2350 = ::halide_cpp_max(_1648, 0);
      int32_t _2351 = _2350 - _1647;
      int32_t _2352 = ::halide_cpp_min(_2349, _2351);
      int32_t _2353 = ::halide_cpp_min(_2352, _2347);
      int32_t _2354 = ::halide_cpp_max(_2348, _2346);
      int32_t _2355 = ::halide_cpp_max(_2354, _2351);
      int32_t _2356 = ::halide_cpp_max(_2355, _2353);
      int32_t _2357 = ::halide_cpp_min(_2356, _2347);
      int32_t _2358 = _2357 >> 5;
      int32_t _2359 = ::halide_cpp_max(_2358, -1);
      int32_t _2360 = _2353 >> 5;
      int32_t _2361 = ::halide_cpp_max(_2360, -1);
      int32_t _2362 = _2351 >> 5;
      int32_t _2363 = _2346 >> 5;
      int32_t _2364 = _2348 >> 5;
      int32_t _2365 = _1496 * _1498;
      int32_t _2366 = _2365 + _1493;
      int32_t _2367 = _1486 * _1488;
      int32_t _2368 = _2367 + _1483;
      int32_t _2369 = _1476 * _1478;
      int32_t _2370 = _2369 + _1473;
      float _2371 = (float)(_1484);
      float _2372 = float_from_bits(1031798784 /* 0.0625 */);
      float _2373 = _2371 * _2372;
      float _2374 = floor_f32(_2373);
      int32_t _2375 = (int32_t)(_2374);
      float _2376 = (float)(_2375);
      struct {
       void * f_0;
       void * f_1;
       void * f_2;
       void * f_3;
       void * f_4;
       void * f_5;
       void * f_6;
       int32_t f_7;
       int32_t f_8;
       int32_t f_9;
       int32_t f_10;
       int32_t f_11;
       int32_t f_12;
       int32_t f_13;
       int32_t f_14;
       int32_t f_15;
       int32_t f_16;
       int32_t f_17;
       int32_t f_18;
       int32_t f_19;
       float f_20;
       int32_t f_21;
       int32_t f_22;
       int32_t f_23;
       int32_t f_24;
       int32_t f_25;
       int32_t f_26;
       int32_t f_27;
       int32_t f_28;
      } s70 = {
       _I_back_canny,
       _I_canny,
       _I_depth,
       _patch_coords,
       _patched_b_canny,
       _patched_canny,
       _patched_depth,
       _1478,
       _1484,
       _1487,
       _1488,
       _1498,
       _1643,
       _2291,
       _2336,
       _2262,
       _1646,
       _1647,
       _2314,
       _2361,
       _2376,
       _2368,
       _2370,
       _2366,
       _2364,
       _2363,
       _2362,
       _2345,
       _2350
      };
      auto *_2377 = (&s70);
      auto _parallel_closure = _2377;
      halide_maybe_unused(_parallel_closure);
      int32_t _2378 = _2359 + 1;
      auto *_2379 = (uint8_t *)(_parallel_closure);
      int32_t _2380 = halide_do_par_for(_ucon, ::foreground_mesh_verts_par_for_patched_canny_s0_p_fused_v14, 0, _2378, _2379);
      bool _2381 = _2380 == 0;
      if (!_2381)
      {
       return _2380;
      }
      int32_t _2382 = ::halide_cpp_max(_1602, 0);
      int32_t _2383 = _2382 + -31;
      int32_t _2384 = ::halide_cpp_min(_2383, _1643);
      {
       int32_t _2385 = _2321 + 1;
       int64_t _2386 = _2385;
       if ((_2386 > ((int64_t(1) << 31) - 1)) || ((_2386 * sizeof(float )) > ((int64_t(1) << 31) - 1)))
       {
        halide_error(_ucon, "32-bit signed overflow computing size of allocation sum_p_canny\n");
        return -1;
       } // overflow test sum_p_canny
       int64_t _2387 = _2386;
       float *_sum_p_canny = (float  *)halide_malloc(_ucon, sizeof(float )*_2387);
       if (!((_sum_p_canny != nullptr) || (_2387 == 0)))
       {
        int32_t _2388 = halide_error_out_of_memory(_ucon);
        return _2388;
       }
       HalideFreeHelper<halide_free> _sum_p_canny_free(_ucon, _sum_p_canny);
       int32_t _2389 = ::halide_cpp_max(_1602, 0);
       int32_t _2390 = _2389 + -31;
       int32_t _2391 = ::halide_cpp_min(_2390, _1643);
       {
        int32_t _2392 = _2321 + 1;
        int64_t _2393 = _2392;
        if ((_2393 > ((int64_t(1) << 31) - 1)) || ((_2393 * sizeof(float )) > ((int64_t(1) << 31) - 1)))
        {
         halide_error(_ucon, "32-bit signed overflow computing size of allocation sum_p_b_canny\n");
         return -1;
        } // overflow test sum_p_b_canny
        int64_t _2394 = _2393;
        float *_sum_p_b_canny = (float  *)halide_malloc(_ucon, sizeof(float )*_2394);
        if (!((_sum_p_b_canny != nullptr) || (_2394 == 0)))
        {
         int32_t _2395 = halide_error_out_of_memory(_ucon);
         return _2395;
        }
        HalideFreeHelper<halide_free> _sum_p_b_canny_free(_ucon, _sum_p_b_canny);
        // produce sum_p_b_canny
        // produce sum_p_canny
        // consume patched_b_canny
        // consume patched_canny
        int32_t _2396 = ::halide_cpp_max(_1602, 0);
        int32_t _2397 = _2396 - _1643;
        int32_t _2398 = _2397 >> 5;
        int32_t _2399 = ::halide_cpp_max(_2398, -1);
        struct {
         void * f_0;
         void * f_1;
         void * f_2;
         void * f_3;
         int32_t f_4;
         int32_t f_5;
         int32_t f_6;
         int32_t f_7;
         int32_t f_8;
         int32_t f_9;
        } s71 = {
         _patched_b_canny,
         _patched_canny,
         _sum_p_b_canny,
         _sum_p_canny,
         _1643,
         _2336,
         _2262,
         _2391,
         _2384,
         _2396
        };
        auto *_2400 = (&s71);
        auto _parallel_closure__1 = _2400;
        halide_maybe_unused(_parallel_closure__1);
        int32_t _2401 = _2399 + 1;
        auto *_2402 = (uint8_t *)(_parallel_closure__1);
        int32_t _2403 = halide_do_par_for(_ucon, ::foreground_mesh_verts_par_for_sum_p_canny_s0_p_fused_v14, 0, _2401, _2402);
        bool _2404 = _2403 == 0;
        if (!_2404)
        {
         return _2403;
        }
        int32_t _2405 = ::halide_cpp_max(_1602, 0);
        int32_t _2406 = _2405 + -31;
        int32_t _2407 = ::halide_cpp_min(_2406, _1643);
        {
         int32_t _2408 = _2321 + 1;
         int64_t _2409 = _2408;
         if ((_2409 > ((int64_t(1) << 31) - 1)) || ((_2409 * sizeof(float )) > ((int64_t(1) << 31) - 1)))
         {
          halide_error(_ucon, "32-bit signed overflow computing size of allocation mean_depth\n");
          return -1;
         } // overflow test mean_depth
         int64_t _2410 = _2409;
         float *_mean_depth = (float  *)halide_malloc(_ucon, sizeof(float )*_2410);
         if (!((_mean_depth != nullptr) || (_2410 == 0)))
         {
          int32_t _2411 = halide_error_out_of_memory(_ucon);
          return _2411;
         }
         HalideFreeHelper<halide_free> _mean_depth_free(_ucon, _mean_depth);
         int32_t _2412 = _2321 + 1;
         struct halide_dimension_t s72[1] = {
          {_2407, _2412, 1, 0},
         };
         auto *_2413 = s72;
         auto _t3866 = _2413;
         halide_maybe_unused(_t3866);
         halide_buffer_t b29;
         auto *_2414 = &b29;
         uint64_t _2415 = (uint64_t)(0ull);
         auto *_2416 = (struct halide_device_interface_t *)(nullptr);
         auto *_2417 = _halide_buffer_init(_2414, _t3866, _mean_depth, _2415, _2416, 2, 32, 1, _t3866, _2415);
         auto _mean_depth_buffer = _2417;
         halide_maybe_unused(_mean_depth_buffer);
         {
          int32_t _2418 = _2321 + 1;
          int64_t _2419 = _2418;
          if ((_2419 > ((int64_t(1) << 31) - 1)) || ((_2419 * sizeof(float )) > ((int64_t(1) << 31) - 1)))
          {
           halide_error(_ucon, "32-bit signed overflow computing size of allocation mean_b_depth\n");
           return -1;
          } // overflow test mean_b_depth
          int64_t _2420 = _2419;
          float *_mean_b_depth = (float  *)halide_malloc(_ucon, sizeof(float )*_2420);
          if (!((_mean_b_depth != nullptr) || (_2420 == 0)))
          {
           int32_t _2421 = halide_error_out_of_memory(_ucon);
           return _2421;
          }
          HalideFreeHelper<halide_free> _mean_b_depth_free(_ucon, _mean_b_depth);
          int32_t _2422 = _2321 + 1;
          struct halide_dimension_t s73[1] = {
           {_2407, _2422, 1, 0},
          };
          auto *_2423 = s73;
          auto _t3867 = _2423;
          halide_maybe_unused(_t3867);
          halide_buffer_t b30;
          auto *_2424 = &b30;
          uint64_t _2425 = (uint64_t)(0ull);
          auto *_2426 = (struct halide_device_interface_t *)(nullptr);
          auto *_2427 = _halide_buffer_init(_2424, _t3867, _mean_b_depth, _2425, _2426, 2, 32, 1, _t3867, _2425);
          auto _mean_b_depth_buffer = _2427;
          halide_maybe_unused(_mean_b_depth_buffer);
          // produce mean_b_depth
          // produce mean_depth
          // consume sum_p_b_canny
          // consume sum_p_canny
          // consume patched_b_canny
          // consume patched_depth
          // consume patched_canny
          int32_t _2428 = ::halide_cpp_max(_1602, 0);
          int32_t _2429 = _2428 - _1643;
          int32_t _2430 = _2429 >> 5;
          int32_t _2431 = ::halide_cpp_max(_2430, -1);
          struct {
           void * f_0;
           void * f_1;
           void * f_2;
           void * f_3;
           void * f_4;
           void * f_5;
           void * f_6;
           int32_t f_7;
           int32_t f_8;
           int32_t f_9;
           int32_t f_10;
           int32_t f_11;
           int32_t f_12;
           int32_t f_13;
           int32_t f_14;
          } s74 = {
           _mean_b_depth,
           _mean_depth,
           _patched_b_canny,
           _patched_canny,
           _patched_depth,
           _sum_p_b_canny,
           _sum_p_canny,
           _1643,
           _2407,
           _2336,
           _2262,
           _2314,
           _2391,
           _2384,
           _2428
          };
          auto *_2432 = (&s74);
          auto _parallel_closure__2 = _2432;
          halide_maybe_unused(_parallel_closure__2);
          int32_t _2433 = _2431 + 1;
          auto *_2434 = (uint8_t *)(_parallel_closure__2);
          int32_t _2435 = halide_do_par_for(_ucon, ::foreground_mesh_verts_par_for_mean_depth_s0_p_fused_v14, 0, _2433, _2434);
          bool _2436 = _2435 == 0;
          if (!_2436)
          {
           return _2435;
          }
          _patched_b_canny_free.free();
          _sum_p_canny_free.free();
          _sum_p_b_canny_free.free();
          float _2437 = (float)(_1484);
          float _2438 = float_from_bits(1031798784 /* 0.0625 */);
          float _2439 = _2437 * _2438;
          float _2440 = floor_f32(_2439);
          int32_t _2441 = (int32_t)(_2440);
          bool _2442 = _2441 < 0;
          int32_t _2443 = _1457 + _1456;
          int32_t _2444 = _2443 + -1;
          float _2445 = (float)(_2444);
          float _2446 = _2445 * _2438;
          float _2447 = floor_f32(_2446);
          int32_t _2448 = (int32_t)(_2447);
          float _2449 = (float)(_1456);
          float _2450 = _2449 * _2438;
          float _2451 = floor_f32(_2450);
          int32_t _2452 = (int32_t)(_2451);
          int32_t _2453 = (int32_t)(_2442 ? _2448 : _2452);
          int32_t _2454 = _2453 * _2441;
          float _2455 = (float)(_1453);
          float _2456 = _2455 * _2438;
          float _2457 = floor_f32(_2456);
          int32_t _2458 = (int32_t)(_2457);
          int32_t _2459 = _2454 + _2458;
          int32_t _2460 = _2459 - _2441;
          int32_t _2461 = ::halide_cpp_max(_2460, 0);
          int32_t _2462 = ::halide_cpp_max(_1543, 1);
          int32_t _2463 = _2462 + -1;
          float _2464 = (float)(_2463);
          float _2465 = _2464 * _2438;
          float _2466 = floor_f32(_2465);
          int32_t _2467 = (int32_t)(_2466);
          float _2468 = (float)(_1552);
          float _2469 = _2468 * _2438;
          float _2470 = floor_f32(_2469);
          int32_t _2471 = (int32_t)(_2470);
          int32_t _2472 = (int32_t)(_2442 ? _2467 : _2471);
          int32_t _2473 = _2472 * _2441;
          float _2474 = (float)(_1463);
          float _2475 = _2474 * _2438;
          float _2476 = floor_f32(_2475);
          int32_t _2477 = (int32_t)(_2476);
          int32_t _2478 = _2473 + _2477;
          int32_t _2479 = _2478 - _2441;
          int32_t _2480 = ::halide_cpp_max(_2479, 0);
          int32_t _2481 = ::halide_cpp_max(_2441, 0);
          int32_t _2482 = ::halide_cpp_min(_1643, _2478);
          int32_t _2483 = ::halide_cpp_max(_2478, 1);
          int32_t _2484 = _2483 + -1;
          int32_t _2485 = ::halide_cpp_min(_2482, _2484);
          int32_t _2486 = ::halide_cpp_min(_2480, _2485);
          int32_t _2487 = _2478 - _2481;
          int32_t _2488 = ::halide_cpp_max(_2487, 1);
          int32_t _2489 = _2488 + -1;
          int32_t _2490 = ::halide_cpp_min(_2486, _2489);
          int32_t _2491 = ::halide_cpp_min(_2490, _2478);
          int32_t _2492 = ::halide_cpp_min(_2480, _2491);
          int32_t _2493 = ::halide_cpp_min(_2492, _2478);
          int32_t _2494 = ::halide_cpp_min(_2493, _2459);
          int32_t _2495 = ::halide_cpp_max(_2459, 1);
          int32_t _2496 = _2495 + -1;
          int32_t _2497 = ::halide_cpp_min(_2494, _2496);
          int32_t _2498 = ::halide_cpp_min(_2461, _2497);
          int32_t _2499 = _2459 - _2481;
          int32_t _2500 = ::halide_cpp_max(_2499, 1);
          int32_t _2501 = _2500 + -1;
          int32_t _2502 = ::halide_cpp_min(_2498, _2501);
          int32_t _2503 = ::halide_cpp_min(_2502, _2459);
          int32_t _2504 = ::halide_cpp_min(_2461, _2503);
          int32_t _2505 = ::halide_cpp_min(_2504, _2459);
          int32_t _2506 = ::halide_cpp_min(_2505, _1643);
          int32_t _2507 = (int32_t)(_2442 ? _2471 : _2467);
          int32_t _2508 = _2507 * _2441;
          int32_t _2509 = ::halide_cpp_max(_1560, 1);
          int32_t _2510 = _2509 + -1;
          float _2511 = (float)(_2510);
          float _2512 = _2511 * _2438;
          float _2513 = floor_f32(_2512);
          int32_t _2514 = (int32_t)(_2513);
          int32_t _2515 = _2508 + _2514;
          int32_t _2516 = _2515 - _2441;
          int32_t _2517 = (int32_t)(_2442 ? _2452 : _2448);
          int32_t _2518 = _2517 * _2441;
          int32_t _2519 = _1454 + _1453;
          int32_t _2520 = _2519 + -1;
          float _2521 = (float)(_2520);
          float _2522 = _2521 * _2438;
          float _2523 = floor_f32(_2522);
          int32_t _2524 = (int32_t)(_2523);
          int32_t _2525 = _2518 + _2524;
          int32_t _2526 = _2525 - _2441;
          int32_t _2527 = ::halide_cpp_max(_1602, _2515);
          int32_t _2528 = ::halide_cpp_max(_2515, 1);
          int32_t _2529 = _2528 + -1;
          int32_t _2530 = ::halide_cpp_max(_2527, _2529);
          int32_t _2531 = ::halide_cpp_max(_2530, _2516);
          int32_t _2532 = ::halide_cpp_max(_2516, 1);
          int32_t _2533 = _2532 + -1;
          int32_t _2534 = ::halide_cpp_max(_2531, _2533);
          int32_t _2535 = ::halide_cpp_max(_2534, _2525);
          int32_t _2536 = ::halide_cpp_max(_2525, 1);
          int32_t _2537 = _2536 + -1;
          int32_t _2538 = ::halide_cpp_max(_2535, _2537);
          int32_t _2539 = ::halide_cpp_max(_2538, _2526);
          int32_t _2540 = ::halide_cpp_max(_2526, 1);
          int32_t _2541 = _2540 + -1;
          int32_t _2542 = ::halide_cpp_max(_2539, _2541);
          int32_t _2543 = ::halide_cpp_max(_2542, _1602);
          int32_t _2544 = _2543 - _2506;
          int32_t _2545 = _2544 + 1;
          {
           int64_t _2546 = 17;
           int64_t _2547 = _2546 * 17;
           int64_t _2548 = (_2547 > ((int64_t(1) << 31) - 1)) ? _2547 : (_2547 * _2545);
           if ((_2548 > ((int64_t(1) << 31) - 1)) || ((_2548 * sizeof(int32_t )) > ((int64_t(1) << 31) - 1)))
           {
            halide_error(_ucon, "32-bit signed overflow computing size of allocation labeled.0\n");
            return -1;
           } // overflow test labeled.0
           int64_t _2549 = _2548;
           int32_t *_labeled_0 = (int32_t  *)halide_malloc(_ucon, sizeof(int32_t )*_2549);
           if (!((_labeled_0 != nullptr) || (_2549 == 0)))
           {
            int32_t _2550 = halide_error_out_of_memory(_ucon);
            return _2550;
           }
           HalideFreeHelper<halide_free> _labeled_0_free(_ucon, _labeled_0);
           struct halide_dimension_t s75[3] = {
            {0, 17, 1, 0},
            {0, 17, 17, 0},
            {_2506, _2545, 289, 0},
           };
           auto *_2551 = s75;
           auto _t3890 = _2551;
           halide_maybe_unused(_t3890);
           halide_buffer_t b31;
           auto *_2552 = &b31;
           uint64_t _2553 = (uint64_t)(0ull);
           auto *_2554 = (struct halide_device_interface_t *)(nullptr);
           auto *_2555 = _halide_buffer_init(_2552, _t3890, _labeled_0, _2553, _2554, 0, 32, 3, _t3890, _2553);
           auto _labeled_0_buffer = _2555;
           halide_maybe_unused(_labeled_0_buffer);
           {
            int64_t _2556 = 17;
            int64_t _2557 = _2556 * 17;
            int64_t _2558 = (_2557 > ((int64_t(1) << 31) - 1)) ? _2557 : (_2557 * _2545);
            if ((_2558 > ((int64_t(1) << 31) - 1)) || ((_2558 * sizeof(int32_t )) > ((int64_t(1) << 31) - 1)))
            {
             halide_error(_ucon, "32-bit signed overflow computing size of allocation labeled.1\n");
             return -1;
            } // overflow test labeled.1
            int64_t _2559 = _2558;
            int32_t *_labeled_1 = (int32_t  *)halide_malloc(_ucon, sizeof(int32_t )*_2559);
            if (!((_labeled_1 != nullptr) || (_2559 == 0)))
            {
             int32_t _2560 = halide_error_out_of_memory(_ucon);
             return _2560;
            }
            HalideFreeHelper<halide_free> _labeled_1_free(_ucon, _labeled_1);
            struct halide_dimension_t s76[3] = {
             {0, 17, 1, 0},
             {0, 17, 17, 0},
             {_2506, _2545, 289, 0},
            };
            auto *_2561 = s76;
            auto _t3891 = _2561;
            halide_maybe_unused(_t3891);
            halide_buffer_t b32;
            auto *_2562 = &b32;
            uint64_t _2563 = (uint64_t)(0ull);
            auto *_2564 = (struct halide_device_interface_t *)(nullptr);
            auto *_2565 = _halide_buffer_init(_2562, _t3891, _labeled_1, _2563, _2564, 0, 32, 3, _t3891, _2563);
            auto _labeled_1_buffer = _2565;
            halide_maybe_unused(_labeled_1_buffer);
            // produce labeled
            // consume mean_b_depth
            // consume mean_depth
            // consume patched_depth
            // consume patch_coords
            // consume patched_canny
            int32_t _2566 = ::halide_cpp_max(_1602, 0);
            int32_t _2567 = _2566 - _1643;
            int32_t _2568 = _2567 + 1;
            int32_t _2569 = _2568 >> 5;
            int32_t _2570 = ::halide_cpp_max(_2569, 0);
            int32_t _2571 = _2567 >> 5;
            int32_t _2572 = ::halide_cpp_max(_1648, 0);
            int32_t _2573 = _2572 - _1647;
            int32_t _2574 = _1646 - _1647;
            struct {
             struct halide_buffer_t * f_0;
             struct halide_buffer_t * f_1;
             struct halide_buffer_t * f_2;
             struct halide_buffer_t * f_3;
             struct halide_buffer_t * f_4;
             struct halide_buffer_t * f_5;
             struct halide_buffer_t * f_6;
             int32_t f_7;
             int32_t f_8;
             int32_t f_9;
             int32_t f_10;
             int32_t f_11;
             int32_t f_12;
             int32_t f_13;
            } s77 = {
             _labeled_0_buffer,
             _labeled_1_buffer,
             _mean_b_depth_buffer,
             _mean_depth_buffer,
             _patch_coords_buffer,
             _patched_canny_buffer,
             _patched_depth_buffer,
             _1643,
             _1647,
             _2570,
             _2573,
             _2574,
             _2566,
             _2567
            };
            auto *_2575 = (&s77);
            auto _parallel_closure__3 = _2575;
            halide_maybe_unused(_parallel_closure__3);
            int32_t _2576 = _2571 + 1;
            auto *_2577 = (uint8_t *)(_parallel_closure__3);
            int32_t _2578 = halide_do_par_for(_ucon, ::foreground_mesh_verts_par_for_labeled_s0_p_v14, 0, _2576, _2577);
            bool _2579 = _2578 == 0;
            if (!_2579)
            {
             return _2578;
            }
            _patched_depth_free.free();
            _mean_depth_free.free();
            _mean_b_depth_free.free();
            // produce I_Vlabels
            // consume labeled
            int32_t _2580 = ::halide_cpp_max(_1543, 1);
            int32_t _2581 = _2580 - _1552;
            int32_t _2582 = ::halide_cpp_max(_1560, 1);
            int32_t _2583 = _2582 - _1463;
            int32_t _2584 = _1466 * _1468;
            int32_t _2585 = 0 - _2584;
            float _2586 = (float)(_1487);
            float _2587 = float_from_bits(1031798784 /* 0.0625 */);
            float _2588 = _2586 * _2587;
            float _2589 = floor_f32(_2588);
            int32_t _2590 = (int32_t)(_2589);
            float _2591 = (float)(_1484);
            float _2592 = _2591 * _2587;
            float _2593 = floor_f32(_2592);
            int32_t _2594 = (int32_t)(_2593);
            for (int _I_Vlabels_s0_y_rebased = 0; _I_Vlabels_s0_y_rebased < 0 + _2581; _I_Vlabels_s0_y_rebased++)
            {
             int32_t _2595 = _1552 + _I_Vlabels_s0_y_rebased;
             bool _2596 = 0 < _2595;
             int32_t _2597 = _1487 + -1;
             bool _2598 = _2595 < _2597;
             bool _2599 = _2596 && _2598;
             int32_t _2600 = _2595 & 15;
             bool _2601 = _2600 == 0;
             bool _2602 = _2599 && _2601;
             int32_t _2603 = _2594 * _2590;
             float _2604 = (float)(_2595);
             float _2605 = float_from_bits(1031798784 /* 0.0625 */);
             float _2606 = _2604 * _2605;
             float _2607 = floor_f32(_2606);
             int32_t _2608 = (int32_t)(_2607);
             int32_t _2609 = _2594 * _2608;
             for (int _I_Vlabels_s0_x_rebased = 0; _I_Vlabels_s0_x_rebased < 0 + _2583; _I_Vlabels_s0_x_rebased++)
             {
              int32_t _2610 = _1463 + _I_Vlabels_s0_x_rebased;
              bool _2611 = 0 < _2610;
              int32_t _2612 = _1484 + -1;
              bool _2613 = _2610 < _2612;
              bool _2614 = _2611 && _2613;
              int32_t _2615 = _2610 & 15;
              bool _2616 = _2615 == 0;
              bool _2617 = _2614 && _2616;
              float _2618 = (float)(_2610);
              float _2619 = float_from_bits(1031798784 /* 0.0625 */);
              float _2620 = _2618 * _2619;
              float _2621 = floor_f32(_2620);
              int32_t _2622 = (int32_t)(_2621);
              int32_t _2623 = _2609 + _2622;
              bool _2624 = 0 < _2623;
              int32_t _2625 = _2603 + -1;
              bool _2626 = _2623 < _2625;
              bool _2627 = _2624 && _2626;
              int32_t _2628 = ::halide_cpp_max(_2623, 1);
              int32_t _2629 = _2628 - _2506;
              int32_t _2630 = _2623 - _2594;
              int32_t _2631 = _2623 - _2506;
              int32_t _2632 = ::halide_cpp_max(_2630, 0);
              int32_t _2633 = _2632 - _2506;
              int32_t _2634 = _2595 & 15;
              int32_t _2635 = _2631 * 17;
              int32_t _2636 = _2635 + _2634;
              int32_t _2637 = _2629 * 289;
              int32_t _2638 = _2637 + -273;
              int32_t _2639 = _labeled_0[_2638];
              int32_t _2640 = ::halide_cpp_max(_2630, 1);
              int32_t _2641 = _2640 - _2506;
              int32_t _2642 = _2641 * 289;
              int32_t _2643 = _2642 + -1;
              int32_t _2644 = _labeled_0[_2643];
              int32_t _2645 = _2631 * 289;
              int32_t _2646 = _labeled_0[_2645];
              int32_t _2647 = _2633 * 289;
              int32_t _2648 = _2647 + 272;
              int32_t _2649 = _labeled_0[_2648];
              int32_t _2650 = ::halide_cpp_max(_2646, _2649);
              int32_t _2651 = ::halide_cpp_max(_2644, _2650);
              int32_t _2652 = ::halide_cpp_max(_2639, _2651);
              bool _2653 = 0 < _2652;
              int32_t _2654 = (int32_t)(_2653 ? 1 : 0);
              int32_t _2655 = _2636 * 17;
              int32_t _2656 = _2655 + _2615;
              int32_t _2657 = _labeled_0[_2656];
              bool _2658 = _2617 && _2602;
              bool _2659 = _2658 && _2627;
              int32_t _2660 = (int32_t)(_2659 ? _2654 : _2657);
              int32_t _2661 = _2645 + _2615;
              int32_t _2662 = _labeled_0[_2661];
              int32_t _2663 = _2647 + _2615;
              int32_t _2664 = _2663 + 272;
              int32_t _2665 = _labeled_0[_2664];
              int32_t _2666 = ::halide_cpp_max(_2662, _2665);
              bool _2667 = 0 < _2666;
              int32_t _2668 = (int32_t)(_2667 ? 1 : 0);
              bool _2669 = _2627 && _2602;
              bool _2670 = !(_2669);
              bool _2671 = _2670 || _2617;
              int32_t _2672 = (int32_t)(_2671 ? _2660 : _2668);
              int32_t _2673 = _labeled_0[_2655];
              int32_t _2674 = _2629 * 17;
              int32_t _2675 = _2674 + _2634;
              int32_t _2676 = _2675 * 17;
              int32_t _2677 = _2676 + -273;
              int32_t _2678 = _labeled_0[_2677];
              int32_t _2679 = ::halide_cpp_max(_2673, _2678);
              bool _2680 = 0 < _2679;
              int32_t _2681 = (int32_t)(_2680 ? 1 : 0);
              bool _2682 = _2617 && _2627;
              bool _2683 = !(_2682);
              bool _2684 = _2683 || _2602;
              int32_t _2685 = (int32_t)(_2684 ? _2672 : _2681);
              int32_t _2686 = _1468 * _2595;
              int32_t _2687 = _2686 + _2585;
              int32_t _2688 = _2687 + _I_Vlabels_s0_x_rebased;
              ((int32_t *)_I_Vlabels)[_2688] = _2685;
             } // for _I_Vlabels_s0_x_rebased
            } // for _I_Vlabels_s0_y_rebased
            _labeled_0_free.free();
            {
             int64_t _2689 = 17;
             int64_t _2690 = _2689 * 17;
             int32_t _2691 = _1521 - _1522;
             int64_t _2692 = (_2690 > ((int64_t(1) << 31) - 1)) ? _2690 : (_2690 * _2691);
             if ((_2692 > ((int64_t(1) << 31) - 1)) || ((_2692 * sizeof(int32_t )) > ((int64_t(1) << 31) - 1)))
             {
              halide_error(_ucon, "32-bit signed overflow computing size of allocation out_labeled\n");
              return -1;
             } // overflow test out_labeled
             int64_t _2693 = _2692;
             int32_t *_out_labeled = (int32_t  *)halide_malloc(_ucon, sizeof(int32_t )*_2693);
             if (!((_out_labeled != nullptr) || (_2693 == 0)))
             {
              int32_t _2694 = halide_error_out_of_memory(_ucon);
              return _2694;
             }
             HalideFreeHelper<halide_free> _out_labeled_free(_ucon, _out_labeled);
             int32_t _2695 = _1521 - _1522;
             struct halide_dimension_t s78[3] = {
              {0, 17, 1, 0},
              {0, 17, 17, 0},
              {_1522, _2695, 289, 0},
             };
             auto *_2696 = s78;
             auto _t3894 = _2696;
             halide_maybe_unused(_t3894);
             halide_buffer_t b33;
             auto *_2697 = &b33;
             uint64_t _2698 = (uint64_t)(0ull);
             auto *_2699 = (struct halide_device_interface_t *)(nullptr);
             auto *_2700 = _halide_buffer_init(_2697, _t3894, _out_labeled, _2698, _2699, 0, 32, 3, _t3894, _2698);
             auto _out_labeled_buffer = _2700;
             halide_maybe_unused(_out_labeled_buffer);
             // produce out_labeled
             int32_t _2701 = _1466 * _1468;
             int32_t _2702 = _2701 + _1463;
             float _2703 = (float)(_1484);
             float _2704 = float_from_bits(1031798784 /* 0.0625 */);
             float _2705 = _2703 * _2704;
             float _2706 = floor_f32(_2705);
             int32_t _2707 = (int32_t)(_2706);
             float _2708 = (float)(_2707);
             for (int _out_labeled_s0_p_rebased = 0; _out_labeled_s0_p_rebased < 0 + _2695; _out_labeled_s0_p_rebased++)
             {
              int32_t _2709 = _out_labeled_s0_p_rebased * 289;
              int32_t _2710 = _out_labeled_s0_p_rebased + _1522;
              for (int _out_labeled_s0_y_p = 0; _out_labeled_s0_y_p < 0 + 17; _out_labeled_s0_y_p++)
              {
               bool _2711 = _2710 < 0;
               int32_t _2712 = (int32_t)(_2711 ? -1 : 0);
               bool _2713 = _1484 == 0;
               int32_t _2714 = (int32_t)(_2713 ? -1 : 0);
               bool _2715 = _1484 < 0;
               int32_t _2716 = (int32_t)(_2715 ? -1 : 0);
               int32_t _2717 = _2710 * 16;
               int32_t _2718 = _2717 - _2712;
               int32_t _2719 = _1484 | _2714;
               int32_t _2720 = _2718 % _2719;
               int32_t _2721 = _1484 ^ _2716;
               int32_t _2722 = ~_2716;
               int32_t _2723 = _2721 + _2722;
               int32_t _2724 = _2712 & _2723;
               int32_t _2725 = _2720 + _2724;
               int32_t _2726 = ~_2714;
               int32_t _2727 = _2725 & _2726;
               float _2728 = (float)(_2710);
               float _2729 = _2728 / _2708;
               float _2730 = floor_f32(_2729);
               float _2731 = float_from_bits(1098907648 /* 16 */);
               float _2732 = _2730 * _2731;
               int32_t _2733 = (int32_t)(_2732);
               int32_t _2734 = _out_labeled_s0_y_p + _2733;
               int32_t _2735 = _1487 + -1;
               int32_t _2736 = ::halide_cpp_min(_2734, _2735);
               int32_t _2737 = ::halide_cpp_max(_2736, 0);
               int32_t _2738 = _2737 * _1468;
               int32_t _2739 = _2738 - _2702;
               int32_t _2740 = _out_labeled_s0_y_p * 17;
               int32_t _2741 = _2740 + _2709;
               for (int _out_labeled_s0_x_p = 0; _out_labeled_s0_x_p < 0 + 17; _out_labeled_s0_x_p++)
               {
                int32_t _2742 = _out_labeled_s0_x_p + _2727;
                int32_t _2743 = _1484 + -1;
                int32_t _2744 = ::halide_cpp_min(_2742, _2743);
                int32_t _2745 = ::halide_cpp_max(_2744, 0);
                int32_t _2746 = _2745 + _2739;
                int32_t _2747 = ((int32_t *)_I_Vlabels)[_2746];
                int32_t _2748 = _out_labeled_s0_x_p + _2741;
                _out_labeled[_2748] = _2747;
               } // for _out_labeled_s0_x_p
              } // for _out_labeled_s0_y_p
             } // for _out_labeled_s0_p_rebased
             int32_t _2749 = _1521 + -32;
             int32_t _2750 = ::halide_cpp_min(_2749, _1522);
             int32_t _2751 = _1521 - _1522;
             int32_t _2752 = _2751 + -1;
             int32_t _2753 = _2752 >> 5;
             int32_t _2754 = _2753 * 32;
             int32_t _2755 = _2754 + _1522;
             int32_t _2756 = ::halide_cpp_min(_2755, _2749);
             {
              int64_t _2757 = 4;
              int64_t _2758 = _2757 * 579;
              int32_t _2759 = _2756 - _2750;
              int32_t _2760 = _2759 + 32;
              int64_t _2761 = (_2758 > ((int64_t(1) << 31) - 1)) ? _2758 : (_2758 * _2760);
              if ((_2761 > ((int64_t(1) << 31) - 1)) || ((_2761 * sizeof(int32_t )) > ((int64_t(1) << 31) - 1)))
              {
               halide_error(_ucon, "32-bit signed overflow computing size of allocation patch_init_faces\n");
               return -1;
              } // overflow test patch_init_faces
              int64_t _2762 = _2761;
              int32_t *_patch_init_faces = (int32_t  *)halide_malloc(_ucon, sizeof(int32_t )*_2762);
              if (!((_patch_init_faces != nullptr) || (_2762 == 0)))
              {
               int32_t _2763 = halide_error_out_of_memory(_ucon);
               return _2763;
              }
              HalideFreeHelper<halide_free> _patch_init_faces_free(_ucon, _patch_init_faces);
              int32_t _2764 = _2756 - _2750;
              int32_t _2765 = _2764 + 32;
              struct halide_dimension_t s79[3] = {
               {0, 4, 1, 0},
               {0, 579, 4, 0},
               {_2750, _2765, 2316, 0},
              };
              auto *_2766 = s79;
              auto _t3895 = _2766;
              halide_maybe_unused(_t3895);
              halide_buffer_t b34;
              auto *_2767 = &b34;
              uint64_t _2768 = (uint64_t)(0ull);
              auto *_2769 = (struct halide_device_interface_t *)(nullptr);
              auto *_2770 = _halide_buffer_init(_2767, _t3895, _patch_init_faces, _2768, _2769, 0, 32, 3, _t3895, _2768);
              auto _patch_init_faces_buffer = _2770;
              halide_maybe_unused(_patch_init_faces_buffer);
              // produce patch_init_faces
              int32_t _2771 = _1521 - _1522;
              int32_t _2772 = _2771 + 31;
              int32_t _2773 = _2772 >> 5;
              struct {
               void * f_0;
               int32_t f_1;
               int32_t f_2;
               int32_t f_3;
              } s80 = {
               _patch_init_faces,
               _1521,
               _1522,
               _2750
              };
              auto *_2774 = (&s80);
              auto _parallel_closure__4 = _2774;
              halide_maybe_unused(_parallel_closure__4);
              auto *_2775 = (uint8_t *)(_parallel_closure__4);
              int32_t _2776 = halide_do_par_for(_ucon, ::foreground_mesh_verts_par_for_patch_init_faces_s0_p_v14, 0, _2773, _2775);
              bool _2777 = _2776 == 0;
              if (!_2777)
              {
               return _2776;
              }
              int32_t _2778 = ::halide_cpp_min(_1516, _1522);
              int32_t _2779 = ::halide_cpp_min(_2778, _1503);
              int32_t _2780 = _1517 + _1516;
              int32_t _2781 = ::halide_cpp_max(_2780, _1521);
              int32_t _2782 = _1504 + _1503;
              int32_t _2783 = ::halide_cpp_max(_2781, _2782);
              int32_t _2784 = _1514 + _1513;
              int32_t _2785 = ::halide_cpp_max(_2784, 578);
              int32_t _2786 = ::halide_cpp_min(_1513, 0);
              int32_t _2787 = _2785 - _2786;
              int32_t _2788 = _1511 + _1510;
              int32_t _2789 = ::halide_cpp_max(_2788, 3);
              int32_t _2790 = ::halide_cpp_min(_1510, 0);
              int32_t _2791 = _2789 - _2790;
              {
               int64_t _2792 = _2791;
               int64_t _2793 = _2792 * _2787;
               int32_t _2794 = _2783 - _2779;
               int64_t _2795 = (_2793 > ((int64_t(1) << 31) - 1)) ? _2793 : (_2793 * _2794);
               if ((_2795 > ((int64_t(1) << 31) - 1)) || ((_2795 * sizeof(int32_t )) > ((int64_t(1) << 31) - 1)))
               {
                halide_error(_ucon, "32-bit signed overflow computing size of allocation patch_faces\n");
                return -1;
               } // overflow test patch_faces
               int64_t _2796 = _2795;
               int32_t *_patch_faces = (int32_t  *)halide_malloc(_ucon, sizeof(int32_t )*_2796);
               if (!((_patch_faces != nullptr) || (_2796 == 0)))
               {
                int32_t _2797 = halide_error_out_of_memory(_ucon);
                return _2797;
               }
               HalideFreeHelper<halide_free> _patch_faces_free(_ucon, _patch_faces);
               int32_t _2798 = ::halide_cpp_min(_1510, 0);
               int32_t _2799 = ::halide_cpp_min(_1513, 0);
               int32_t _2800 = _2783 - _2779;
               int32_t _2801 = _2791 * _2787;
               struct halide_dimension_t s81[3] = {
                {_2798, _2791, 1, 0},
                {_2799, _2787, _2791, 0},
                {_2779, _2800, _2801, 0},
               };
               auto *_2802 = s81;
               auto _t3896 = _2802;
               halide_maybe_unused(_t3896);
               halide_buffer_t b35;
               auto *_2803 = &b35;
               uint64_t _2804 = (uint64_t)(0ull);
               auto *_2805 = (struct halide_device_interface_t *)(nullptr);
               auto *_2806 = _halide_buffer_init(_2803, _t3896, _patch_faces, _2804, _2805, 0, 32, 3, _t3896, _2804);
               auto _patch_faces_buffer = _2806;
               halide_maybe_unused(_patch_faces_buffer);
               // produce patch_faces
               // consume patch_init_faces
               // consume out_labeled
               // consume patch_coords
               // consume patched_canny
               int32_t _2807 = _1521 - _1522;
               int32_t _2808 = _2807 >> 5;
               int32_t _2809 = ::halide_cpp_max(_2808, 0);
               int32_t _2810 = _2807 + 31;
               int32_t _2811 = _2810 >> 5;
               int32_t _2812 = ::halide_cpp_max(_1648, 0);
               int32_t _2813 = _2812 - _1647;
               int32_t _2814 = _1646 - _1647;
               struct {
                struct halide_buffer_t * f_0;
                struct halide_buffer_t * f_1;
                struct halide_buffer_t * f_2;
                struct halide_buffer_t * f_3;
                struct halide_buffer_t * f_4;
                int32_t f_5;
                int32_t f_6;
                int32_t f_7;
                int32_t f_8;
                int32_t f_9;
                int32_t f_10;
                int32_t f_11;
                int32_t f_12;
                int32_t f_13;
                int32_t f_14;
                int32_t f_15;
               } s82 = {
                _out_labeled_buffer,
                _patch_coords_buffer,
                _patch_faces_buffer,
                _patch_init_faces_buffer,
                _patched_canny_buffer,
                _2791,
                _2787,
                _1521,
                _1522,
                _1647,
                _2809,
                _2798,
                _2799,
                _2813,
                _2814,
                _2807
               };
               auto *_2815 = (&s82);
               auto _parallel_closure__5 = _2815;
               halide_maybe_unused(_parallel_closure__5);
               auto *_2816 = (uint8_t *)(_parallel_closure__5);
               int32_t _2817 = halide_do_par_for(_ucon, ::foreground_mesh_verts_par_for_patch_faces_s0_p_v14, 0, _2811, _2816);
               bool _2818 = _2817 == 0;
               if (!_2818)
               {
                return _2817;
               }
               _patched_canny_free.free();
               _patch_coords_free.free();
               _out_labeled_free.free();
               _patch_init_faces_free.free();
               // produce P_fore_faces
               // consume patch_faces
               int32_t _2819 = ::halide_cpp_max(_1513, 0);
               int32_t _2820 = ::halide_cpp_max(_1510, 0);
               int32_t _2821 = _1517 + 31;
               int32_t _2822 = _2821 >> 5;
               int32_t _2823 = _2791 * _2787;
               int32_t _2824 = _1516 - _2779;
               int32_t _2825 = _1516 * _1518;
               int32_t _2826 = _1513 * _1515;
               int32_t _2827 = _2825 + _2826;
               int32_t _2828 = 0 - _2827;
               struct {
                void * f_0;
                void * f_1;
                int32_t f_2;
                int32_t f_3;
                int32_t f_4;
                int32_t f_5;
                int32_t f_6;
                int32_t f_7;
                int32_t f_8;
                int32_t f_9;
                int32_t f_10;
                int32_t f_11;
                int32_t f_12;
                int32_t f_13;
                int32_t f_14;
               } s83 = {
                _P_fore_faces,
                _patch_faces,
                _1511,
                _1514,
                _1517,
                _1513,
                _1516,
                _1515,
                _1518,
                _2791,
                _2820,
                _2823,
                _2824,
                _2819,
                _2828
               };
               auto *_2829 = (&s83);
               auto _parallel_closure__6 = _2829;
               halide_maybe_unused(_parallel_closure__6);
               auto *_2830 = (uint8_t *)(_parallel_closure__6);
               int32_t _2831 = halide_do_par_for(_ucon, ::foreground_mesh_verts_par_for_P_fore_faces_s0_p_v14, 0, _2822, _2830);
               bool _2832 = _2831 == 0;
               if (!_2832)
               {
                return _2831;
               }
               // produce P_Nfaces
               // consume patch_faces
               int32_t _2833 = ::halide_cpp_min(_1513, 0);
               int32_t _2834 = ::halide_cpp_min(_1510, 0);
               int32_t _2835 = _2791 * _2787;
               int32_t _2836 = _1503 - _2779;
               struct {
                void * f_0;
                void * f_1;
                int32_t f_2;
                int32_t f_3;
                int32_t f_4;
                int32_t f_5;
                int32_t f_6;
               } s84 = {
                _P_Nfaces,
                _patch_faces,
                _2791,
                _2835,
                _2836,
                _2834,
                _2833
               };
               auto *_2837 = (&s84);
               auto _parallel_closure__7 = _2837;
               halide_maybe_unused(_parallel_closure__7);
               auto *_2838 = (uint8_t *)(_parallel_closure__7);
               int32_t _2839 = halide_do_par_for(_ucon, ::foreground_mesh_verts_par_for_P_Nfaces_s0_p_rebased, 0, _1504, _2838);
               bool _2840 = _2839 == 0;
               if (!_2840)
               {
                return _2839;
               }
               _patch_faces_free.free();
               // produce I_ForeMask
               // consume labeled
               int32_t _2841 = _1456 * _1458;
               int32_t _2842 = 0 - _2841;
               float _2843 = (float)(_1487);
               float _2844 = float_from_bits(1031798784 /* 0.0625 */);
               float _2845 = _2843 * _2844;
               float _2846 = floor_f32(_2845);
               int32_t _2847 = (int32_t)(_2846);
               float _2848 = (float)(_1484);
               float _2849 = _2848 * _2844;
               float _2850 = floor_f32(_2849);
               int32_t _2851 = (int32_t)(_2850);
               for (int _I_ForeMask_s0_y_rebased = 0; _I_ForeMask_s0_y_rebased < 0 + _1457; _I_ForeMask_s0_y_rebased++)
               {
                int32_t _2852 = _1456 + _I_ForeMask_s0_y_rebased;
                bool _2853 = 0 < _2852;
                int32_t _2854 = _1487 + -1;
                bool _2855 = _2852 < _2854;
                bool _2856 = _2853 && _2855;
                int32_t _2857 = _2852 & 15;
                bool _2858 = _2857 == 0;
                bool _2859 = _2856 && _2858;
                int32_t _2860 = _2851 * _2847;
                float _2861 = (float)(_2852);
                float _2862 = float_from_bits(1031798784 /* 0.0625 */);
                float _2863 = _2861 * _2862;
                float _2864 = floor_f32(_2863);
                int32_t _2865 = (int32_t)(_2864);
                int32_t _2866 = _2851 * _2865;
                for (int _I_ForeMask_s0_x_rebased = 0; _I_ForeMask_s0_x_rebased < 0 + _1454; _I_ForeMask_s0_x_rebased++)
                {
                 int32_t _2867 = _1453 + _I_ForeMask_s0_x_rebased;
                 bool _2868 = 0 < _2867;
                 int32_t _2869 = _1484 + -1;
                 bool _2870 = _2867 < _2869;
                 bool _2871 = _2868 && _2870;
                 int32_t _2872 = _2867 & 15;
                 bool _2873 = _2872 == 0;
                 bool _2874 = _2871 && _2873;
                 float _2875 = (float)(_2867);
                 float _2876 = float_from_bits(1031798784 /* 0.0625 */);
                 float _2877 = _2875 * _2876;
                 float _2878 = floor_f32(_2877);
                 int32_t _2879 = (int32_t)(_2878);
                 int32_t _2880 = _2866 + _2879;
                 bool _2881 = 0 < _2880;
                 int32_t _2882 = _2860 + -1;
                 bool _2883 = _2880 < _2882;
                 bool _2884 = _2881 && _2883;
                 int32_t _2885 = ::halide_cpp_max(_2880, 1);
                 int32_t _2886 = _2885 - _2506;
                 int32_t _2887 = _2880 - _2851;
                 int32_t _2888 = _2880 - _2506;
                 int32_t _2889 = ::halide_cpp_max(_2887, 0);
                 int32_t _2890 = _2889 - _2506;
                 int32_t _2891 = _2852 & 15;
                 int32_t _2892 = _2888 * 17;
                 int32_t _2893 = _2892 + _2891;
                 int32_t _2894 = _2886 * 289;
                 int32_t _2895 = _2894 + -273;
                 int32_t _2896 = _labeled_1[_2895];
                 int32_t _2897 = ::halide_cpp_max(_2887, 1);
                 int32_t _2898 = _2897 - _2506;
                 int32_t _2899 = _2898 * 289;
                 int32_t _2900 = _2899 + -1;
                 int32_t _2901 = _labeled_1[_2900];
                 int32_t _2902 = _2888 * 289;
                 int32_t _2903 = _labeled_1[_2902];
                 int32_t _2904 = _2890 * 289;
                 int32_t _2905 = _2904 + 272;
                 int32_t _2906 = _labeled_1[_2905];
                 int32_t _2907 = ::halide_cpp_max(_2903, _2906);
                 int32_t _2908 = ::halide_cpp_max(_2901, _2907);
                 int32_t _2909 = ::halide_cpp_max(_2896, _2908);
                 bool _2910 = 0 < _2909;
                 int32_t _2911 = (int32_t)(_2910 ? 1 : 0);
                 int32_t _2912 = _2893 * 17;
                 int32_t _2913 = _2912 + _2872;
                 int32_t _2914 = _labeled_1[_2913];
                 bool _2915 = _2874 && _2859;
                 bool _2916 = _2915 && _2884;
                 int32_t _2917 = (int32_t)(_2916 ? _2911 : _2914);
                 int32_t _2918 = _2902 + _2872;
                 int32_t _2919 = _labeled_1[_2918];
                 int32_t _2920 = _2904 + _2872;
                 int32_t _2921 = _2920 + 272;
                 int32_t _2922 = _labeled_1[_2921];
                 int32_t _2923 = ::halide_cpp_max(_2919, _2922);
                 bool _2924 = 0 < _2923;
                 int32_t _2925 = (int32_t)(_2924 ? 1 : 0);
                 bool _2926 = _2884 && _2859;
                 bool _2927 = !(_2926);
                 bool _2928 = _2927 || _2874;
                 int32_t _2929 = (int32_t)(_2928 ? _2917 : _2925);
                 int32_t _2930 = _labeled_1[_2912];
                 int32_t _2931 = _2886 * 17;
                 int32_t _2932 = _2931 + _2891;
                 int32_t _2933 = _2932 * 17;
                 int32_t _2934 = _2933 + -273;
                 int32_t _2935 = _labeled_1[_2934];
                 int32_t _2936 = ::halide_cpp_max(_2930, _2935);
                 bool _2937 = 0 < _2936;
                 int32_t _2938 = (int32_t)(_2937 ? 1 : 0);
                 bool _2939 = _2874 && _2884;
                 bool _2940 = !(_2939);
                 bool _2941 = _2940 || _2859;
                 int32_t _2942 = (int32_t)(_2941 ? _2929 : _2938);
                 int32_t _2943 = _1458 * _2852;
                 int32_t _2944 = _2943 + _2842;
                 int32_t _2945 = _2944 + _I_ForeMask_s0_x_rebased;
                 ((int32_t *)_I_ForeMask)[_2945] = _2942;
                } // for _I_ForeMask_s0_x_rebased
               } // for _I_ForeMask_s0_y_rebased
               _labeled_1_free.free();
              } // alloc _patch_faces
             } // alloc _patch_init_faces
            } // alloc _out_labeled
           } // alloc _labeled_1
          } // alloc _labeled_0
         } // alloc _mean_b_depth
        } // alloc _mean_depth
       } // alloc _sum_p_b_canny
      } // alloc _sum_p_canny
     } // alloc _patched_b_canny
    } // alloc _patched_depth
   } // alloc _patch_coords
  } // alloc _patched_canny
 } // if _1807
 return 0;
}

HALIDE_FUNCTION_ATTRS
int foreground_mesh_verts_argv(void **args) {
 return foreground_mesh_verts(
  (halide_buffer_t *)args[0],
  (halide_buffer_t *)args[1],
  (halide_buffer_t *)args[2],
  (halide_buffer_t *)args[3],
  (halide_buffer_t *)args[4],
  (halide_buffer_t *)args[5],
  (halide_buffer_t *)args[6]
);
}
HALIDE_FUNCTION_ATTRS
const struct halide_filter_metadata_t *foreground_mesh_verts_metadata() {
 int64_t const *const *buffer_estimates__I_canny = nullptr;
 const halide_scalar_value_t *scalar_def__I_canny = nullptr;
 const halide_scalar_value_t *scalar_min__I_canny = nullptr;
 const halide_scalar_value_t *scalar_max__I_canny = nullptr;
 const halide_scalar_value_t *scalar_estimate__I_canny = nullptr;
 int64_t const *const *buffer_estimates__I_back_canny = nullptr;
 const halide_scalar_value_t *scalar_def__I_back_canny = nullptr;
 const halide_scalar_value_t *scalar_min__I_back_canny = nullptr;
 const halide_scalar_value_t *scalar_max__I_back_canny = nullptr;
 const halide_scalar_value_t *scalar_estimate__I_back_canny = nullptr;
 int64_t const *const *buffer_estimates__I_depth = nullptr;
 const halide_scalar_value_t *scalar_def__I_depth = nullptr;
 const halide_scalar_value_t *scalar_min__I_depth = nullptr;
 const halide_scalar_value_t *scalar_max__I_depth = nullptr;
 const halide_scalar_value_t *scalar_estimate__I_depth = nullptr;
 int64_t const *const *buffer_estimates__P_fore_faces = nullptr;
 const halide_scalar_value_t *scalar_def__P_fore_faces = nullptr;
 const halide_scalar_value_t *scalar_min__P_fore_faces = nullptr;
 const halide_scalar_value_t *scalar_max__P_fore_faces = nullptr;
 const halide_scalar_value_t *scalar_estimate__P_fore_faces = nullptr;
 int64_t const *const *buffer_estimates__P_Nfaces = nullptr;
 const halide_scalar_value_t *scalar_def__P_Nfaces = nullptr;
 const halide_scalar_value_t *scalar_min__P_Nfaces = nullptr;
 const halide_scalar_value_t *scalar_max__P_Nfaces = nullptr;
 const halide_scalar_value_t *scalar_estimate__P_Nfaces = nullptr;
 int64_t const *const *buffer_estimates__I_Vlabels = nullptr;
 const halide_scalar_value_t *scalar_def__I_Vlabels = nullptr;
 const halide_scalar_value_t *scalar_min__I_Vlabels = nullptr;
 const halide_scalar_value_t *scalar_max__I_Vlabels = nullptr;
 const halide_scalar_value_t *scalar_estimate__I_Vlabels = nullptr;
 int64_t const *const *buffer_estimates__I_ForeMask = nullptr;
 const halide_scalar_value_t *scalar_def__I_ForeMask = nullptr;
 const halide_scalar_value_t *scalar_min__I_ForeMask = nullptr;
 const halide_scalar_value_t *scalar_max__I_ForeMask = nullptr;
 const halide_scalar_value_t *scalar_estimate__I_ForeMask = nullptr;
 static const halide_filter_argument_t args[7] = {
  {
   "I_canny",
   halide_argument_kind_input_buffer,
   2,
   {halide_type_uint, 8, 1},
   scalar_def__I_canny,
   scalar_min__I_canny,
   scalar_max__I_canny,
   scalar_estimate__I_canny,
   buffer_estimates__I_canny,
   },
  {
   "I_back_canny",
   halide_argument_kind_input_buffer,
   2,
   {halide_type_uint, 8, 1},
   scalar_def__I_back_canny,
   scalar_min__I_back_canny,
   scalar_max__I_back_canny,
   scalar_estimate__I_back_canny,
   buffer_estimates__I_back_canny,
   },
  {
   "I_depth",
   halide_argument_kind_input_buffer,
   2,
   {halide_type_uint, 8, 1},
   scalar_def__I_depth,
   scalar_min__I_depth,
   scalar_max__I_depth,
   scalar_estimate__I_depth,
   buffer_estimates__I_depth,
   },
  {
   "P_fore_faces",
   halide_argument_kind_output_buffer,
   3,
   {halide_type_int, 32, 1},
   scalar_def__P_fore_faces,
   scalar_min__P_fore_faces,
   scalar_max__P_fore_faces,
   scalar_estimate__P_fore_faces,
   buffer_estimates__P_fore_faces,
   },
  {
   "P_Nfaces",
   halide_argument_kind_output_buffer,
   1,
   {halide_type_int, 32, 1},
   scalar_def__P_Nfaces,
   scalar_min__P_Nfaces,
   scalar_max__P_Nfaces,
   scalar_estimate__P_Nfaces,
   buffer_estimates__P_Nfaces,
   },
  {
   "I_Vlabels",
   halide_argument_kind_output_buffer,
   2,
   {halide_type_int, 32, 1},
   scalar_def__I_Vlabels,
   scalar_min__I_Vlabels,
   scalar_max__I_Vlabels,
   scalar_estimate__I_Vlabels,
   buffer_estimates__I_Vlabels,
   },
  {
   "I_ForeMask",
   halide_argument_kind_output_buffer,
   2,
   {halide_type_int, 32, 1},
   scalar_def__I_ForeMask,
   scalar_min__I_ForeMask,
   scalar_max__I_ForeMask,
   scalar_estimate__I_ForeMask,
   buffer_estimates__I_ForeMask,
   },
  };
 static const halide_filter_metadata_t md = {
  halide_filter_metadata_t::VERSION,
  7,
  args,
  "x86-64-linux-avx-avx2-f16c-fma-no_runtime-sse41",
  "foreground_mesh_verts",
  };
 return &md;
}

#ifdef __cplusplus
}  // extern "C"
#endif

